{"version":3,"sources":["../src/config/config.ts","../src/schema/columns.ts","../src/schema/schema.ts","../src/utils/mergeAbis.ts"],"sourcesContent":["import type { Prettify } from \"@/types/utils.js\";\nimport type { Abi } from \"abitype\";\nimport { type Narrow, type Transport } from \"viem\";\nimport type { GetAddress } from \"./address.js\";\nimport type { GetEventFilter } from \"./eventFilter.js\";\nimport type { NonStrictPick } from \"./utilityTypes.js\";\n\nexport type BlockConfig = {\n  /** Block number at which to start indexing events (inclusive). If `undefined`, events will be processed from block 0. Default: `undefined`. */\n  startBlock?: number;\n  /** Block number at which to stop indexing events (inclusive). If `undefined`, events will be processed in real-time. Default: `undefined`. */\n  endBlock?: number;\n  /** Maximum block range to use when calling `eth_getLogs`. Default: `10_000`. */\n  maxBlockRange?: number;\n};\n\ntype DatabaseConfig =\n  | {\n      kind: \"sqlite\";\n      /** Path to SQLite database file. Default: `\".ponder/store\"`. */\n      filename?: string;\n    }\n  | {\n      kind: \"postgres\";\n      /** PostgreSQL database connection string. Default: `process.env.DATABASE_PRIVATE_URL` or `process.env.DATABASE_URL`. */\n      connectionString?: string;\n    };\n\nexport type OptionConfig = {\n  /** Maximum number of seconds to wait for event processing to be complete before responding as healthy. If event processing exceeds this duration, the API may serve incomplete data. Default: `240` (4 minutes). */\n  maxHealthcheckDuration?: number;\n};\n\nexport type NetworkConfig<network> = {\n  /** Chain ID of the network. */\n  chainId: network extends { chainId: infer chainId extends number }\n    ? chainId | number\n    : number;\n  /** A viem `http`, `webSocket`, or `fallback` [Transport](https://viem.sh/docs/clients/transports/http.html).\n   *\n   * __To avoid rate limiting, include a custom RPC URL.__ Usage:\n   *\n   * ```ts\n   * import { http } from \"viem\";\n   *\n   * const network = {\n   *    name: \"mainnet\",\n   *    chainId: 1,\n   *    transport: http(\"https://eth-mainnet.g.alchemy.com/v2/...\"),\n   * }\n   * ```\n   */\n  transport: Transport;\n  /** Polling frequency (in ms). Default: `1_000`. */\n  pollingInterval?: number;\n  /** Maximum number of RPC requests per second. Default: `50`. */\n  maxRequestsPerSecond?: number;\n  /** (Deprecated) Maximum concurrency of tasks during the historical sync. Default: `20`. */\n  maxHistoricalTaskConcurrency?: number;\n};\n\ntype AbiConfig<abi extends Abi | readonly unknown[]> = {\n  /** Contract application byte interface. */\n  abi: abi;\n};\n\ntype GetNetwork<\n  networks,\n  contract,\n  abi extends Abi,\n  ///\n  allNetworkNames extends string = [keyof networks] extends [never]\n    ? string\n    : keyof networks & string,\n> = contract extends { network: infer network }\n  ? {\n      /**\n       * Network that this contract is deployed to. Must match a network name in `networks`.\n       * Any filter information overrides the values in the higher level \"contracts\" property.\n       * Factories cannot override an address and vice versa.\n       */\n      network:\n        | allNetworkNames\n        | {\n            [name in allNetworkNames]?: Prettify<\n              GetAddress<NonStrictPick<network, \"factory\" | \"address\">> &\n                GetEventFilter<abi, NonStrictPick<contract, \"filter\">> &\n                BlockConfig\n            >;\n          };\n    }\n  : {\n      /**\n       * Network that this contract is deployed to. Must match a network name in `networks`.\n       * Any filter information overrides the values in the higher level \"contracts\" property.\n       * Factories cannot override an address and vice versa.\n       */\n      network:\n        | allNetworkNames\n        | {\n            [name in allNetworkNames]?: Prettify<\n              GetAddress<unknown> & GetEventFilter<abi, unknown> & BlockConfig\n            >;\n          };\n    };\n\ntype ContractConfig<networks, contract, abi extends Abi> = Prettify<\n  AbiConfig<abi> &\n    GetNetwork<networks, NonStrictPick<contract, \"network\">, abi> &\n    GetAddress<NonStrictPick<contract, \"factory\" | \"address\">> &\n    GetEventFilter<abi, NonStrictPick<contract, \"filter\">> &\n    BlockConfig\n>;\n\ntype GetContract<networks = unknown, contract = unknown> = contract extends {\n  abi: infer abi extends Abi;\n}\n  ? // 1. Contract has a valid abi\n    ContractConfig<networks, contract, abi>\n  : // 2. Contract has an invalid abi\n    ContractConfig<networks, contract, Abi>;\n\ntype ContractsConfig<networks, contracts> = {} extends contracts\n  ? // contracts empty, return empty\n    {}\n  : {\n      [name in keyof contracts]: GetContract<networks, contracts[name]>;\n    };\n\ntype NetworksConfig<networks> = {} extends networks\n  ? {}\n  : {\n      [networkName in keyof networks]: NetworkConfig<networks[networkName]>;\n    };\n\nexport const createConfig = <const networks, const contracts>(config: {\n  // TODO: add jsdoc to these properties.\n  networks: NetworksConfig<Narrow<networks>>;\n  contracts: ContractsConfig<networks, Narrow<contracts>>;\n  database?: DatabaseConfig;\n  options?: OptionConfig;\n}): CreateConfigReturnType<networks, contracts> =>\n  config as CreateConfigReturnType<networks, contracts>;\n\nexport type Config = {\n  networks: { [name: string]: NetworkConfig<unknown> };\n  contracts: { [name: string]: GetContract };\n  database?: DatabaseConfig;\n  options?: OptionConfig;\n};\n\nexport type CreateConfigReturnType<networks, contracts> = {\n  networks: networks;\n  contracts: contracts;\n  database?: DatabaseConfig;\n  options?: OptionConfig;\n};\n","import type {\n  BaseColumn,\n  InternalColumn,\n  InternalEnum,\n  ManyColumn,\n  OneColumn,\n  Scalar,\n} from \"./types.js\";\n\ntype Optional<\n  TScalar extends Scalar,\n  TReferences extends `${string}.id` | undefined,\n  TList extends boolean,\n> = () => TReferences extends undefined\n  ? TList extends true\n    ? InternalColumn<TScalar, TReferences, true, TList>\n    : InternalColumn<TScalar, TReferences, true, TList> & {\n        /**\n         * Mark the column as optional.\n         *\n         * - Docs: https://ponder.sh/docs/guides/design-your-schema#optional\n         *\n         * @example\n         * import { p } from '@ponder/core'\n         *\n         * export default p.createSchema({\n         *   t: p.createTable({\n         *     id: p.string(),\n         *     o: p.int().optional(),\n         *   })\n         * })\n         */\n        list: List<TScalar, true>;\n        /**\n         * Mark the column as a foreign key.\n         *\n         * - Docs: https://ponder.sh/docs/guides/design-your-schema#foreign-key\n         *\n         * @param references Table that this column is a key of.\n         *\n         * @example\n         * import { p } from '@ponder/core'\n         *\n         * export default p.createSchema({\n         *   a: p.createTable({\n         *     id: p.string(),\n         *     b_id: p.string.references(\"b.id\"),\n         *   })\n         *   b: p.createTable({\n         *     id: p.string(),\n         *   })\n         * })\n         */\n        references: References<TScalar, true>;\n      }\n  : InternalColumn<TScalar, TReferences, true, TList>;\n\n/**\n * Helper function for optional modifier\n */\nconst optional = <\n  TScalar extends Scalar,\n  TReferences extends `${string}.id` | undefined,\n  TList extends boolean,\n>(\n  column: BaseColumn<TScalar, TReferences, false, TList>,\n): Optional<TScalar, TReferences, TList> =>\n  (() => {\n    const newColumn = { ...column, optional: true } as const;\n\n    return column.list || column.references !== undefined\n      ? {\n          \" column\": newColumn,\n        }\n      : {\n          \" column\": newColumn,\n          list: list(newColumn as BaseColumn<TScalar, undefined, true, false>),\n          references: references(\n            newColumn as BaseColumn<TScalar, undefined, true, false>,\n          ),\n        };\n  }) as Optional<TScalar, TReferences, TList>;\n\ntype List<\n  TScalar extends Scalar,\n  TOptional extends boolean,\n> = () => TOptional extends true\n  ? InternalColumn<TScalar, undefined, TOptional, true>\n  : InternalColumn<TScalar, undefined, TOptional, true> & {\n      /**\n       * Mark the column as optional.\n       *\n       * - Docs: https://ponder.sh/docs/guides/design-your-schema#optional\n       *\n       * @example\n       * import { p } from '@ponder/core'\n       *\n       * export default p.createSchema({\n       *   t: p.createTable({\n       *     id: p.string(),\n       *     o: p.int().optional(),\n       *   })\n       * })\n       */\n      optional: Optional<TScalar, undefined, true>;\n    };\n\n/**\n * Helper function for list modifier\n *\n * List columns can't be references\n */\nconst list = <TScalar extends Scalar, TOptional extends boolean>(\n  column: BaseColumn<TScalar, undefined, TOptional, false>,\n): List<TScalar, TOptional> =>\n  (() => {\n    const newColumn = { ...column, list: true } as const;\n    return column.optional\n      ? {\n          \" column\": newColumn,\n        }\n      : {\n          \" column\": newColumn,\n          optional: optional(\n            newColumn as BaseColumn<TScalar, undefined, false, true>,\n          ),\n        };\n  }) as List<TScalar, TOptional>;\n\ntype References<TScalar extends Scalar, TOptional extends boolean> = <\n  TReferences extends `${string}.id`,\n>(references: TReferences) => TOptional extends true\n  ? InternalColumn<TScalar, TReferences, TOptional, false>\n  : InternalColumn<TScalar, TReferences, TOptional, false> & {\n      /**\n       * Mark the column as optional.\n       *\n       * - Docs: https://ponder.sh/docs/guides/design-your-schema#optional\n       *\n       * @example\n       * import { p } from '@ponder/core'\n       *\n       * export default p.createSchema({\n       *   t: p.createTable({\n       *     id: p.string(),\n       *     o: p.int().optional(),\n       *   })\n       * })\n       */\n      optional: Optional<TScalar, TReferences, false>;\n    };\n\n/**\n * Helper function for reference modifier\n *\n * Reference columns can't be lists\n */\nconst references = <TScalar extends Scalar, TOptional extends boolean>(\n  column: BaseColumn<TScalar, undefined, TOptional, false>,\n): References<TScalar, TOptional> =>\n  (<TReferences extends `${string}.id`>(references: TReferences) => {\n    const newColumn = { ...column, references } as const;\n\n    return column.optional\n      ? { \" column\": newColumn }\n      : {\n          \" column\": newColumn,\n          optional: optional(\n            newColumn as BaseColumn<TScalar, TReferences, false, false>,\n          ),\n        };\n  }) as References<TScalar, TOptional>;\n\nexport type EmptyModifier<TScalar extends Scalar> = InternalColumn<\n  TScalar,\n  undefined,\n  false,\n  false\n> & {\n  /**\n   * Mark the column as optional.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#optional\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default p.createSchema({\n   *   t: p.createTable({\n   *     id: p.string(),\n   *     o: p.int().optional(),\n   *   })\n   * })\n   */\n  optional: Optional<TScalar, undefined, false>;\n  /**\n   * Mark the column as a list.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#list\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default p.createSchema({\n   *   t: p.createTable({\n   *     id: p.string(),\n   *     l: p.int().list(),\n   *   })\n   * })\n   */\n  list: List<TScalar, false>;\n  /**\n   * Mark the column as a foreign key.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#foreign-key\n   *\n   * @param references Table that this column is a key of.\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default p.createSchema({\n   *   a: p.createTable({\n   *     id: p.string(),\n   *     b_id: p.string.references(\"b.id\"),\n   *   })\n   *   b: p.createTable({\n   *     id: p.string(),\n   *   })\n   * })\n   */\n  references: References<TScalar, false>;\n};\n\nconst emptyColumn =\n  <TScalar extends Scalar>(scalar: TScalar) =>\n  (): EmptyModifier<TScalar> => {\n    const column = {\n      _type: \"b\",\n      type: scalar,\n      references: undefined,\n      optional: false,\n      list: false,\n    } as const;\n\n    return {\n      \" column\": column,\n      optional: optional(column),\n      list: list(column),\n      references: references(column),\n    };\n  };\n\nexport type _Enum<\n  TType extends string,\n  TOptional extends boolean,\n  TList extends boolean,\n> = InternalEnum<TType, TOptional, TList> &\n  (TOptional extends true\n    ? {}\n    : {\n        /**\n         * Mark the column as optional.\n         *\n         * - Docs: https://ponder.sh/docs/guides/design-your-schema#optional\n         *\n         * @example\n         * import { p } from '@ponder/core'\n         *\n         * export default p.createSchema({\n         *   e: p.createEnum([\"ONE\", \"TWO\"])\n         *   t: p.createTable({\n         *     id: p.string(),\n         *     a: p.enum(\"e\").optional(),\n         *   })\n         * })\n         */\n        optional: () => _Enum<TType, true, TList>;\n      }) &\n  (TList extends true\n    ? {}\n    : {\n        /**\n         * Mark the column as a list.\n         *\n         * - Docs: https://ponder.sh/docs/guides/design-your-schema#list\n         *\n         * @example\n         * import { p } from '@ponder/core'\n         *\n         * export default p.createSchema({\n         *   e: p.createEnum([\"ONE\", \"TWO\"])\n         *   t: p.createTable({\n         *     id: p.string(),\n         *     a: p.enum(\"e\").list(),\n         *   })\n         * })\n         */\n        list: () => _Enum<TType, TOptional, true>;\n      });\n\nexport const _enum = <TType extends string>(\n  type: TType,\n): _Enum<TType, false, false> => ({\n  \" enum\": {\n    _type: \"e\",\n    type,\n    optional: false,\n    list: false,\n  },\n  optional: () => ({\n    \" enum\": {\n      _type: \"e\",\n      type,\n      optional: true,\n      list: false,\n    },\n    list: () => ({\n      \" enum\": {\n        _type: \"e\",\n        type,\n        optional: true,\n        list: true,\n      },\n    }),\n  }),\n\n  list: () => ({\n    \" enum\": {\n      _type: \"e\",\n      type,\n      list: true,\n      optional: false,\n    },\n    optional: () => ({\n      \" enum\": {\n        _type: \"e\",\n        type,\n        optional: true,\n        list: true,\n      },\n    }),\n  }),\n});\n\nexport const string = emptyColumn(\"string\");\nexport const int = emptyColumn(\"int\");\nexport const float = emptyColumn(\"float\");\nexport const boolean = emptyColumn(\"boolean\");\nexport const hex = emptyColumn(\"hex\");\nexport const bigint = emptyColumn(\"bigint\");\n\nexport const one = <T extends string>(derivedColumn: T): OneColumn<T> =>\n  ({\n    _type: \"o\",\n    referenceColumn: derivedColumn,\n  }) as OneColumn<T>;\n\nexport const many = <T extends `${string}.${string}`>(\n  derived: T,\n): ManyColumn<T> =>\n  ({\n    _type: \"m\",\n    referenceTable: derived.split(\".\")[0],\n    referenceColumn: derived.split(\".\")[1],\n  }) as ManyColumn<T>;\n","import {\n  type EmptyModifier,\n  type _Enum,\n  _enum,\n  bigint,\n  boolean,\n  float,\n  hex,\n  int,\n  many,\n  one,\n  string,\n} from \"./columns.js\";\nimport type {\n  Enum,\n  EnumColumn,\n  ExtractAllNames,\n  FilterEnums,\n  FilterTables,\n  ID,\n  IDColumn,\n  InternalColumn,\n  InternalEnum,\n  ManyColumn,\n  NonReferenceColumn,\n  OneColumn,\n  ReferenceColumn,\n  Scalar,\n  Table,\n} from \"./types.js\";\n\n/**\n * Fix issue with Array.isArray not checking readonly arrays\n * {@link https://github.com/microsoft/TypeScript/issues/17002}\n */\ndeclare global {\n  interface ArrayConstructor {\n    isArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>;\n  }\n}\n\nexport const createTable = <\n  TColumns extends\n    | ({\n        id: { \" column\": IDColumn };\n      } & Record<\n        string,\n        InternalEnum | InternalColumn | ManyColumn | OneColumn\n      >)\n    | unknown =\n    | ({\n        id: { \" column\": IDColumn };\n      } & Record<\n        string,\n        InternalEnum | InternalColumn | ManyColumn | OneColumn\n      >)\n    | unknown,\n>(\n  columns: TColumns,\n): {\n  [key in keyof TColumns]: TColumns[key] extends InternalColumn\n    ? TColumns[key][\" column\"]\n    : TColumns[key] extends InternalEnum\n      ? TColumns[key][\" enum\"]\n      : TColumns[key];\n} =>\n  Object.entries(\n    columns as {\n      id: { \" column\": IDColumn };\n    } & Record<string, InternalEnum | InternalColumn | ManyColumn | OneColumn>,\n  ).reduce(\n    (\n      acc: Record<\n        string,\n        | NonReferenceColumn\n        | ReferenceColumn\n        | EnumColumn\n        | ManyColumn\n        | OneColumn\n      >,\n      cur,\n    ) => ({\n      ...acc,\n      [cur[0]]:\n        \" column\" in cur[1]\n          ? (cur[1][\" column\"] as NonReferenceColumn | ReferenceColumn)\n          : \" enum\" in cur[1]\n            ? cur[1][\" enum\"]\n            : cur[1],\n    }),\n    {},\n  ) as {\n    [key in keyof TColumns]: TColumns[key] extends InternalColumn\n      ? TColumns[key][\" column\"]\n      : TColumns[key] extends InternalEnum\n        ? TColumns[key][\" enum\"]\n        : TColumns[key];\n  };\n\nexport const createEnum = <const TEnum extends Enum>(_enum: TEnum) => _enum;\n\nconst P = {\n  createEnum,\n  createTable,\n  string,\n  bigint,\n  int,\n  float,\n  hex,\n  boolean,\n  one,\n  many,\n  enum: _enum,\n};\n\ntype P = {\n  /**\n   * Primitive `string` column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#primitives\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.string(),\n   *   })\n   * })\n   */\n  string: () => EmptyModifier<\"string\">;\n  /**\n   * Primitive `int` column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#primitives\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.int(),\n   *   })\n   * })\n   */\n  int: () => EmptyModifier<\"int\">;\n  /**\n   * Primitive `float` column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#primitives\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.string(),\n   *     f: p.float(),\n   *   })\n   * })\n   */\n  float: () => EmptyModifier<\"float\">;\n  /**\n   * Primitive `hex` column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#primitives\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.hex(),\n   *   })\n   * })\n   */\n  hex: () => EmptyModifier<\"hex\">;\n  /**\n   * Primitive `boolean` column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#primitives\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.string(),\n   *     b: p.boolean(),\n   *   })\n   * })\n   */\n  boolean: () => EmptyModifier<\"boolean\">;\n  /**\n   * Primitive `bigint` column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#primitives\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.bigint(),\n   *   })\n   * })\n   */\n  bigint: () => EmptyModifier<\"bigint\">;\n  /**\n   * Custom defined allowable value column type.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#enum\n   *\n   * @param type Enum defined elsewhere in the schema with `p.createEnum()`.\n   *\n   * @example\n   * export default createSchema({\n   *   e: p.createEnum([\"ONE\", \"TWO\"])\n   *   t: p.createTable({\n   *     id: p.string(),\n   *     a: p.enum(\"e\"),\n   *   })\n   * })\n   */\n  enum: <TType extends string>(type: TType) => _Enum<TType, false, false>;\n  /**\n   * One-to-one column type.`one` columns don't exist in the database. They are only present when querying data from the GraphQL API.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#one-to-one\n   *\n   * @param reference Reference column to be resolved.\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   a: p.createTable({\n   *     id: p.string(),\n   *     b_id: p.string.references(\"b.id\"),\n   *     b: p.one(\"b_id\"),\n   *   })\n   *   b: p.createTable({\n   *     id: p.string(),\n   *   })\n   * })\n   */\n  one: <T extends string>(derivedColumn: T) => OneColumn<T>;\n  /**\n   * Many-to-one column type. `many` columns don't exist in the database. They are only present when querying data from the GraphQL API.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#one-to-many\n   *\n   * @param reference Reference column that references the `id` column of the current table.\n   *\n   * @example\n   * import { p } from '@ponder/core'\n   *\n   * export default createSchema({\n   *   a: p.createTable({\n   *     id: p.string(),\n   *     ref: p.string.references(\"b.id\"),\n   *   })\n   *   b: p.createTable({\n   *     id: p.string(),\n   *     m: p.many(\"a.ref\"),\n   *   })\n   * })\n   */\n  many: <T extends `${string}.${string}`>(derived: T) => ManyColumn<T>;\n  /**\n   * Create an Enum type for the database.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#tables\n   *\n   * @example\n   * export default createSchema({\n   *   e: p.createEnum([\"ONE\", \"TWO\"])\n   *   t: p.createTable({\n   *     id: p.string(),\n   *     a: p.enum(\"e\"),\n   *   })\n   * })\n   */\n  createEnum: typeof createEnum;\n  /**\n   * Create a database table.\n   *\n   * - Docs: https://ponder.sh/docs/guides/design-your-schema#tables\n   *\n   * @example\n   * export default createSchema({\n   *   t: p.createTable({\n   *     id: p.string(),\n   *   })\n   * })\n   */\n  createTable: typeof createTable;\n};\n\n/**\n * Create a database schema.\n *\n * - Docs: https://ponder.sh/docs/guides/design-your-schema#tables\n *\n * @example\n * export default createSchema({\n *   t: p.createTable({\n *     id: p.string(),\n *   })\n * })\n */\nexport const createSchema = <\n  TSchema extends {\n    [tableName in keyof TSchema]:\n      | ({ id: NonReferenceColumn<ID, false, false> } & {\n          [columnName in keyof TSchema[tableName]]:\n            | NonReferenceColumn\n            | ReferenceColumn<\n                Scalar,\n                `${keyof FilterTables<TSchema> & string}.id`\n              >\n            | EnumColumn<keyof FilterEnums<TSchema>, boolean, boolean>\n            | ManyColumn<ExtractAllNames<tableName & string, TSchema>>\n            | OneColumn<Exclude<keyof TSchema[tableName], columnName>>;\n        })\n      | Enum<readonly string[]>;\n  },\n>(\n  _schema: (p: P) => TSchema,\n): {\n  tables: { [key in keyof FilterTables<TSchema>]: TSchema[key] };\n  enums: {\n    [key in keyof FilterEnums<TSchema>]: TSchema[key];\n  };\n} => {\n  const schema = _schema(P);\n  return Object.entries(schema).reduce(\n    (\n      acc: {\n        enums: Record<string, Enum>;\n        tables: Record<string, Table>;\n      },\n      [name, tableOrEnum],\n    ) =>\n      Array.isArray(tableOrEnum)\n        ? { ...acc, enums: { ...acc.enums, [name]: tableOrEnum } }\n        : {\n            ...acc,\n            tables: { ...acc.tables, [name]: tableOrEnum },\n          },\n    { tables: {}, enums: {} },\n  ) as {\n    tables: { [key in keyof FilterTables<TSchema>]: TSchema[key] };\n    enums: {\n      [key in keyof FilterEnums<TSchema>]: TSchema[key];\n    };\n  };\n};\n","import type { Abi } from \"abitype\";\nimport type { AbiItem } from \"viem\";\nimport { formatAbiItem } from \"viem/utils\";\n\nexport type MergeAbi<\n  TBase extends Abi,\n  TInsert extends Abi,\n> = TInsert extends readonly [\n  infer First extends AbiItem,\n  ...infer Rest extends Abi,\n]\n  ? Extract<TBase[number], First> extends never\n    ? First[\"type\"] extends \"constructor\" | \"receive\" | \"fallback\"\n      ? MergeAbi<TBase, Rest>\n      : MergeAbi<readonly [...TBase, First], Rest>\n    : MergeAbi<TBase, Rest>\n  : TBase;\n\ntype MergeAbis<\n  TAbis extends readonly Abi[],\n  TMerged extends Abi = [],\n> = TAbis extends readonly [\n  infer First extends Abi,\n  ...infer Rest extends readonly Abi[],\n]\n  ? MergeAbis<Rest, MergeAbi<TMerged, First>>\n  : TMerged;\n\nconst isAbiItemEqual = (a: AbiItem, b: AbiItem): boolean =>\n  formatAbiItem(a) === formatAbiItem(b);\n\n/**\n * Combine multiple ABIs into one, removing duplicates if necessary.\n */\nexport const mergeAbis = <const TAbis extends readonly Abi[]>(abis: TAbis) => {\n  let merged: Abi = [];\n\n  for (const abi of abis) {\n    for (const item of abi) {\n      // Don't add a duplicate items\n      // if item is constructor or already in merged, don't add it\n      if (\n        item.type !== \"constructor\" &&\n        item.type !== \"receive\" &&\n        item.type !== \"fallback\" &&\n        !merged.some((m) => isAbiItemEqual(m, item))\n      ) {\n        merged = [...merged, item];\n      }\n    }\n  }\n\n  return merged as MergeAbis<TAbis>;\n};\n"],"mappings":"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","names":["references","_enum"]}