{"version":3,"sources":["../../src/bin/ponder.ts","../../src/Ponder.ts","../../src/build/service.ts","../../src/schema/utils.ts","../../src/build/schema/schema.ts","../../src/server/graphql/schema.ts","../../src/utils/checkpoint.ts","../../src/server/graphql/entity.ts","../../src/server/graphql/plural.ts","../../src/server/graphql/singular.ts","../../src/utils/emittery.ts","../../src/config/abi.ts","../../src/utils/duplicates.ts","../../src/config/factories.ts","../../src/utils/lowercase.ts","../../src/utils/offset.ts","../../src/utils/chains.ts","../../src/config/networks.ts","../../src/build/config/config.ts","../../src/build/functions/functions.ts","../../src/build/functions/parseAst.ts","../../src/build/plugin.ts","../../src/build/stacktrace.ts","../../src/codegen/service.ts","../../src/utils/exists.ts","../../src/codegen/ponderEnv.ts","../../src/config/database.ts","../../src/utils/pg.ts","../../src/utils/print.ts","../../src/utils/sqlite.ts","../../src/config/options.ts","../../src/indexing-store/postgres/store.ts","../../src/utils/serialize.ts","../../src/indexing-store/utils/cursor.ts","../../src/utils/encoding.ts","../../src/indexing-store/utils/encoding.ts","../../src/indexing-store/utils/filter.ts","../../src/indexing-store/utils/sort.ts","../../src/indexing-store/sqlite/store.ts","../../src/config/sources.ts","../../src/utils/dedupe.ts","../../src/utils/queue.ts","../../src/utils/wait.ts","../../src/indexing/service.ts","../../src/indexing/context.ts","../../src/indexing/ponderActions.ts","../../src/indexing/transport.ts","../../src/indexing/trace.ts","../../src/logger/service.ts","../../src/metrics/service.ts","../../src/server/service.ts","../../src/ui/graphiql.html.ts","../../src/sync-gateway/service.ts","../../src/metrics/utils.ts","../../src/utils/format.ts","../../src/utils/interval.ts","../../src/sync-historical/service.ts","../../src/sync-historical/getLogFilterRetryRanges.ts","../../src/sync-historical/validateHistoricalBlockRange.ts","../../src/utils/poll.ts","../../src/utils/range.ts","../../src/sync-realtime/service.ts","../../src/sync-realtime/bloom.ts","../../src/sync-realtime/filter.ts","../../src/sync-realtime/format.ts","../../src/utils/fragments.ts","../../src/sync-store/postgres/store.ts","../../src/sync-store/postgres/format.ts","../../src/sync-store/postgres/migrations.ts","../../src/sync-store/sqlite/store.ts","../../src/sync-store/sqlite/format.ts","../../src/sync-store/sqlite/migrations.ts","../../src/telemetry/service.ts","../../src/telemetry/remote.ts","../../src/ui/app.tsx","../../src/ui/ProgressBar.tsx","../../src/ui/service.ts","../../src/utils/requestQueue.ts","../../src/utils/timer.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { readFileSync } from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\n\nimport { cac } from \"cac\";\nimport dotenv from \"dotenv\";\nimport pc from \"picocolors\";\n\nimport { Ponder } from \"@/Ponder.js\";\nimport { buildOptions } from \"@/config/options.js\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst packageJsonPath = resolve(__dirname, \"../../package.json\");\nconst packageJson = JSON.parse(\n  readFileSync(packageJsonPath, { encoding: \"utf8\" }),\n);\n\ndotenv.config({ path: \".env.local\" });\n\n/**\n * CLI options for `ponder` commands. Note that we don't always use CAC's built-in\n * default value behavior, because we want to know downstream if the user explicitly\n * set a value or not.\n */\nexport type CliOptions = {\n  help?: boolean;\n  root?: string;\n  config: string;\n  port?: number;\n  hostname?: string;\n  // CAC converts `-vv` to { v: [true, true], debug: [true, true] }\n  v?: boolean | boolean[];\n  debug?: boolean | boolean[];\n  trace?: boolean;\n};\n\nconst cli = cac(\"ponder\")\n  .version(packageJson.version)\n  .usage(\"<command> [OPTIONS]\")\n  .option(\n    \"--root [PATH]\",\n    \"Path to the project root directory (default: working directory)\",\n  )\n  .option(\"--config [PATH]\", \"Path to the project config file\", {\n    default: \"ponder.config.ts\",\n  })\n  .help();\n\ncli\n  .command(\"dev\", \"Start the app in development mode\")\n  .option(\n    \"-p, --port [PORT]\",\n    \"Port number for the the web server (default: 42069)\",\n  )\n  .option(\n    \"-H, --hostname [HOSTNAME]\",\n    \"Hostname for the web server (default: 0.0.0.0)\",\n  )\n  .option(\n    \"-v, --debug\",\n    \"Enable debug logs including realtime blocks, internal events, etc\",\n  )\n  .option(\n    \"-vv, --trace\",\n    \"Enable trace logs including db queries, indexing checkpoints, etc\",\n  )\n  .action(async (cliOptions: CliOptions) => {\n    if (cliOptions.help) process.exit(0);\n\n    validateNodeVersion();\n\n    const options = buildOptions({ cliOptions });\n    const devOptions = { ...options, uiEnabled: true };\n\n    const ponder = new Ponder({ options: devOptions });\n    registerKilledProcessListener(() => ponder.kill());\n\n    await ponder.dev();\n  });\n\ncli\n  .command(\"start\", \"Start the app in production mode\")\n  .option(\n    \"-p, --port [PORT]\",\n    \"Port number for the the web server (default: 42069)\",\n  )\n  .option(\n    \"-H, --hostname [HOSTNAME]\",\n    \"Hostname for the web server (default: 0.0.0.0)\",\n  )\n  .option(\n    \"-v, --debug\",\n    \"Enable debug logs including realtime blocks, internal events, etc\",\n  )\n  .option(\n    \"-vv, --trace\",\n    \"Enable trace logs including db queries, indexing checkpoints, etc\",\n  )\n  .action(async (cliOptions: CliOptions) => {\n    if (cliOptions.help) process.exit(0);\n\n    validateNodeVersion();\n\n    const options = buildOptions({ cliOptions });\n    const startOptions = { ...options, uiEnabled: false };\n\n    const ponder = new Ponder({ options: startOptions });\n    registerKilledProcessListener(() => ponder.kill());\n\n    await ponder.start();\n  });\n\ncli\n  .command(\"serve\", \"Start the web server (experimental)\")\n  .option(\n    \"-p, --port [PORT]\",\n    \"Port number for the the web server (default: 42069)\",\n  )\n  .option(\n    \"-H, --hostname [HOSTNAME]\",\n    \"Hostname for the web server (default: 0.0.0.0)\",\n  )\n  .option(\n    \"-v, --debug\",\n    \"Enable debug logs including realtime blocks, internal events, etc\",\n  )\n  .option(\n    \"-vv, --trace\",\n    \"Enable trace logs including db queries, indexing checkpoints, etc\",\n  )\n  .action(async (cliOptions: CliOptions) => {\n    if (cliOptions.help) process.exit(0);\n\n    validateNodeVersion();\n\n    const options = buildOptions({ cliOptions });\n    const devOptions = { ...options, uiEnabled: true };\n\n    const ponder = new Ponder({ options: devOptions });\n    registerKilledProcessListener(() => ponder.kill());\n\n    await ponder.serve();\n  });\n\ncli\n  .command(\"codegen\", \"Generate the schema.graphql file, then exit\")\n  .action(async (cliOptions: CliOptions) => {\n    if (cliOptions.help) process.exit(0);\n\n    validateNodeVersion();\n\n    const options = buildOptions({ cliOptions });\n    const codegenOptions = {\n      ...options,\n      uiEnabled: false,\n      logLevel: \"error\" as const,\n    };\n\n    const ponder = new Ponder({ options: codegenOptions });\n    registerKilledProcessListener(() => ponder.kill());\n\n    await ponder.codegen();\n  });\n\ncli.parse();\n\nfunction registerKilledProcessListener(fn: () => Promise<unknown>) {\n  let isKillListenerInProgress = false;\n\n  const listener = async () => {\n    if (isKillListenerInProgress) return;\n    isKillListenerInProgress = true;\n    await fn();\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", listener); // CTRL+C\n  process.on(\"SIGQUIT\", listener); // Keyboard quit\n  process.on(\"SIGTERM\", listener); // `kill` command\n}\n\n/**\n * Checks the user's node version at run time. Used in combinatatin with\n * package.json \"engine\" field to ensure proper use.\n */\nfunction validateNodeVersion() {\n  const _nodeVersion = process.version.split(\".\");\n  const nodeVersion = [\n    Number(_nodeVersion[0].slice(1)),\n    Number(_nodeVersion[1]),\n    Number(_nodeVersion[2]),\n  ];\n  if (nodeVersion[0] < 18 || (nodeVersion[0] === 18 && nodeVersion[1] < 14)) {\n    console.log(\n      `Ponder requires ${pc.cyan(\"Node >=18\")}, detected ${process.version}.`,\n    );\n    console.log(\"\");\n    process.exit(1);\n  }\n}\n","import { existsSync } from \"node:fs\";\nimport path from \"node:path\";\nimport process from \"node:process\";\nimport type { IndexingFunctions } from \"@/build/functions/functions.js\";\nimport { BuildService } from \"@/build/service.js\";\nimport { CodegenService } from \"@/codegen/service.js\";\nimport type { Config } from \"@/config/config.js\";\nimport { buildDatabase } from \"@/config/database.js\";\nimport { type Network } from \"@/config/networks.js\";\nimport { type Options } from \"@/config/options.js\";\nimport type { Source } from \"@/config/sources.js\";\nimport { PostgresIndexingStore } from \"@/indexing-store/postgres/store.js\";\nimport { SqliteIndexingStore } from \"@/indexing-store/sqlite/store.js\";\nimport { type IndexingStore } from \"@/indexing-store/store.js\";\nimport { IndexingService } from \"@/indexing/service.js\";\nimport { LoggerService } from \"@/logger/service.js\";\nimport { MetricsService } from \"@/metrics/service.js\";\nimport type { Schema } from \"@/schema/types.js\";\nimport { ServerService } from \"@/server/service.js\";\nimport { SyncGateway } from \"@/sync-gateway/service.js\";\nimport { HistoricalSyncService } from \"@/sync-historical/service.js\";\nimport { RealtimeSyncService } from \"@/sync-realtime/service.js\";\nimport { PostgresSyncStore } from \"@/sync-store/postgres/store.js\";\nimport { SqliteSyncStore } from \"@/sync-store/sqlite/store.js\";\nimport { type SyncStore } from \"@/sync-store/store.js\";\nimport { TelemetryService } from \"@/telemetry/service.js\";\nimport { UiService } from \"@/ui/service.js\";\nimport type { GraphQLSchema } from \"graphql\";\nimport type { TableAccess } from \"./build/functions/parseAst.js\";\nimport { type RequestQueue, createRequestQueue } from \"./utils/requestQueue.js\";\n\nexport type Common = {\n  options: Options;\n  logger: LoggerService;\n  metrics: MetricsService;\n  telemetry: TelemetryService;\n};\n\nexport class Ponder {\n  common: Common;\n  buildService: BuildService;\n\n  // User config and build artifacts\n  config: Config = undefined!;\n  sources: Source[] = undefined!;\n  networks: Network[] = undefined!;\n  schema: Schema = undefined!;\n  graphqlSchema: GraphQLSchema = undefined!;\n  indexingFunctions: IndexingFunctions = undefined!;\n  tableAccess: TableAccess = undefined!;\n\n  // Sync services\n  syncStore: SyncStore = undefined!;\n  syncServices: {\n    network: Network;\n    requestQueue: RequestQueue;\n    sources: Source[];\n    historical: HistoricalSyncService;\n    realtime: RealtimeSyncService;\n  }[] = undefined!;\n  syncGatewayService: SyncGateway = undefined!;\n\n  // Indexing services\n  indexingStore: IndexingStore = undefined!;\n  indexingService: IndexingService = undefined!;\n\n  // Misc services\n  serverService: ServerService = undefined!;\n  codegenService: CodegenService = undefined!;\n  uiService: UiService = undefined!;\n\n  constructor({ options }: { options: Options }) {\n    const logger = new LoggerService({\n      level: options.logLevel,\n      dir: options.logDir,\n    });\n    const metrics = new MetricsService();\n    const telemetry = new TelemetryService({ options });\n\n    this.common = { options, logger, metrics, telemetry };\n\n    this.buildService = new BuildService({ common: this.common });\n  }\n\n  async dev({\n    syncStore,\n    indexingStore,\n  }: {\n    // These options are only used for testing.\n    syncStore?: SyncStore;\n    indexingStore?: IndexingStore;\n  } = {}) {\n    const dotEnvPath = path.join(this.common.options.rootDir, \".env.local\");\n    if (!existsSync(dotEnvPath)) {\n      this.common.logger.warn({\n        service: \"app\",\n        msg: \"Local environment file (.env.local) not found\",\n      });\n    }\n\n    const success = await this.setupBuildService();\n    if (!success) return;\n\n    this.common.telemetry.record({\n      event: \"App Started\",\n      properties: {\n        command: \"ponder dev\",\n        contractCount: this.sources.length,\n        databaseKind: this.config.database?.kind,\n      },\n    });\n\n    await this.setupCoreServices({ isDev: true, syncStore, indexingStore });\n    this.registerCoreServiceEventListeners();\n\n    // If running `ponder dev`, register build service listeners to handle hot reloads.\n    this.registerBuildServiceEventListeners();\n\n    await this.startSyncServices();\n  }\n\n  async start({\n    syncStore,\n    indexingStore,\n  }: {\n    // These options are only used for testing.\n    syncStore?: SyncStore;\n    indexingStore?: IndexingStore;\n  } = {}) {\n    const success = await this.setupBuildService();\n    if (!success) return;\n\n    this.common.telemetry.record({\n      event: \"App Started\",\n      properties: {\n        command: \"ponder start\",\n        contractCount: this.sources.length,\n        databaseKind: this.config.database?.kind,\n      },\n    });\n\n    await this.setupCoreServices({ isDev: false, syncStore, indexingStore });\n    this.registerCoreServiceEventListeners();\n\n    await this.startSyncServices();\n  }\n\n  async serve() {\n    const success = await this.setupBuildService();\n    if (!success) return;\n\n    this.common.telemetry.record({\n      event: \"App Started\",\n      properties: {\n        command: \"ponder serve\",\n        databaseKind: this.config.database?.kind,\n      },\n    });\n\n    const database = buildDatabase({\n      common: this.common,\n      config: this.config,\n    });\n\n    if (database.indexing.kind === \"sqlite\") {\n      throw new Error(`The 'ponder serve' command only works with Postgres.`);\n    }\n\n    this.common.metrics.registerDatabaseMetrics(database);\n    this.indexingStore = new PostgresIndexingStore({\n      common: this.common,\n      pool: database.indexing.pool,\n      usePublic: true,\n    });\n\n    this.serverService = new ServerService({\n      common: this.common,\n      indexingStore: this.indexingStore,\n    });\n\n    this.serverService.setup({ registerDevRoutes: false });\n    await this.serverService.start();\n\n    // TODO: Make this less hacky. This was a quick way to make the schema available\n    // to the findUnique and findMany functions without having to change the API.\n    this.indexingStore.schema = this.schema;\n\n    this.serverService.reloadGraphqlSchema({\n      graphqlSchema: this.graphqlSchema,\n    });\n  }\n\n  async codegen() {\n    const success = await this.setupBuildService();\n    if (!success) return;\n\n    this.codegenService = new CodegenService({ common: this.common });\n\n    this.codegenService.generateGraphqlSchemaFile({\n      graphqlSchema: this.graphqlSchema,\n    });\n    this.codegenService.generatePonderEnv();\n\n    this.buildService.clearListeners();\n    await this.buildService.kill();\n    await this.common.telemetry.kill();\n  }\n\n  private async setupBuildService() {\n    this.common.logger.debug({\n      service: \"app\",\n      msg: `Started using config file: ${path.relative(\n        this.common.options.rootDir,\n        this.common.options.configFile,\n      )}`,\n    });\n\n    // Initialize the Vite server and Vite Node runner.\n    await this.buildService.setup();\n\n    // Build and load dependencies so that we can create initial versions of all services.\n    // If any are undefined, there was an error in config, schema, or indexing functions.\n    // For now, we can just exit. No need to call `this.kill()` because no services are set up.\n\n    const result = await this.buildService.initialLoad();\n    if (result.error) {\n      this.common.logger.error({\n        service: \"build\",\n        error: result.error,\n      });\n      this.common.logger.fatal({\n        service: \"app\",\n        msg: \"Failed intial build\",\n      });\n      await this.buildService.kill();\n      await this.common.telemetry.kill();\n      return false;\n    }\n\n    this.config = result.config;\n    this.sources = result.sources;\n    this.networks = result.networks;\n    this.schema = result.schema;\n    this.graphqlSchema = result.graphqlSchema;\n    this.indexingFunctions = result.indexingFunctions;\n    this.tableAccess = result.tableAccess;\n\n    return true;\n  }\n\n  private async setupCoreServices({\n    isDev,\n    syncStore,\n    indexingStore,\n  }: {\n    isDev: boolean;\n    // These options are only used for testing.\n    syncStore?: SyncStore;\n    indexingStore?: IndexingStore;\n  }) {\n    const database = buildDatabase({\n      common: this.common,\n      config: this.config,\n    });\n    this.common.metrics.registerDatabaseMetrics(database);\n    this.syncStore =\n      syncStore ??\n      (database.sync.kind === \"sqlite\"\n        ? new SqliteSyncStore({\n            common: this.common,\n            database: database.sync.database,\n          })\n        : new PostgresSyncStore({\n            common: this.common,\n            pool: database.sync.pool,\n          }));\n    this.indexingStore =\n      indexingStore ??\n      (database.indexing.kind === \"sqlite\"\n        ? new SqliteIndexingStore({\n            common: this.common,\n            database: database.indexing.database,\n          })\n        : new PostgresIndexingStore({\n            common: this.common,\n            pool: database.indexing.pool,\n          }));\n\n    const networksToSync = this.networks.filter((network) => {\n      const hasSources = this.sources.some(\n        (source) => source.networkName === network.name,\n      );\n      if (!hasSources) {\n        this.common.logger.warn({\n          service: \"app\",\n          msg: `No contracts found (network=${network.name})`,\n        });\n      }\n      return hasSources;\n    });\n\n    this.syncServices = networksToSync.map((network) => {\n      const sourcesForNetwork = this.sources.filter(\n        (source) => source.networkName === network.name,\n      );\n\n      const requestQueue = createRequestQueue({\n        network,\n        metrics: this.common.metrics,\n      });\n\n      return {\n        network,\n        requestQueue,\n        sources: sourcesForNetwork,\n        historical: new HistoricalSyncService({\n          common: this.common,\n          syncStore: this.syncStore,\n          network,\n          requestQueue,\n          sources: sourcesForNetwork,\n        }),\n        realtime: new RealtimeSyncService({\n          common: this.common,\n          syncStore: this.syncStore,\n          network,\n          requestQueue,\n          sources: sourcesForNetwork,\n        }),\n      };\n    });\n\n    this.syncGatewayService = new SyncGateway({\n      common: this.common,\n      syncStore: this.syncStore,\n      networks: networksToSync,\n    });\n\n    this.indexingService = new IndexingService({\n      common: this.common,\n      syncStore: this.syncStore,\n      indexingStore: this.indexingStore,\n      syncGatewayService: this.syncGatewayService,\n      sources: this.sources,\n      networks: this.syncServices.map((s) => s.network),\n      requestQueues: this.syncServices.map((s) => s.requestQueue),\n    });\n\n    this.serverService = new ServerService({\n      common: this.common,\n      indexingStore: this.indexingStore,\n    });\n\n    this.codegenService = new CodegenService({ common: this.common });\n    this.uiService = new UiService({\n      common: this.common,\n      sources: this.sources,\n    });\n\n    // One-time setup for some services.\n    await this.syncStore.migrateUp();\n\n    this.serverService.setup({ registerDevRoutes: isDev });\n    await this.serverService.start();\n    this.serverService.reloadGraphqlSchema({\n      graphqlSchema: this.graphqlSchema,\n    });\n\n    // Start the indexing service\n    await this.indexingService.reset({\n      indexingFunctions: this.indexingFunctions,\n      schema: this.schema,\n      tableAccess: this.tableAccess,\n    });\n    await this.indexingService.processEvents();\n\n    this.codegenService.generateGraphqlSchemaFile({\n      graphqlSchema: this.graphqlSchema,\n    });\n    this.codegenService.generatePonderEnv();\n  }\n\n  private async startSyncServices() {\n    try {\n      await Promise.all(\n        this.syncServices.map(async ({ historical, realtime }) => {\n          const blockNumbers = await realtime.setup();\n          await historical.setup(blockNumbers);\n\n          historical.start();\n          realtime.start();\n        }),\n      );\n    } catch (error_) {\n      const error = error_ as Error;\n      error.stack = undefined;\n      this.common.logger.fatal({ service: \"app\", error });\n      await this.kill();\n    }\n  }\n\n  /**\n   * Shutdown sequence.\n   */\n  async kill() {\n    this.common.logger.info({\n      service: \"app\",\n      msg: \"Shutting down...\",\n    });\n    this.common.telemetry.record({\n      event: \"App Killed\",\n      properties: { processDuration: process.uptime() },\n    });\n\n    this.clearBuildServiceEventListeners();\n    this.clearCoreServiceEventListeners();\n\n    await Promise.all([\n      this.buildService.kill(),\n      this.serverService.kill(),\n      this.common.telemetry.kill(),\n    ]);\n    this.uiService.kill();\n\n    await this.killCoreServices();\n\n    // Now all resources should be cleaned up. The process should exit gracefully.\n    this.common.logger.debug({\n      service: \"app\",\n      msg: \"Finished shutdown sequence\",\n    });\n  }\n\n  /**\n   * Kill sync and indexing services and stores.\n   */\n  private async killCoreServices() {\n    // 1) Kick off indexing store teardown. This is the longest-running operation\n    // in the shutdown sequence and we really want to make sure it completes.\n    const indexingStoreTeardownPromise = this.indexingStore.teardown();\n\n    // 2) Kill misc services.\n    await this.serverService.kill();\n    this.uiService.kill();\n\n    // 3) Kill core services. Note that these methods pause and clear the queues\n    // and set a boolean flag that allows tasks to fail silently with no retries.\n    this.indexingService.kill();\n    this.syncServices.forEach(({ realtime, historical, requestQueue }) => {\n      realtime.kill();\n      historical.kill();\n      requestQueue.clear(); // TODO: Remove this once viem supports canceling requests.\n    });\n\n    // 4) Indexing store cleanup. This is the longest-running operation,\n    // and we really want to make sure it completes.\n    await indexingStoreTeardownPromise;\n\n    // 5) Cancel pending RPC requests and database queries.\n    // TODO: Once supported by viem, cancel in-progress requests too. This will\n    // cause errors in the sync and indexing services, but they will be silent\n    // and the failed tasks will not be retried.\n    await Promise.all(\n      this.syncServices.map(({ requestQueue }) => requestQueue.onIdle()),\n    );\n\n    await this.indexingStore.kill();\n    await this.syncStore.kill();\n  }\n\n  private registerBuildServiceEventListeners() {\n    this.buildService.onSerial(\n      \"newConfig\",\n      async ({ config, sources, networks }) => {\n        this.uiService.ui.indexingError = false;\n\n        this.clearCoreServiceEventListeners();\n        await this.killCoreServices();\n\n        await this.common.metrics.resetMetrics();\n\n        this.config = config;\n        this.sources = sources;\n        this.networks = networks;\n\n        await this.setupCoreServices({ isDev: true });\n        this.registerCoreServiceEventListeners();\n\n        await this.startSyncServices();\n      },\n    );\n\n    this.buildService.onSerial(\n      \"newSchema\",\n      async ({ schema, graphqlSchema, tableAccess }) => {\n        this.uiService.ui.indexingError = false;\n\n        this.schema = schema;\n        this.graphqlSchema = graphqlSchema;\n        this.tableAccess = tableAccess;\n\n        this.codegenService.generateGraphqlSchemaFile({ graphqlSchema });\n        this.serverService.reloadGraphqlSchema({ graphqlSchema });\n\n        await this.indexingService.reset({ schema, tableAccess });\n        await this.indexingService.processEvents();\n      },\n    );\n\n    this.buildService.onSerial(\n      \"newIndexingFunctions\",\n      async ({ indexingFunctions, tableAccess }) => {\n        this.uiService.ui.indexingError = false;\n\n        this.indexingFunctions = indexingFunctions;\n        this.tableAccess = tableAccess;\n\n        await this.indexingService.reset({ indexingFunctions, tableAccess });\n        await this.indexingService.processEvents();\n      },\n    );\n\n    this.buildService.onSerial(\"error\", async () => {\n      this.uiService.ui.indexingError = true;\n\n      this.indexingService.kill();\n\n      for (const { realtime, historical } of this.syncServices) {\n        realtime.kill();\n        historical.kill();\n      }\n    });\n  }\n\n  private clearBuildServiceEventListeners() {\n    this.buildService.clearListeners();\n  }\n\n  private registerCoreServiceEventListeners() {\n    this.syncServices.forEach(({ network, historical, realtime }) => {\n      historical.on(\"historicalCheckpoint\", (checkpoint) => {\n        this.syncGatewayService.handleNewHistoricalCheckpoint(checkpoint);\n      });\n\n      historical.on(\"syncComplete\", () => {\n        this.syncGatewayService.handleHistoricalSyncComplete({\n          chainId: network.chainId,\n        });\n      });\n\n      realtime.on(\"realtimeCheckpoint\", (checkpoint) => {\n        this.syncGatewayService.handleNewRealtimeCheckpoint(checkpoint);\n      });\n\n      realtime.on(\"finalityCheckpoint\", (checkpoint) => {\n        this.syncGatewayService.handleNewFinalityCheckpoint(checkpoint);\n      });\n\n      realtime.on(\"shallowReorg\", (checkpoint) => {\n        this.syncGatewayService.handleReorg(checkpoint);\n      });\n\n      realtime.on(\"fatal\", async () => {\n        this.common.logger.fatal({\n          service: \"app\",\n          msg: \"Realtime sync service failed\",\n        });\n        await this.kill();\n      });\n    });\n\n    this.syncGatewayService.on(\"newCheckpoint\", async () => {\n      await this.indexingService.processEvents();\n    });\n\n    this.syncGatewayService.on(\"reorg\", async (checkpoint) => {\n      await this.indexingService.handleReorg(checkpoint);\n      await this.indexingService.processEvents();\n    });\n\n    this.indexingService.on(\"eventsProcessed\", async ({ toCheckpoint }) => {\n      if (this.serverService.isHistoricalIndexingComplete) return;\n      // If a batch of events are processed AND the historical sync is complete AND\n      // the new toTimestamp is greater than the historical sync completion timestamp,\n      // historical event processing is complete, and the server should begin responding as healthy.\n      if (\n        this.syncGatewayService.historicalSyncCompletedAt &&\n        toCheckpoint.blockTimestamp >=\n          this.syncGatewayService.historicalSyncCompletedAt\n      ) {\n        this.serverService.setIsHistoricalIndexingComplete();\n        await this.indexingStore.publish();\n      }\n    });\n\n    this.indexingService.on(\"error\", async () => {\n      this.uiService.ui.indexingError = true;\n    });\n\n    this.serverService.on(\"admin:reload\", async ({ chainId }) => {\n      const syncServiceForChainId = this.syncServices.find(\n        ({ network }) => network.chainId === chainId,\n      );\n      if (!syncServiceForChainId) {\n        this.common.logger.warn({\n          service: \"server\",\n          msg: `No network defined for chainId: ${chainId}`,\n        });\n        return;\n      }\n\n      await this.syncStore.deleteRealtimeData({\n        chainId,\n        fromBlock: BigInt(0),\n      });\n\n      this.syncGatewayService.resetCheckpoints({ chainId });\n\n      // Clear all the metrics for the sources.\n      syncServiceForChainId.sources.forEach(\n        ({ networkName, contractName }) => {\n          this.common.metrics.ponder_historical_total_blocks.set(\n            { network: networkName, contract: contractName },\n            0,\n          );\n          this.common.metrics.ponder_historical_completed_blocks.set(\n            { network: networkName, contract: contractName },\n            0,\n          );\n          this.common.metrics.ponder_historical_cached_blocks.set(\n            { network: networkName, contract: contractName },\n            0,\n          );\n        },\n      );\n\n      // Reload the sync services for the specific chain by killing, setting up, and then starting again.\n      syncServiceForChainId.realtime.kill();\n      syncServiceForChainId.historical.kill();\n\n      try {\n        const blockNumbers = await syncServiceForChainId.realtime.setup();\n        await syncServiceForChainId.historical.setup(blockNumbers);\n      } catch (error_) {\n        const error = error_ as Error;\n        error.stack = undefined;\n        this.common.logger.fatal({\n          service: \"app\",\n          msg: \"Failed to fetch initial realtime data\",\n          error,\n        });\n        await this.kill();\n      }\n\n      syncServiceForChainId.realtime.start();\n      syncServiceForChainId.historical.start();\n\n      // NOTE: We have to reset the historical state after restarting the sync services\n      // otherwise the state will be out of sync.\n      this.uiService.resetHistoricalState();\n\n      // Reload the indexing service with existing schema. We use the exisiting schema as there is\n      // alternative resetting behavior for a schema change.\n      await this.indexingService.reset();\n      await this.indexingService.processEvents();\n    });\n  }\n\n  private clearCoreServiceEventListeners() {\n    this.syncServices.forEach(({ historical, realtime }) => {\n      historical.clearListeners();\n      realtime.clearListeners();\n    });\n    this.syncGatewayService.clearListeners();\n    this.indexingService.clearListeners();\n    this.serverService.clearListeners();\n  }\n}\n","import path from \"node:path\";\nimport type { Common } from \"@/Ponder.js\";\nimport { safeBuildSchema } from \"@/build/schema/schema.js\";\nimport type { Config } from \"@/config/config.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { Source } from \"@/config/sources.js\";\nimport type { Schema } from \"@/schema/types.js\";\nimport { buildGqlSchema } from \"@/server/graphql/schema.js\";\nimport { Emittery } from \"@/utils/emittery.js\";\nimport { glob } from \"glob\";\nimport { GraphQLSchema } from \"graphql\";\nimport { type ViteDevServer, createServer } from \"vite\";\nimport { ViteNodeRunner } from \"vite-node/client\";\nimport { ViteNodeServer } from \"vite-node/server\";\nimport { installSourcemapsSupport } from \"vite-node/source-map\";\nimport { normalizeModuleId, toFilePath } from \"vite-node/utils\";\nimport viteTsconfigPathsPlugin from \"vite-tsconfig-paths\";\nimport { safeBuildNetworksAndSources } from \"./config/config.js\";\nimport {\n  type IndexingFunctions,\n  type RawIndexingFunctions,\n  safeBuildIndexingFunctions,\n} from \"./functions/functions.js\";\nimport { type TableAccess, parseAst } from \"./functions/parseAst.js\";\nimport { vitePluginPonder } from \"./plugin.js\";\nimport type { ViteNodeError } from \"./stacktrace.js\";\nimport { parseViteNodeError } from \"./stacktrace.js\";\n\ntype BuildServiceEvents = {\n  // Note: Should new config ever trigger a re-analyze?\n  newConfig: { config: Config; sources: Source[]; networks: Network[] };\n  newIndexingFunctions: {\n    indexingFunctions: IndexingFunctions;\n    tableAccess: TableAccess;\n  };\n  newSchema: {\n    schema: Schema;\n    graphqlSchema: GraphQLSchema;\n    tableAccess: TableAccess;\n  };\n  error: { kind: \"config\" | \"schema\" | \"indexingFunctions\"; error: Error };\n};\n\nexport class BuildService extends Emittery<BuildServiceEvents> {\n  private common: Common;\n\n  private viteDevServer: ViteDevServer = undefined!;\n  private viteNodeServer: ViteNodeServer = undefined!;\n  private viteNodeRunner: ViteNodeRunner = undefined!;\n\n  private rawIndexingFunctions: RawIndexingFunctions = {};\n\n  // Maintain the latest version of built user code to support validation.\n  // Note that `networks` and `schema` are not currently needed for validation.\n  private sources?: Source[];\n  private schema?: Schema;\n  private indexingFunctions?: IndexingFunctions;\n\n  constructor({ common }: { common: Common }) {\n    super();\n    this.common = common;\n  }\n\n  async setup() {\n    const viteLogger = {\n      warnedMessages: new Set<string>(),\n      loggedErrors: new WeakSet<Error>(),\n      hasWarned: false,\n      clearScreen() {},\n      hasErrorLogged: (error: Error) => viteLogger.loggedErrors.has(error),\n      info: (msg: string) => {\n        this.common.logger.trace({ service: \"build(vite)\", msg });\n      },\n      warn: (msg: string) => {\n        viteLogger.hasWarned = true;\n        this.common.logger.trace({ service: \"build(vite)\", msg });\n      },\n      warnOnce: (msg: string) => {\n        if (viteLogger.warnedMessages.has(msg)) return;\n        viteLogger.hasWarned = true;\n        this.common.logger.trace({ service: \"build(vite)\", msg });\n        viteLogger.warnedMessages.add(msg);\n      },\n      error: (msg: string) => {\n        viteLogger.hasWarned = true;\n        this.common.logger.trace({ service: \"build(vite)\", msg });\n      },\n    };\n\n    this.viteDevServer = await createServer({\n      root: this.common.options.rootDir,\n      cacheDir: path.join(this.common.options.ponderDir, \"vite\"),\n      publicDir: false,\n      customLogger: viteLogger,\n      server: { hmr: false },\n      plugins: [viteTsconfigPathsPlugin(), vitePluginPonder()],\n    });\n\n    // This is Vite boilerplate (initializes the Rollup container).\n    await this.viteDevServer.pluginContainer.buildStart({});\n\n    this.viteNodeServer = new ViteNodeServer(this.viteDevServer);\n    installSourcemapsSupport({\n      getSourceMap: (source) => this.viteNodeServer.getSourceMap(source),\n    });\n\n    this.viteNodeRunner = new ViteNodeRunner({\n      root: this.viteDevServer.config.root,\n      fetchModule: (id) => this.viteNodeServer.fetchModule(id, \"ssr\"),\n      resolveId: (id, importer) =>\n        this.viteNodeServer.resolveId(id, importer, \"ssr\"),\n    });\n\n    const handleFileChange = async (files_: string[]) => {\n      const files = files_.map(\n        (file) =>\n          toFilePath(normalizeModuleId(file), this.common.options.rootDir).path,\n      );\n\n      // Invalidate all modules that depend on the updated files.\n      const invalidated = [\n        ...this.viteNodeRunner.moduleCache.invalidateDepTree(files),\n      ];\n\n      this.common.logger.info({\n        service: \"build\",\n        msg: `Hot reload ${invalidated\n          .map((f) => path.relative(this.common.options.rootDir, f))\n          .join(\", \")}`,\n      });\n\n      if (invalidated.includes(this.common.options.configFile)) {\n        const configResult = await this.loadConfig();\n        const validationResult = this.validate();\n\n        if (configResult.success && validationResult.success) {\n          this.emit(\"newConfig\", configResult);\n        } else {\n          const error = configResult.error ?? (validationResult.error as Error);\n          this.common.logger.error({ service: \"build\", error });\n          this.emit(\"error\", { kind: \"config\", error });\n        }\n      }\n\n      if (invalidated.includes(this.common.options.schemaFile)) {\n        const schemaResult = await this.loadSchema();\n        const validationResult = this.validate();\n        const analyzeResult = this.analyze();\n\n        if (schemaResult.success && validationResult.success) {\n          this.emit(\"newSchema\", {\n            ...schemaResult,\n            tableAccess: analyzeResult,\n          });\n        } else {\n          const error = schemaResult.error ?? (validationResult.error as Error);\n          this.common.logger.error({ service: \"build\", error });\n          this.emit(\"error\", { kind: \"schema\", error });\n        }\n      }\n\n      const indexingFunctionRegex = new RegExp(\n        `^${this.common.options.srcDir.replace(\n          /[.*+?^${}()|[\\]\\\\]/g,\n          \"\\\\$&\",\n        )}/.*\\\\.(js|ts)$`,\n      );\n      const indexingFunctionFiles = invalidated.filter((file) =>\n        indexingFunctionRegex.test(file),\n      );\n\n      if (indexingFunctionFiles.length > 0) {\n        const indexingFunctionsResult = await this.loadIndexingFunctions({\n          files: indexingFunctionFiles,\n        });\n        const validationResult = this.validate();\n        const analyzeResult = this.analyze();\n\n        if (indexingFunctionsResult.success && validationResult.success) {\n          this.emit(\"newIndexingFunctions\", {\n            ...indexingFunctionsResult,\n            tableAccess: analyzeResult,\n          });\n        } else {\n          const error =\n            indexingFunctionsResult.error ?? (validationResult.error as Error);\n          this.common.logger.error({ service: \"build\", error });\n          this.emit(\"error\", { kind: \"indexingFunctions\", error });\n        }\n      }\n    };\n\n    // TODO: Consider handling \"add\" and \"unlink\" events too.\n    // TODO: Debounce, de-duplicate, and batch updates.\n\n    this.viteDevServer.watcher.on(\"change\", async (file) => {\n      const ignoreRegex = new RegExp(\n        `^${this.common.options.ponderDir.replace(\n          /[.*+?^${}()|[\\]\\\\]/g,\n          \"\\\\$&\",\n        )}/.*[^/]$`,\n      );\n      if (\n        ignoreRegex.test(file) ||\n        path.join(this.common.options.generatedDir, \"schema.graphql\") ===\n          file ||\n        path.join(this.common.options.rootDir, \"ponder-env.d.ts\") === file\n      )\n        return;\n\n      await handleFileChange([file]);\n    });\n  }\n\n  async kill() {\n    this.cancelMutexes();\n    await this.viteDevServer?.close();\n    this.common.logger.debug({\n      service: \"build\",\n      msg: \"Killed build service\",\n    });\n  }\n\n  async initialLoad() {\n    const configResult = await this.loadConfig();\n    if (!configResult.success) return { error: configResult.error } as const;\n\n    const schemaResult = await this.loadSchema();\n    if (!schemaResult.success) return { error: schemaResult.error } as const;\n\n    const files = glob.sync(\n      path.join(this.common.options.srcDir, \"**/*.{js,mjs,ts,mts}\"),\n    );\n    const indexingFunctionsResult = await this.loadIndexingFunctions({ files });\n    if (!indexingFunctionsResult.success)\n      return { error: indexingFunctionsResult.error } as const;\n\n    const validationResult = this.validate();\n    const analyzeResult = this.analyze();\n    if (!validationResult.success)\n      return { error: validationResult.error } as const;\n\n    const { config, sources, networks } = configResult;\n    const { schema, graphqlSchema } = schemaResult;\n    const { indexingFunctions } = indexingFunctionsResult;\n\n    return {\n      config,\n      networks,\n      sources,\n      schema,\n      graphqlSchema,\n      indexingFunctions,\n      tableAccess: analyzeResult,\n    };\n  }\n\n  private async loadConfig() {\n    const loadResult = await this.executeFile(this.common.options.configFile);\n    if (!loadResult.success) {\n      return { success: false, error: loadResult.error } as const;\n    }\n\n    const rawConfig = loadResult.exports.default as Config;\n    const buildResult = await safeBuildNetworksAndSources({\n      config: rawConfig,\n    });\n\n    if (buildResult.error) {\n      return { success: false, error: buildResult.error } as const;\n    }\n\n    for (const warning of buildResult.data.warnings) {\n      this.common.logger.warn({ service: \"build\", msg: warning });\n    }\n\n    const { sources, networks } = buildResult.data;\n    this.sources = sources;\n\n    return { success: true, config: rawConfig, sources, networks } as const;\n  }\n\n  private async loadSchema() {\n    const loadResult = await this.executeFile(this.common.options.schemaFile);\n    if (loadResult.error) {\n      return { success: false, error: loadResult.error } as const;\n    }\n\n    const rawSchema = loadResult.exports.default as Schema;\n\n    const buildResult = safeBuildSchema({ schema: rawSchema });\n    if (buildResult.error) {\n      return { success: false, error: buildResult.error } as const;\n    }\n\n    const schema = buildResult.data.schema;\n    this.schema = schema;\n\n    // TODO: Probably move this elsewhere. Also, handle errors.\n    const graphqlSchema = buildGqlSchema(buildResult.data.schema);\n\n    return { success: true, schema, graphqlSchema } as const;\n  }\n\n  private async loadIndexingFunctions({ files }: { files: string[] }) {\n    const rawLoadResults = await Promise.all(\n      files.map((file) => this.executeFile(file)),\n    );\n    const loadResultErrors = rawLoadResults.filter(\n      (r): r is { success: false; error: ViteNodeError } => !r.success,\n    );\n    const loadResults = rawLoadResults.filter(\n      (r): r is { success: true; file: string; exports: any } => r.success,\n    );\n\n    if (loadResultErrors.length > 0) {\n      return { success: false, error: loadResultErrors[0].error } as const;\n    }\n\n    for (const result of loadResults) {\n      const { file, exports } = result;\n      const fns = (exports?.ponder?.fns ?? []) as { name: string; fn: any }[];\n      (this.rawIndexingFunctions || {})[file] = fns;\n    }\n\n    const buildResult = safeBuildIndexingFunctions({\n      rawIndexingFunctions: this.rawIndexingFunctions,\n    });\n    if (!buildResult.success) {\n      return { success: false, error: buildResult.error } as const;\n    }\n\n    for (const warning of buildResult.data.warnings) {\n      this.common.logger.warn({ service: \"build\", msg: warning });\n    }\n\n    const indexingFunctions = buildResult.data.indexingFunctions;\n    this.indexingFunctions = indexingFunctions;\n\n    return { success: true, indexingFunctions } as const;\n  }\n\n  /**\n   * Validates and builds the latest config, schema, and indexing functions.\n   * Returns an error if validation fails.\n   */\n  private validate() {\n    if (!this.sources || !this.indexingFunctions)\n      return { success: true } as const;\n\n    for (const [sourceName, fns] of Object.entries(this.indexingFunctions)) {\n      for (const eventName of Object.keys(fns)) {\n        const eventKey = `${sourceName}:${eventName}`;\n\n        const source = this.sources.find((s) => s.contractName === sourceName);\n        if (!source) {\n          // Multi-network contracts have N sources, but the hint here should not have duplicates.\n          const uniqueContractNames = [\n            ...new Set(this.sources.map((s) => s.contractName)),\n          ];\n          const error = new Error(\n            `Validation failed: Invalid contract name for event '${eventKey}'. Got '${sourceName}', expected one of [${uniqueContractNames\n              .map((n) => `'${n}'`)\n              .join(\", \")}].`,\n          );\n          error.stack = undefined;\n          return { success: false, error } as const;\n        }\n\n        const eventNames = [\n          ...Object.keys(source.abiEvents.bySafeName),\n          \"setup\",\n        ];\n        if (!eventNames.find((e) => e === eventName)) {\n          const error = new Error(\n            `Validation failed: Invalid event name for event '${eventKey}'. Got '${eventName}', expected one of [${eventNames\n              .map((eventName) => `'${eventName}'`)\n              .join(\", \")}].`,\n          );\n          error.stack = undefined;\n          return { success: false, error } as const;\n        }\n      }\n    }\n\n    return { success: true } as const;\n  }\n\n  private analyze() {\n    if (!this.rawIndexingFunctions || !this.schema) return [];\n\n    const tableNames = Object.keys(this.schema.tables);\n    const filePaths = Object.keys(this.rawIndexingFunctions);\n    const indexingFunctionKeys = Object.values(\n      this.rawIndexingFunctions,\n    ).flatMap((indexingFunctions) => indexingFunctions.map((x) => x.name));\n\n    const tableAccessMap = parseAst({\n      tableNames,\n      filePaths,\n      indexingFunctionKeys,\n    });\n\n    return tableAccessMap;\n  }\n\n  private async executeFile(file: string) {\n    try {\n      const exports = await this.viteNodeRunner.executeFile(file);\n      return { success: true, file, exports } as const;\n    } catch (error_) {\n      const relativePath = path.relative(this.common.options.rootDir, file);\n      const error = parseViteNodeError(relativePath, error_ as Error);\n      return { success: false, error } as const;\n    }\n  }\n}\n","import type {\n  EnumColumn,\n  ManyColumn,\n  NonReferenceColumn,\n  OneColumn,\n  ReferenceColumn,\n} from \"./types.js\";\n\n/**\n * Returns the name of the table that was referenced by a reference column\n */\nexport const referencedTableName = (references: unknown) =>\n  (references as string).split(\".\")[0];\n\nexport const isOneColumn = (\n  column:\n    | EnumColumn\n    | NonReferenceColumn\n    | ReferenceColumn\n    | ManyColumn\n    | OneColumn,\n): column is OneColumn => column._type === \"o\";\n\nexport const isBaseColumn = (\n  column:\n    | EnumColumn\n    | NonReferenceColumn\n    | ReferenceColumn\n    | ManyColumn\n    | OneColumn,\n): column is NonReferenceColumn | ReferenceColumn => column._type === \"b\";\n\nexport const isManyColumn = (\n  column:\n    | EnumColumn\n    | NonReferenceColumn\n    | ReferenceColumn\n    | ManyColumn\n    | OneColumn,\n): column is ManyColumn => column._type === \"m\";\n\nexport const isEnumColumn = (\n  column:\n    | EnumColumn\n    | NonReferenceColumn\n    | ReferenceColumn\n    | ManyColumn\n    | OneColumn,\n): column is EnumColumn => column._type === \"e\";\n\nexport const isReferenceColumn = (\n  column:\n    | EnumColumn\n    | NonReferenceColumn\n    | ReferenceColumn\n    | ManyColumn\n    | OneColumn,\n): column is ReferenceColumn =>\n  column._type === \"b\" && column.references !== undefined;\n","import type { Schema } from \"../../schema/types.js\";\nimport {\n  isEnumColumn,\n  isManyColumn,\n  isOneColumn,\n  isReferenceColumn,\n  referencedTableName,\n} from \"../../schema/utils.js\";\n\nexport const buildSchema = ({ schema }: { schema: Schema }) => {\n  // Validate enums\n  Object.entries(schema.enums).forEach(([name, _enum]) => {\n    validateTableOrColumnName(name, \"Enum\");\n\n    const enumValues = new Set<string>();\n    for (const enumValue of _enum) {\n      if (enumValues.has(enumValue)) {\n        throw Error(\n          `Validation failed: Enum '${name}' contains duplicate value '${enumValue}'.`,\n        );\n      }\n      enumValues.add(enumValue);\n    }\n  });\n\n  // Validate tables\n  Object.entries(schema.tables).forEach(([tableName, columns]) => {\n    validateTableOrColumnName(tableName, \"Table\");\n\n    // Validate the id column\n    if (columns.id === undefined)\n      throw Error(\n        `Validation failed: Table '${tableName}' does not have an 'id' column.`,\n      );\n\n    if (isEnumColumn(columns.id))\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'enum', expected one of ['string', 'hex', 'bigint', 'int'].`,\n      );\n    if (isOneColumn(columns.id))\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'one', expected one of ['string', 'hex', 'bigint', 'int'].`,\n      );\n    if (isManyColumn(columns.id))\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. Got 'many', expected one of ['string', 'hex', 'bigint', 'int'].`,\n      );\n    if (isReferenceColumn(columns.id))\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot use the '.references' modifier.`,\n      );\n\n    if (\n      columns.id.type !== \"bigint\" &&\n      columns.id.type !== \"string\" &&\n      columns.id.type !== \"hex\" &&\n      columns.id.type !== \"int\"\n    )\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. Got '${columns.id.type}', expected one of ['string', 'hex', 'bigint', 'int'].`,\n      );\n\n    // @ts-expect-error\n    if (columns.id.optional === true)\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot be optional.`,\n      );\n    // @ts-expect-error\n    if (columns.id.list === true)\n      throw Error(\n        `Validation failed: Invalid type for ID column '${tableName}.id'. ID columns cannot be a list.`,\n      );\n\n    // Validate all other columns\n    Object.entries(columns).forEach(([columnName, column]) => {\n      if (columnName === \"id\") return;\n\n      validateTableOrColumnName(columnName, \"Column\");\n\n      if (isOneColumn(column)) {\n        const usedColumn = Object.entries(columns).find(\n          ([c]) => c === column.referenceColumn,\n        );\n\n        if (usedColumn === undefined) {\n          const otherColumns = Object.keys(columns).filter(\n            (c) => c !== columnName,\n          );\n          throw Error(\n            `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that does not exist. Got '${\n              column.referenceColumn\n            }', expected one of [${otherColumns\n              .map((c) => `'${c}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        if (!isReferenceColumn(usedColumn[1])) {\n          const foreignKeyColumns = Object.keys(columns).filter(\n            (c) => c !== columnName && isReferenceColumn(columns[c]),\n          );\n          throw Error(\n            `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that is not foreign key column. Got '${\n              column.referenceColumn\n            }', expected one of [${foreignKeyColumns\n              .map((c) => `'${c}'`)\n              .join(\", \")}].`,\n          );\n        }\n      }\n\n      if (isManyColumn(column)) {\n        const usedTable = Object.entries(schema.tables).find(\n          ([name]) => name === column.referenceTable,\n        );\n\n        if (usedTable === undefined) {\n          const otherTables = Object.keys(schema.tables).filter(\n            (t) => t !== tableName,\n          );\n\n          throw Error(\n            `Validation failed. Relationship column '${tableName}.${columnName}' uses a table that does not exist. Got '${\n              column.referenceTable\n            }', expected one of [${otherTables\n              .map((t) => `'${t}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        const usedTableColumns = Object.entries(usedTable[1]);\n        const usedColumn = usedTableColumns.find(\n          ([columnName]) => columnName === column.referenceColumn,\n        );\n\n        if (usedColumn === undefined) {\n          throw Error(\n            `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that does not exist. Got '${\n              column.referenceTable\n            }.${column.referenceColumn}', expected one of [${usedTableColumns\n              .map((c) => `'${usedTable[0]}.${c}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        if (!isReferenceColumn(usedColumn[1])) {\n          const foreignKeyColumnNames = usedTableColumns.filter(([, c]) =>\n            isReferenceColumn(c),\n          );\n          throw Error(\n            `Validation failed. Relationship column '${tableName}.${columnName}' uses a column that is not foreign key column. Got '${\n              column.referenceTable\n            }.${\n              column.referenceColumn\n            }', expected one of [${foreignKeyColumnNames\n              .map((c) => `'${usedTable[0]}.${c}'`)\n              .join(\", \")}].`,\n          );\n        }\n      }\n\n      if (isEnumColumn(column)) {\n        const referencedEnum = Object.entries(schema.enums).find(\n          ([enumName]) => enumName === column.type,\n        );\n        if (referencedEnum === undefined) {\n          throw Error(\n            `Validation failed: Enum column '${tableName}.${columnName}' doesn't reference a valid enum. Got '${\n              column.type\n            }', expected one of [${Object.keys(schema.enums)\n              .map((e) => `'${e}'`)\n              .join(\", \")}].`,\n          );\n        }\n      }\n\n      if (isReferenceColumn(column)) {\n        const referencedTable = Object.entries(schema.tables).find(\n          ([tableName]) => tableName === referencedTableName(column.references),\n        );\n\n        if (referencedTable === undefined) {\n          throw Error(\n            `Validation failed: Foreign key column '${tableName}.${columnName}' does not reference a valid ID column. Got '${\n              column.references\n            }', expected one of [${Object.keys(schema.tables)\n              .map((t) => `'${t}.id'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        if (referencedTable[1].id.type !== column.type) {\n          throw Error(\n            `Validation failed: Foreign key column '${tableName}.${columnName}' type does not match the referenced table's ID column type. Got '${column.type}', expected '${referencedTable[1].id.type}'.`,\n          );\n        }\n\n        // NOTE: This is unreachable, but worth documenting here.\n        // if (column.list) {\n        //   throw Error(\n        //     `Validation failed: Foreign key column '${tableName}.${columnName}' cannot use the 'list' modifier.`,\n        //   );\n        // }\n      }\n\n      // NOTE: This is unreachable, but worth documenting here.\n      // if (isPrimitiveColumn(column)) {\n      //   if (\n      //     column.type !== \"bigint\" &&\n      //     column.type !== \"string\" &&\n      //     column.type !== \"boolean\" &&\n      //     column.type !== \"int\" &&\n      //     column.type !== \"float\" &&\n      //     column.type !== \"hex\"\n      //   ) {\n      //     throw Error(\n      //       `Validation failed: Primitive column '${tableName}.${columnName}' type is invalid. Got '${column.type}', expected one of ['bigint', 'string', 'boolean', 'int', 'float', 'hex'].`,\n      //     );\n      //   }\n      // }\n    });\n  });\n\n  return { schema };\n};\n\nconst validateTableOrColumnName = (key: string, type: string) => {\n  if (key === \"\")\n    throw Error(`Validation failed: ${type} name can't be an empty string.`);\n\n  if (!/^[a-z|A-Z|0-9]+$/.test(key))\n    throw Error(\n      `Validation failed: ${type} name '${key}' contains an invalid character.`,\n    );\n};\n\nexport function safeBuildSchema({ schema }: { schema: Schema }) {\n  try {\n    const result = buildSchema({ schema });\n    return { success: true, data: result } as const;\n  } catch (error_) {\n    const error = error_ as Error;\n    error.stack = undefined;\n    return { success: false, error } as const;\n  }\n}\n","import type { IndexingStore } from \"@/indexing-store/store.js\";\nimport type { Scalar, Schema } from \"@/schema/types.js\";\nimport {\n  GraphQLBoolean,\n  type GraphQLFieldConfig,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLString,\n} from \"graphql\";\nimport { buildEntityTypes } from \"./entity.js\";\nimport { buildPluralField } from \"./plural.js\";\nimport { buildSingularField } from \"./singular.js\";\n\nconst GraphQLBigInt = new GraphQLScalarType({\n  name: \"BigInt\",\n  serialize: (value) => String(value),\n  // TODO: Kyle this cast is probably a bad idea.\n  parseValue: (value) => BigInt(value as any),\n  parseLiteral: (value) => {\n    if (value.kind === \"StringValue\") {\n      return BigInt(value.value);\n    } else {\n      throw new Error(\n        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`,\n      );\n    }\n  },\n});\n\nexport const tsTypeToGqlScalar: { [type in Scalar]: GraphQLScalarType } = {\n  int: GraphQLInt,\n  float: GraphQLFloat,\n  string: GraphQLString,\n  boolean: GraphQLBoolean,\n  bigint: GraphQLBigInt,\n  hex: GraphQLString,\n};\n\nexport type Source = { request: unknown };\nexport type Context = { store: IndexingStore };\n\nexport const buildGqlSchema = (schema: Schema): GraphQLSchema => {\n  const queryFields: Record<string, GraphQLFieldConfig<Source, Context>> = {};\n\n  // First build the entity types. These have resolvers defined for any\n  // relationship or derived fields. This is also important for the thunk nonsense.\n  const { entityTypes, entityPageTypes, enumTypes } = buildEntityTypes({\n    schema,\n  });\n\n  for (const [tableName, table] of Object.entries(schema.tables)) {\n    const entityType = entityTypes[tableName];\n    const entityPageType = entityPageTypes[tableName];\n\n    const singularFieldName =\n      tableName.charAt(0).toLowerCase() + tableName.slice(1);\n    queryFields[singularFieldName] = buildSingularField({\n      tableName,\n      table,\n      entityType,\n    });\n\n    const pluralFieldName = `${singularFieldName}s`;\n    queryFields[pluralFieldName] = buildPluralField({\n      table,\n      tableName,\n      entityPageType,\n      enumTypes,\n    });\n  }\n\n  const queryType = new GraphQLObjectType({\n    name: \"Query\",\n    fields: queryFields,\n  });\n\n  const gqlSchema = new GraphQLSchema({\n    query: queryType,\n  });\n\n  return gqlSchema;\n};\n","export type Checkpoint = {\n  blockTimestamp: number;\n  chainId: number;\n  blockNumber: number;\n  // Execution index of the log within the block.\n  // If undefined, the checkpoint includes all events in the block.\n  logIndex?: number | undefined;\n};\n\n// 10 digits for unix timestamp gets us to the year 2277.\nconst BLOCK_TIMESTAMP_DIGITS = 10;\n// Chain IDs are uint256. As of writing the largest Chain ID on https://chainlist.org\n// is 13 digits. 16 digits should be enough (JavaScript's max safe integer).\nconst CHAIN_ID_DIGITS = 16;\n// Same logic as chain ID.\nconst BLOCK_NUMBER_DIGITS = 16;\n// Same logic as chain ID.\nconst EXECUTION_INDEX_DIGITS = 16;\n\nexport const encodeCheckpoint = (checkpoint: Checkpoint) => {\n  const { blockTimestamp, chainId, blockNumber, logIndex } = checkpoint;\n  const result =\n    blockTimestamp.toString().padStart(BLOCK_TIMESTAMP_DIGITS, \"0\") +\n    chainId.toString().padStart(CHAIN_ID_DIGITS, \"0\") +\n    blockNumber.toString().padStart(BLOCK_NUMBER_DIGITS, \"0\") +\n    (logIndex !== undefined\n      ? logIndex.toString().padStart(EXECUTION_INDEX_DIGITS, \"0\")\n      : \"9\".repeat(EXECUTION_INDEX_DIGITS));\n\n  if (\n    result.length !==\n    BLOCK_TIMESTAMP_DIGITS +\n      CHAIN_ID_DIGITS +\n      BLOCK_NUMBER_DIGITS +\n      EXECUTION_INDEX_DIGITS\n  )\n    throw new Error(`Invalid stringified checkpoint: ${result}`);\n\n  return result;\n};\n\nexport const zeroCheckpoint: Checkpoint = {\n  blockTimestamp: 0,\n  chainId: 0,\n  blockNumber: 0,\n  logIndex: 0,\n};\n\n// TODO: Consider changing block timestamps and numbers to bigints\n// so that we can accurately represent EVM max values.\nexport const maxCheckpoint: Checkpoint = {\n  blockTimestamp: 9999999999,\n  chainId: 2147483647,\n  blockNumber: 9999999999,\n  logIndex: 2147483647,\n};\n\n/**\n * Returns true if two checkpoints are equal.\n */\nexport const isCheckpointEqual = (a: Checkpoint, b: Checkpoint) => {\n  return (\n    a.blockTimestamp === b.blockTimestamp &&\n    a.chainId === b.chainId &&\n    a.blockNumber === b.blockNumber &&\n    ((a.logIndex === undefined && b.logIndex === undefined) ||\n      a.logIndex === b.logIndex)\n  );\n};\n\n/**\n * Returns true if checkpoint a is greater than checkpoint b.\n * Returns false if the checkpoints are equal.\n */\nexport const isCheckpointGreaterThan = (a: Checkpoint, b: Checkpoint) => {\n  if (a.blockTimestamp !== b.blockTimestamp)\n    return a.blockTimestamp > b.blockTimestamp;\n  if (a.chainId !== b.chainId) return a.chainId > b.chainId;\n  if (a.blockNumber !== b.blockNumber) return a.blockNumber > b.blockNumber;\n\n  // If both logIndex are defined, compare normally.\n  if (a.logIndex !== undefined && b.logIndex !== undefined) {\n    return a.logIndex > b.logIndex;\n  }\n  // If both are undefined, the checkpoints are equal, so a is not greater than b.\n  if (a.logIndex === undefined && b.logIndex === undefined) {\n    return false;\n  }\n  // If only a is undefined, it's considered greater.\n  if (a.logIndex === undefined) return true;\n  // Otherwise b is undefined and a is defined, so b is greater.\n  else return false;\n};\n\n/**\n * Returns true if checkpoint a is greater than or equal to checkpoint b.\n */\nexport const isCheckpointGreaterThanOrEqualTo = (\n  a: Checkpoint,\n  b: Checkpoint,\n) => {\n  return isCheckpointGreaterThan(a, b) || isCheckpointEqual(a, b);\n};\n\nexport const checkpointMax = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((max, checkpoint) => {\n    return isCheckpointGreaterThan(checkpoint, max) ? checkpoint : max;\n  });\n\nexport const checkpointMin = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((min, checkpoint) => {\n    return isCheckpointGreaterThan(min, checkpoint) ? checkpoint : min;\n  });\n","import type { ReferenceColumn, Schema } from \"@/schema/types.js\";\nimport {\n  isEnumColumn,\n  isManyColumn,\n  isOneColumn,\n  referencedTableName,\n} from \"@/schema/utils.js\";\nimport { maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport { GraphQLBoolean, type GraphQLFieldResolver } from \"graphql\";\nimport {\n  GraphQLEnumType,\n  type GraphQLFieldConfigMap,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from \"graphql\";\nimport type { PluralResolver } from \"./plural.js\";\nimport { type Context, type Source } from \"./schema.js\";\nimport { tsTypeToGqlScalar } from \"./schema.js\";\n\nconst GraphQLPageInfo = new GraphQLObjectType({\n  name: \"PageInfo\",\n  fields: {\n    hasNextPage: { type: new GraphQLNonNull(GraphQLBoolean) },\n    hasPreviousPage: { type: new GraphQLNonNull(GraphQLBoolean) },\n    startCursor: { type: GraphQLString },\n    endCursor: { type: GraphQLString },\n  },\n});\n\nexport const buildEntityTypes = ({ schema }: { schema: Schema }) => {\n  const enumTypes: Record<string, GraphQLEnumType> = {};\n  const entityTypes: Record<string, GraphQLObjectType<Source, Context>> = {};\n  const entityPageTypes: Record<string, GraphQLObjectType> = {};\n\n  for (const [enumName, _enum] of Object.entries(schema.enums)) {\n    enumTypes[enumName] = new GraphQLEnumType({\n      name: enumName,\n      values: _enum.reduce(\n        (acc: Record<string, {}>, cur) => ({ ...acc, [cur]: {} }),\n        {},\n      ),\n    });\n  }\n\n  for (const [tableName, table] of Object.entries(schema.tables)) {\n    entityTypes[tableName] = new GraphQLObjectType({\n      name: tableName,\n      fields: () => {\n        const fieldConfigMap: GraphQLFieldConfigMap<Source, Context> = {};\n\n        Object.entries(table).forEach(([columnName, column]) => {\n          if (isOneColumn(column)) {\n            // Column must resolve the foreign key of the referenced column\n            // Note: this relies on the fact that reference columns can't be lists\n\n            const referenceColumn = table[\n              column.referenceColumn\n            ] as ReferenceColumn;\n\n            const referencedTable = referencedTableName(\n              referenceColumn.references,\n            );\n\n            const resolver: GraphQLFieldResolver<Source, Context> = async (\n              parent,\n              _args,\n              context,\n            ) => {\n              const { store } = context;\n\n              // @ts-ignore\n              const relatedRecordId = parent[column.referenceColumn];\n\n              // Note: Don't query with a null or undefined id, indexing store will throw error.\n              if (relatedRecordId === null || relatedRecordId === undefined)\n                return null;\n\n              return await store.findUnique({\n                tableName: referencedTable,\n                id: relatedRecordId,\n              });\n            };\n\n            fieldConfigMap[columnName] = {\n              type: referenceColumn.optional\n                ? entityTypes[referencedTable]\n                : new GraphQLNonNull(entityTypes[referencedTable]),\n              resolve: resolver,\n            };\n          } else if (isManyColumn(column)) {\n            const resolver: PluralResolver = async (parent, args, context) => {\n              const { store } = context;\n\n              const {\n                timestamp,\n                where,\n                orderBy,\n                orderDirection,\n                limit,\n                after,\n                before,\n              } = args;\n\n              // The parent object gets passed in here with relationship fields defined as the\n              // string ID of the related entity. Here, we get the ID and query for that entity.\n              // Then, the GraphQL server serves the resolved object here instead of the ID.\n              // @ts-ignore\n              const entityId = parent.id;\n\n              const checkpoint = timestamp\n                ? { ...maxCheckpoint, blockTimestamp: timestamp }\n                : undefined; // Latest.\n\n              const whereObject = where ? buildWhereObject({ where }) : {};\n              whereObject[column.referenceColumn] = entityId;\n\n              const orderByObject = orderBy\n                ? { [orderBy]: orderDirection || \"asc\" }\n                : undefined;\n\n              return await store.findMany({\n                tableName: column.referenceTable,\n                checkpoint,\n                where: whereObject,\n                orderBy: orderByObject,\n                limit,\n                before,\n                after,\n              });\n            };\n\n            fieldConfigMap[columnName] = {\n              type: entityPageTypes[column.referenceTable],\n              args: {\n                timestamp: { type: GraphQLInt },\n                orderBy: { type: GraphQLString },\n                orderDirection: { type: GraphQLString },\n                before: { type: GraphQLString },\n                after: { type: GraphQLString },\n                limit: { type: GraphQLInt },\n              },\n              resolve: resolver,\n            };\n          } else {\n            const type = isEnumColumn(column)\n              ? enumTypes[column.type]\n              : tsTypeToGqlScalar[column.type];\n            if (column.list) {\n              const listType = new GraphQLList(new GraphQLNonNull(type));\n              fieldConfigMap[columnName] = {\n                type: column.optional ? listType : new GraphQLNonNull(listType),\n              };\n            } else {\n              fieldConfigMap[columnName] = {\n                type: column.optional ? type : new GraphQLNonNull(type),\n              };\n            }\n          }\n        });\n\n        return fieldConfigMap;\n      },\n    });\n\n    entityPageTypes[tableName] = new GraphQLObjectType({\n      name: `${tableName}Page`,\n      fields: () => ({\n        items: {\n          type: new GraphQLList(new GraphQLNonNull(entityTypes[tableName])),\n        },\n        pageInfo: { type: GraphQLPageInfo },\n      }),\n    });\n  }\n\n  return { entityTypes, entityPageTypes, enumTypes };\n};\n\nconst graphqlFilterToStoreCondition = {\n  \"\": \"equals\",\n  not: \"not\",\n  in: \"in\",\n  not_in: \"notIn\",\n  has: \"has\",\n  not_has: \"notHas\",\n  gt: \"gt\",\n  lt: \"lt\",\n  gte: \"gte\",\n  lte: \"lte\",\n  contains: \"contains\",\n  not_contains: \"notContains\",\n  starts_with: \"startsWith\",\n  not_starts_with: \"notStartsWith\",\n  ends_with: \"endsWith\",\n  not_ends_with: \"notEndsWith\",\n} as const;\n\nfunction buildWhereObject({ where }: { where: Record<string, any> }) {\n  const whereObject: Record<string, any> = {};\n\n  Object.entries(where).forEach(([whereKey, rawValue]) => {\n    const [fieldName, condition_] = whereKey.split(/_(.*)/s);\n    // This is a hack to handle the \"\" operator, which the regex above doesn't handle\n    const condition = (\n      condition_ === undefined ? \"\" : condition_\n    ) as keyof typeof graphqlFilterToStoreCondition;\n\n    const storeCondition = graphqlFilterToStoreCondition[condition];\n    if (!storeCondition) {\n      throw new Error(\n        `Invalid query: Unknown where condition: ${fieldName}_${condition}`,\n      );\n    }\n\n    whereObject[fieldName] = { [storeCondition]: rawValue };\n  });\n\n  return whereObject;\n}\n","import type { Schema } from \"@/schema/types.js\";\nimport { isEnumColumn, isManyColumn, isOneColumn } from \"@/schema/utils.js\";\nimport { maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport {\n  type GraphQLEnumType,\n  type GraphQLFieldConfig,\n  type GraphQLFieldResolver,\n  type GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLString,\n} from \"graphql\";\nimport { type Context, type Source } from \"./schema.js\";\nimport { tsTypeToGqlScalar } from \"./schema.js\";\n\ntype PluralArgs = {\n  timestamp?: number;\n  where?: { [key: string]: number | string };\n  after?: string;\n  before?: string;\n  limit?: number;\n  orderBy?: string;\n  orderDirection?: \"asc\" | \"desc\";\n};\n\nexport type PluralResolver = GraphQLFieldResolver<Source, Context, PluralArgs>;\n\nconst operators = {\n  universal: [\"\", \"_not\"],\n  singular: [\"_in\", \"_not_in\"],\n  plural: [\"_has\", \"_not_has\"],\n  numeric: [\"_gt\", \"_lt\", \"_gte\", \"_lte\"],\n  string: [\n    \"_contains\",\n    \"_not_contains\",\n    \"_starts_with\",\n    \"_ends_with\",\n    \"_not_starts_with\",\n    \"_not_ends_with\",\n  ],\n};\n\nexport const buildPluralField = ({\n  tableName,\n  table,\n  entityPageType,\n  enumTypes,\n}: {\n  tableName: string;\n  table: Schema[\"tables\"][string];\n  entityPageType: GraphQLObjectType;\n  enumTypes: Record<string, GraphQLEnumType>;\n}): GraphQLFieldConfig<Source, Context> => {\n  const filterFields: GraphQLInputFieldConfigMap = {};\n\n  Object.entries(table).forEach(([columnName, column]) => {\n    // Note: Only include non-virtual columns in plural fields\n    if (isOneColumn(column)) return;\n    if (isManyColumn(column)) return;\n\n    const type = isEnumColumn(column)\n      ? enumTypes[column.type]\n      : tsTypeToGqlScalar[column.type];\n\n    if (column.list) {\n      // List fields => universal, plural\n      operators.universal.forEach((suffix) => {\n        filterFields[`${columnName}${suffix}`] = {\n          type: new GraphQLList(type),\n        };\n      });\n\n      operators.plural.forEach((suffix) => {\n        filterFields[`${columnName}${suffix}`] = {\n          type: type,\n        };\n      });\n    } else {\n      // Scalar fields => universal, singular, numeric OR string depending on base type\n      // Note: Booleans => universal and singular only.\n      operators.universal.forEach((suffix) => {\n        filterFields[`${columnName}${suffix}`] = {\n          type: type,\n        };\n      });\n\n      operators.singular.forEach((suffix) => {\n        filterFields[`${columnName}${suffix}`] = {\n          type: new GraphQLList(type),\n        };\n      });\n\n      if ([\"int\", \"bigint\", \"float\", \"hex\"].includes(column.type)) {\n        operators.numeric.forEach((suffix) => {\n          filterFields[`${columnName}${suffix}`] = {\n            type: type,\n          };\n        });\n      }\n\n      if (\"string\" === column.type) {\n        operators.string.forEach((suffix) => {\n          filterFields[`${columnName}${suffix}`] = {\n            type: type,\n          };\n        });\n      }\n    }\n  });\n\n  const filterType = new GraphQLInputObjectType({\n    name: `${tableName}Filter`,\n    fields: filterFields,\n  });\n\n  const resolver: PluralResolver = async (_, args, context) => {\n    const { store } = context;\n\n    const { timestamp, where, orderBy, orderDirection, before, limit, after } =\n      args;\n\n    const checkpoint = timestamp\n      ? { ...maxCheckpoint, blockTimestamp: timestamp }\n      : undefined; // Latest.\n\n    const whereObject = where ? buildWhereObject({ where }) : {};\n\n    const orderByObject = orderBy\n      ? { [orderBy]: orderDirection || \"asc\" }\n      : undefined;\n\n    return await store.findMany({\n      tableName,\n      checkpoint,\n      where: whereObject,\n      orderBy: orderByObject,\n      limit,\n      before,\n      after,\n    });\n  };\n\n  return {\n    type: entityPageType,\n    args: {\n      timestamp: { type: GraphQLInt },\n      where: { type: filterType },\n      orderBy: { type: GraphQLString },\n      orderDirection: { type: GraphQLString },\n      before: { type: GraphQLString },\n      after: { type: GraphQLString },\n      limit: { type: GraphQLInt },\n    },\n    resolve: resolver,\n  };\n};\n\nconst graphqlFilterToStoreCondition = {\n  \"\": \"equals\",\n  not: \"not\",\n  in: \"in\",\n  not_in: \"notIn\",\n  has: \"has\",\n  not_has: \"notHas\",\n  gt: \"gt\",\n  lt: \"lt\",\n  gte: \"gte\",\n  lte: \"lte\",\n  contains: \"contains\",\n  not_contains: \"notContains\",\n  starts_with: \"startsWith\",\n  not_starts_with: \"notStartsWith\",\n  ends_with: \"endsWith\",\n  not_ends_with: \"notEndsWith\",\n} as const;\n\nfunction buildWhereObject({ where }: { where: Record<string, any> }) {\n  const whereObject: Record<string, any> = {};\n\n  Object.entries(where).forEach(([whereKey, rawValue]) => {\n    const [fieldName, condition_] = whereKey.split(/_(.*)/s);\n    // This is a hack to handle the \"\" operator, which the regex above doesn't handle\n    const condition = (\n      condition_ === undefined ? \"\" : condition_\n    ) as keyof typeof graphqlFilterToStoreCondition;\n\n    const storeCondition = graphqlFilterToStoreCondition[condition];\n    if (!storeCondition) {\n      throw new Error(\n        `Invalid query: Unknown where condition: ${fieldName}_${condition}`,\n      );\n    }\n\n    whereObject[fieldName] = { [storeCondition]: rawValue };\n  });\n\n  return whereObject;\n}\n","import type { GraphQLObjectType } from \"graphql\";\nimport {\n  type GraphQLFieldConfig,\n  type GraphQLFieldResolver,\n  GraphQLInt,\n  GraphQLNonNull,\n} from \"graphql\";\n\nimport type { BaseColumn, ID, Schema } from \"@/schema/types.js\";\nimport { maxCheckpoint } from \"@/utils/checkpoint.js\";\n\nimport type { Context, Source } from \"./schema.js\";\nimport { tsTypeToGqlScalar } from \"./schema.js\";\n\ntype SingularArgs = {\n  id?: string;\n  timestamp?: number;\n};\ntype SingularResolver = GraphQLFieldResolver<Source, Context, SingularArgs>;\n\nconst buildSingularField = ({\n  tableName,\n  table,\n  entityType,\n}: {\n  tableName: string;\n  table: Schema[\"tables\"][string];\n  entityType: GraphQLObjectType<Source, Context>;\n}): GraphQLFieldConfig<Source, Context> => {\n  const resolver: SingularResolver = async (_, args, context) => {\n    const { store } = context;\n    const { id, timestamp } = args;\n\n    if (id === undefined) return null;\n\n    const checkpoint = timestamp\n      ? { ...maxCheckpoint, blockTimestamp: timestamp }\n      : undefined; // Latest.\n\n    const entityInstance = await store.findUnique({\n      tableName: tableName,\n      id,\n      checkpoint,\n    });\n\n    return entityInstance;\n  };\n\n  return {\n    type: entityType,\n    args: {\n      id: {\n        type: new GraphQLNonNull(\n          tsTypeToGqlScalar[\n            (table as { id: BaseColumn<ID, never, false, false> }).id.type\n          ],\n        ),\n      },\n      timestamp: { type: GraphQLInt },\n    },\n    resolve: resolver,\n  };\n};\n\nexport { buildSingularField };\n","import { E_CANCELED, Mutex } from \"async-mutex\";\nimport _Emittery, {\n  type DatalessEventNames,\n  type EventName,\n  type OmnipresentEventData,\n  type UnsubscribeFunction,\n} from \"emittery\";\n\nexport class Emittery<\n  EventData = Record<EventName, any>,\n  AllEventData = EventData & OmnipresentEventData,\n  DatalessEvents = DatalessEventNames<EventData>,\n> extends _Emittery<EventData, AllEventData, DatalessEvents> {\n  private listenerMutexes: Map<\n    EventName,\n    Map<\n      (eventData: AllEventData[any]) => void | Promise<void>,\n      { mutex: Mutex; latestEventData: any; unsubscribe: UnsubscribeFunction }\n    >\n  > = new Map();\n\n  onSerial<Name extends keyof AllEventData>(\n    eventName: Name,\n    listener: (eventData: AllEventData[Name]) => void | Promise<void>,\n  ): UnsubscribeFunction {\n    // If this is the first listener being registered for this event, create the listener map.\n    if (!this.listenerMutexes.has(eventName))\n      this.listenerMutexes.set(eventName, new Map());\n\n    // If the listener has already been registered, return the existing unsubscribe function.\n    if (this.listenerMutexes.get(eventName)!.has(listener))\n      return this.listenerMutexes.get(eventName)!.get(listener)!.unsubscribe;\n\n    const innerListener = async (eventData: AllEventData[Name]) => {\n      const eventMutex = this.listenerMutexes.get(eventName)!.get(listener)!;\n\n      eventMutex.latestEventData = eventData;\n\n      try {\n        await eventMutex.mutex.runExclusive(async () => {\n          if (eventMutex.latestEventData === undefined) return;\n\n          const toProcess = eventMutex.latestEventData;\n          eventMutex.latestEventData = undefined;\n\n          await listener(toProcess);\n        });\n      } catch (error) {\n        // Pending locks get cancelled in cancelMutexes(). This is expected, so it's safe to\n        // ignore the error that is thrown when a pending lock is cancelled.\n        if (error !== E_CANCELED) throw error;\n      }\n    };\n\n    const unsubscribe = super.on(eventName, innerListener);\n\n    this.listenerMutexes.get(eventName)!.set(listener, {\n      mutex: new Mutex(),\n      latestEventData: undefined,\n      unsubscribe,\n    });\n\n    return unsubscribe;\n  }\n\n  cancelMutexes() {\n    for (const [, listenerMap] of this.listenerMutexes) {\n      for (const [, { mutex }] of listenerMap) {\n        mutex.cancel();\n      }\n    }\n  }\n}\n","import { type Abi, type AbiEvent, formatAbiItem } from \"abitype\";\nimport {\n  type GetEventArgs,\n  type Hex,\n  encodeEventTopics,\n  getAbiItem,\n  getEventSelector,\n  parseAbiItem,\n} from \"viem\";\n\nimport { getDuplicateElements } from \"@/utils/duplicates.js\";\nimport type { Config } from \"./config.js\";\nimport type { Topics } from \"./sources.js\";\n\n/**\n * Fix issue with Array.isArray not checking readonly arrays\n * {@link https://github.com/microsoft/TypeScript/issues/17002}\n */\ndeclare global {\n  interface ArrayConstructor {\n    isArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>;\n  }\n}\n\ntype AbiEventMeta = {\n  // Event name (if no overloads) or full event signature (if name is overloaded).\n  // This is the event name used when registering indexing functions using `ponder.on(\"ContractName:EventName\", ...)`\n  safeName: string;\n  // Full event signature, e.g. `event Deposit(address indexed from,bytes32 indexed id,uint value);`\n  signature: string;\n  // Keccak256 hash of the event signature (topic[0]).\n  selector: Hex;\n  // ABI item used for decoding raw logs.\n  item: AbiEvent;\n};\n\nexport type AbiEvents = {\n  bySafeName: { [key: string]: AbiEventMeta | undefined };\n  bySelector: { [key: Hex]: AbiEventMeta | undefined };\n};\n\nexport const buildAbiEvents = ({ abi }: { abi: Abi }) => {\n  const abiEvents = abi\n    .filter((item): item is AbiEvent => item.type === \"event\")\n    .filter((item) => item.anonymous === undefined || item.anonymous === false);\n\n  const overloadedEventNames = getDuplicateElements(\n    abiEvents.map((item) => item.name),\n  );\n\n  return abiEvents.reduce<AbiEvents>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedEventNames.has(item.name)\n        ? signature.split(\"event \")[1]\n        : item.name;\n      const selector = getEventSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n\nexport function buildTopics(\n  abi: Abi,\n  filter: NonNullable<Config[\"contracts\"][string][\"filter\"]>,\n): Topics {\n  if (Array.isArray(filter.event)) {\n    // List of event signatures\n    return [\n      filter.event.map((event) => getEventSelector(findAbiEvent(abi, event))),\n    ];\n  } else {\n    // Single event with args\n    return encodeEventTopics({\n      abi: [findAbiEvent(abi, filter.event)],\n      args: filter.args as GetEventArgs<Abi, string>,\n    });\n  }\n}\n\n/**\n * Finds the event ABI item for the event name or event signature.\n *\n * @param eventName Event name or event signature if there are duplicates\n */\nconst findAbiEvent = (abi: Abi, eventName: string): AbiEvent => {\n  if (eventName.includes(\"(\")) {\n    // full event signature\n    return parseAbiItem(`event ${eventName}`) as AbiEvent;\n  } else {\n    return getAbiItem({ abi, name: eventName }) as AbiEvent;\n  }\n};\n","/**\n * Returns a Set containing all the duplicate elements in an array of strings.\n * @param arr - The input array of strings.\n * @returns A Set object containing the duplicate elements found in the input array.\n */\nexport function getDuplicateElements(arr: string[]): Set<string> {\n  const uniqueElements = new Set<string>();\n  const duplicates = new Set<string>();\n\n  arr.forEach((element: string) => {\n    if (uniqueElements.has(element)) {\n      duplicates.add(element);\n    } else {\n      uniqueElements.add(element);\n    }\n  });\n\n  return duplicates;\n}\n","import type { AbiEvent } from \"abitype\";\nimport { getEventSelector } from \"viem\";\n\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { getBytesConsumedByParam } from \"@/utils/offset.js\";\nimport type { FactoryCriteria } from \"./sources.js\";\n\nexport function buildFactoryCriteria({\n  address: _address,\n  event,\n  parameter,\n}: {\n  address: `0x${string}`;\n  event: AbiEvent;\n  parameter: string;\n}) {\n  const address = toLowerCase(_address);\n  const eventSelector = getEventSelector(event);\n\n  // Check if the provided parameter is present in the list of indexed inputs.\n  const indexedInputPosition = event.inputs\n    .filter((x) => \"indexed\" in x && x.indexed)\n    .findIndex((input) => input.name === parameter);\n\n  if (indexedInputPosition > -1) {\n    return {\n      address,\n      eventSelector,\n      // Add 1 because inputs will not contain an element for topic0 (the signature).\n      childAddressLocation: `topic${(indexedInputPosition + 1) as 1 | 2 | 3}`,\n    } satisfies FactoryCriteria;\n  }\n\n  const nonIndexedInputs = event.inputs.filter(\n    (x) => !(\"indexed\" in x && x.indexed),\n  );\n  const nonIndexedInputPosition = nonIndexedInputs.findIndex(\n    (input) => input.name === parameter,\n  );\n\n  if (nonIndexedInputPosition === -1) {\n    throw new Error(\n      `Factory event parameter not found in factory event signature. Got '${parameter}', expected one of [${event.inputs\n        .map((i) => `'${i.name}'`)\n        .join(\", \")}].`,\n    );\n  }\n\n  let offset = 0;\n  for (let i = 0; i < nonIndexedInputPosition; i++) {\n    offset += getBytesConsumedByParam(nonIndexedInputs[i]);\n  }\n\n  return {\n    address,\n    eventSelector,\n    childAddressLocation: `offset${offset}`,\n  } satisfies FactoryCriteria;\n}\n","/**\n * Transforms the input string to lower case.\n */\nexport function toLowerCase<T extends string>(value: T) {\n  return value.toLowerCase() as Lowercase<T>;\n}\n","import type { AbiParameter } from \"abitype\";\nimport { InvalidAbiDecodingTypeError } from \"viem\";\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/5c95fafceffe7f399b5b5ee32119e2d78a0c8acd/src/utils/abi/decodeEventLog.ts\n\nexport function getBytesConsumedByParam(param: AbiParameter): number {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, innerType] = arrayComponents;\n\n    // If the array is dynamic or has dynamic children, it uses the\n    // dynamic encoding scheme (32 byte header).\n    if (!length || hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // If the length of the array is known in advance,\n    // and the length of each element in the array is known,\n    // the array data is encoded contiguously after the array.\n    const bytesConsumedByInnerType = getBytesConsumedByParam({\n      ...param,\n      type: innerType,\n    });\n    return length * bytesConsumedByInnerType;\n  }\n\n  if (param.type === \"tuple\") {\n    // If the tuple has dynamic children, it uses the dynamic encoding\n    // scheme (32 byte header).\n    if (hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // Otherwise the tuple has static children, so we can just decode\n    // each component in sequence.\n    let consumed = 0;\n    for (const component of (param as any).components ?? []) {\n      consumed += getBytesConsumedByParam(component);\n    }\n    return consumed;\n  }\n\n  // Otherwise, it's a dynamic string or bytes (32 bytes),\n  // or a static number, address, or bool (32 bytes).\n  if (\n    param.type === \"string\" ||\n    param.type.startsWith(\"bytes\") ||\n    param.type.startsWith(\"uint\") ||\n    param.type.startsWith(\"int\") ||\n    param.type === \"address\" ||\n    param.type === \"bool\"\n  ) {\n    return 32;\n  }\n\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: \"/docs/contract/decodeAbiParameters\",\n  });\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param;\n  if (type === \"string\") return true;\n  if (type === \"bytes\") return true;\n  if (type.endsWith(\"[]\")) return true;\n\n  if (type === \"tuple\") return (param as any).components?.some(hasDynamicChild);\n\n  const arrayComponents = getArrayComponents(param.type);\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true;\n\n  return false;\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined;\n}\n","import * as _chains from \"viem/chains\";\n\nexport const chains = _chains as unknown as Record<string, _chains.Chain>;\n","import { chains } from \"@/utils/chains.js\";\nimport type { Chain, Client, Transport } from \"viem\";\n\nexport type Network = {\n  name: string;\n  chainId: number;\n  chain: Chain;\n  transport: ReturnType<Transport>;\n  pollingInterval: number;\n  maxRequestsPerSecond: number;\n  maxHistoricalTaskConcurrency: number;\n  defaultMaxBlockRange: number;\n  finalityBlockCount: number;\n};\n\nexport function getDefaultMaxBlockRange({\n  chainId,\n  rpcUrls,\n}: {\n  chainId: number;\n  rpcUrls: (string | undefined)[];\n}) {\n  let maxBlockRange: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      maxBlockRange = 2_000;\n      break;\n    // Optimism.\n    case 10:\n    case 420:\n      maxBlockRange = 50_000;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      maxBlockRange = 50_000;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 421613:\n      maxBlockRange = 50_000;\n      break;\n    default:\n      maxBlockRange = 50_000;\n  }\n\n  const isQuickNode = rpcUrls\n    .filter((url): url is string => url !== undefined)\n    .some((url) => url.includes(\"quiknode\"));\n\n  const isCloudflare = rpcUrls\n    .filter((url): url is string => url !== undefined)\n    .some((url) => url.includes(\"cloudflare-eth\"));\n\n  if (isQuickNode) {\n    maxBlockRange = Math.min(maxBlockRange, 10_000);\n  } else if (isCloudflare) {\n    maxBlockRange = Math.min(maxBlockRange, 800);\n  }\n\n  return maxBlockRange;\n}\n\n/**\n * Returns the number of blocks that must pass before a block is considered final.\n * Note that a value of `0` indicates that blocks are considered final immediately.\n *\n * @param network The network to get the finality block count for.\n * @returns The finality block count.\n */\nexport function getFinalityBlockCount({ chainId }: { chainId: number }) {\n  let finalityBlockCount: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      finalityBlockCount = 32;\n      break;\n    // Optimism.\n    case 10:\n    case 420:\n      finalityBlockCount = 5;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      finalityBlockCount = 100;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 421613:\n      finalityBlockCount = 40;\n      break;\n    // Zora.\n    case 7777777:\n      finalityBlockCount = 5;\n      break;\n    default:\n      finalityBlockCount = 5;\n  }\n\n  return finalityBlockCount;\n}\n\n/**\n * Returns the list of RPC URLs backing a Transport.\n *\n * @param transport A viem Transport.\n * @returns Array of RPC URLs.\n */\nexport async function getRpcUrlsForClient(parameters: {\n  transport: Transport;\n  chain: Chain;\n}) {\n  // This is how viem converts a Transport into the Client.transport type.\n  const { config, value } = parameters.transport({\n    chain: parameters.chain,\n    pollingInterval: 4_000, // default viem value\n  });\n  const transport = { ...config, ...value } as Client[\"transport\"];\n\n  async function getRpcUrlsForTransport(transport: Client[\"transport\"]) {\n    switch (transport.type) {\n      case \"http\": {\n        return [transport.url ?? parameters.chain.rpcUrls.default.http[0]];\n      }\n      case \"webSocket\": {\n        try {\n          const socket = await transport.getSocket();\n          return [socket.url];\n        } catch (e) {\n          const symbol = Object.getOwnPropertySymbols(e).find(\n            (symbol) => symbol.toString() === \"Symbol(kTarget)\",\n          );\n          if (!symbol) return [];\n          const url = (e as any)[symbol]?._url;\n          if (!url) return [];\n          return [url.replace(/\\/$/, \"\")];\n        }\n      }\n      case \"fallback\": {\n        // This is how viem converts a TransportConfig into the Client.transport type.\n        const fallbackTransports = transport.transports.map((t: any) => ({\n          ...t.config,\n          ...t.value,\n        })) as Client[\"transport\"][];\n\n        const urls: (string | undefined)[] = [];\n        for (const fallbackTransport of fallbackTransports) {\n          urls.push(...(await getRpcUrlsForTransport(fallbackTransport)));\n        }\n\n        return urls;\n      }\n      default: {\n        // TODO: Consider logging a warning here. This will catch \"custom\" and unknown transports,\n        // which we might not want to support.\n        return [];\n      }\n    }\n  }\n\n  return getRpcUrlsForTransport(transport);\n}\n\nlet publicRpcUrls: Set<string> | undefined = undefined;\n\n/**\n * Returns `true` if the RPC URL is found in the list of public RPC URLs\n * included in viem/chains. Handles both HTTP and WebSocket RPC URLs.\n *\n * @param rpcUrl An RPC URL.\n * @returns Boolean indicating if the RPC URL is public.\n */\nexport function isRpcUrlPublic(rpcUrl: string | undefined) {\n  if (rpcUrl === undefined) return true;\n\n  if (!publicRpcUrls) {\n    // By default, viem uses `chain.default.{http|webSocket}.[0]` if it exists.\n    publicRpcUrls = Object.values(chains).reduce<Set<string>>((acc, chain) => {\n      chain.rpcUrls.default.http.forEach((httpRpcUrl) => {\n        acc.add(httpRpcUrl);\n      });\n\n      (\n        (chain.rpcUrls.default as unknown as { webSocket?: string[] })\n          .webSocket ?? []\n      ).forEach((webSocketRpcUrl) => {\n        acc.add(webSocketRpcUrl);\n      });\n\n      return acc;\n    }, new Set<string>());\n  }\n\n  return publicRpcUrls.has(rpcUrl);\n}\n","import { buildAbiEvents, buildTopics } from \"@/config/abi.js\";\nimport type { Config } from \"@/config/config.js\";\nimport { buildFactoryCriteria } from \"@/config/factories.js\";\nimport {\n  type Network,\n  getDefaultMaxBlockRange,\n  getFinalityBlockCount,\n  getRpcUrlsForClient,\n  isRpcUrlPublic,\n} from \"@/config/networks.js\";\nimport { chains } from \"@/utils/chains.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type {\n  Factory,\n  LogFilter,\n  Source,\n  Topics,\n} from \"../../config/sources.js\";\n\nexport async function buildNetworksAndSources({ config }: { config: Config }) {\n  const warnings: string[] = [];\n\n  const networks: Network[] = await Promise.all(\n    Object.entries(config.networks).map(async ([networkName, network]) => {\n      const { chainId, transport } = network;\n\n      const defaultChain =\n        Object.values(chains).find((c) =>\n          \"id\" in c ? c.id === chainId : false,\n        ) ?? chains.mainnet;\n      const chain = { ...defaultChain, name: networkName, id: chainId };\n\n      // Note: This can throw.\n      const rpcUrls = await getRpcUrlsForClient({ transport, chain });\n      rpcUrls.forEach((rpcUrl) => {\n        if (isRpcUrlPublic(rpcUrl)) {\n          warnings.push(\n            `Network '${networkName}' is using a public RPC URL (${rpcUrl}). Most apps require an RPC URL with a higher rate limit.`,\n          );\n        }\n      });\n\n      return {\n        name: networkName,\n        chainId: chainId,\n        chain,\n        transport: network.transport({ chain }),\n        maxRequestsPerSecond: network.maxRequestsPerSecond ?? 50,\n        pollingInterval: network.pollingInterval ?? 1_000,\n        defaultMaxBlockRange: getDefaultMaxBlockRange({ chainId, rpcUrls }),\n        finalityBlockCount: getFinalityBlockCount({ chainId }),\n        maxHistoricalTaskConcurrency: 20,\n      } satisfies Network;\n    }),\n  );\n\n  const sources: Source[] = Object.entries(config.contracts)\n    // First, apply any network-specific overrides and flatten the result.\n    .flatMap(([contractName, contract]) => {\n      if (contract.network === null || contract.network === undefined) {\n        throw new Error(\n          `Validation failed: Network for contract '${contractName}' is null or undefined. Expected one of [${networks\n            .map((n) => `'${n.name}'`)\n            .join(\", \")}].`,\n        );\n      }\n\n      // Single network case.\n      if (typeof contract.network === \"string\") {\n        return {\n          id: `${contractName}_${contract.network}`,\n          contractName,\n          networkName: contract.network,\n          abi: contract.abi,\n\n          address: \"address\" in contract ? contract.address : undefined,\n          factory: \"factory\" in contract ? contract.factory : undefined,\n          filter: contract.filter,\n\n          startBlock: contract.startBlock ?? 0,\n          endBlock: contract.endBlock,\n          maxBlockRange: contract.maxBlockRange,\n        };\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"contracts\"][string][\"network\"], string>[string]\n      >;\n\n      // Multiple networks case.\n      return Object.entries(contract.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => ({\n          id: `${contractName}_${networkName}`,\n          contractName,\n          networkName,\n          abi: contract.abi,\n\n          address:\n            (\"address\" in overrides ? overrides?.address : undefined) ??\n            (\"address\" in contract ? contract.address : undefined),\n          factory:\n            (\"factory\" in overrides ? overrides.factory : undefined) ??\n            (\"factory\" in contract ? contract.factory : undefined),\n          filter: overrides.filter ?? contract.filter,\n\n          startBlock: overrides.startBlock ?? contract.startBlock ?? 0,\n          endBlock: overrides.endBlock ?? contract.endBlock,\n          maxBlockRange: overrides.maxBlockRange ?? contract.maxBlockRange,\n        }));\n    })\n    // Second, build and validate the factory or log filter.\n    .map((rawContract) => {\n      const network = networks.find((n) => n.name === rawContract.networkName);\n      if (!network) {\n        throw new Error(\n          `Validation failed: Invalid network for contract '${\n            rawContract.contractName\n          }'. Got '${rawContract.networkName}', expected one of [${networks\n            .map((n) => `'${n.name}'`)\n            .join(\", \")}].`,\n        );\n      }\n\n      // Note: This can probably throw for invalid ABIs. Consider adding explicit ABI validation before this line.\n      const abiEvents = buildAbiEvents({ abi: rawContract.abi });\n\n      let topics: Topics | undefined = undefined;\n\n      if (rawContract.filter !== undefined) {\n        if (\n          Array.isArray(rawContract.filter.event) &&\n          rawContract.filter.args !== undefined\n        ) {\n          throw new Error(\n            `Validation failed: Event filter for contract '${rawContract.contractName}' cannot contain indexed argument values if multiple events are provided.`,\n          );\n        }\n\n        const filterSafeEventNames = Array.isArray(rawContract.filter.event)\n          ? rawContract.filter.event\n          : [rawContract.filter.event];\n\n        for (const filterSafeEventName of filterSafeEventNames) {\n          const abiEvent = abiEvents.bySafeName[filterSafeEventName];\n          if (!abiEvent) {\n            throw new Error(\n              `Validation failed: Invalid filter for contract '${\n                rawContract.contractName\n              }'. Got event name '${filterSafeEventName}', expected one of [${Object.keys(\n                abiEvents.bySafeName,\n              )\n                .map((n) => `'${n}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        // TODO: Explicit validation of indexed argument value format (array or object).\n        // Note: This can throw.\n        topics = buildTopics(rawContract.abi, rawContract.filter);\n      }\n\n      const baseContract = {\n        id: rawContract.id,\n        contractName: rawContract.contractName,\n        networkName: rawContract.networkName,\n        chainId: network.chainId,\n        abi: rawContract.abi,\n        abiEvents: abiEvents,\n        startBlock: rawContract.startBlock,\n        endBlock: rawContract.endBlock,\n        maxBlockRange: rawContract.maxBlockRange,\n      };\n\n      const resolvedFactory = rawContract?.factory;\n      const resolvedAddress = rawContract?.address;\n\n      if (resolvedFactory !== undefined && resolvedAddress !== undefined) {\n        throw new Error(\n          `Validation failed: Contract '${baseContract.contractName}' cannot specify both 'factory' and 'address' options.`,\n        );\n      }\n\n      if (resolvedFactory) {\n        // Note that this can throw.\n        const factoryCriteria = buildFactoryCriteria(resolvedFactory);\n\n        return {\n          ...baseContract,\n          type: \"factory\",\n          criteria: { ...factoryCriteria, topics },\n        } satisfies Factory;\n      }\n\n      const validatedAddress = Array.isArray(resolvedAddress)\n        ? resolvedAddress.map((r) => toLowerCase(r))\n        : resolvedAddress\n          ? toLowerCase(resolvedAddress)\n          : undefined;\n\n      if (validatedAddress !== undefined) {\n        for (const address of Array.isArray(validatedAddress)\n          ? validatedAddress\n          : [validatedAddress]) {\n          if (!address.startsWith(\"0x\"))\n            throw new Error(\n              `Validation failed: Invalid prefix for address '${address}'. Got '${address.slice(\n                0,\n                2,\n              )}', expected '0x'.`,\n            );\n          if (address.length !== 42)\n            throw new Error(\n              `Validation failed: Invalid length for address '${address}'. Got ${address.length}, expected 42 characters.`,\n            );\n        }\n      }\n\n      return {\n        ...baseContract,\n        type: \"logFilter\",\n        criteria: {\n          address: validatedAddress,\n          topics,\n        },\n      } satisfies LogFilter;\n    });\n\n  return { networks, sources, warnings };\n}\n\nexport async function safeBuildNetworksAndSources({\n  config,\n}: { config: Config }) {\n  try {\n    const result = await buildNetworksAndSources({ config });\n\n    return { success: true, data: result } as const;\n  } catch (error_) {\n    const error = error_ as Error;\n    error.stack = undefined;\n    return { success: false, error } as const;\n  }\n}\n","export type RawIndexingFunctions = {\n  [fileName: string]: { name: string; fn: (...args: any) => any }[];\n};\n\nexport type IndexingFunctions = {\n  [sourceName: string]: {\n    [eventName: string]: (...args: any) => any;\n  };\n};\n\nexport function buildIndexingFunctions({\n  rawIndexingFunctions,\n}: { rawIndexingFunctions: RawIndexingFunctions }) {\n  const warnings: string[] = [];\n\n  let indexingFunctionCount = 0;\n  const indexingFunctions: IndexingFunctions = {};\n\n  for (const fileFns of Object.values(rawIndexingFunctions)) {\n    for (const { name: eventKey, fn } of fileFns) {\n      const eventNameComponents = eventKey.split(\":\");\n      const [sourceName, eventName] = eventNameComponents;\n      if (eventNameComponents.length !== 2 || !sourceName || !eventName) {\n        throw new Error(\n          `Validation failed: Invalid event '${eventKey}', expected format '{contractName}:{eventName}'.`,\n        );\n      }\n\n      indexingFunctions[sourceName] ||= {};\n\n      if (eventName in indexingFunctions[sourceName]) {\n        throw new Error(\n          `Validation failed: Multiple indexing functions registered for event '${eventKey}'.`,\n        );\n      }\n\n      indexingFunctions[sourceName][eventName] = fn;\n      indexingFunctionCount += 1;\n    }\n  }\n\n  if (indexingFunctionCount === 0) {\n    warnings.push(\"No indexing functions were registered.\");\n  }\n\n  return { indexingFunctions, warnings } as const;\n}\n\nexport function safeBuildIndexingFunctions({\n  rawIndexingFunctions,\n}: { rawIndexingFunctions: RawIndexingFunctions }) {\n  try {\n    const result = buildIndexingFunctions({ rawIndexingFunctions });\n\n    return { success: true, data: result } as const;\n  } catch (error_) {\n    const error = error_ as Error;\n    error.stack = undefined;\n    return { success: false, error } as const;\n  }\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { SgNode, js, ts } from \"@ast-grep/napi\";\n\nconst ormFunctions = {\n  create: [\"write\"],\n  update: [\"read\", \"write\"],\n  upsert: [\"read\", \"write\"],\n  delete: [\"write\"],\n  findUnique: [\"read\"],\n  findMany: [\"read\"],\n  createMany: [\"write\"],\n  updateMany: [\"read\", \"write\"],\n} as const;\n\n/**\n * Return the event signature, \"{ContractName}:{EventName}\", from the AST node.\n */\nconst getEventSignature = (node: SgNode) => {\n  return node.getMatch(\"NAME\")?.text()!;\n};\n\nconst parseTableReference = (\n  node: SgNode,\n  tableNames: string[],\n): string | null => {\n  // _table can often be \"context.db.TABLE\"\n  const _table = node.getMatch(\"TABLE\")!.text()!.split(\".\")!;\n  const table = _table.length === 1 ? _table[0] : _table[_table.length - 1];\n\n  const isIncluded = tableNames.includes(table);\n\n  // Note: Null represents flag to say: \"mark this function as fully dependent\"\n  return isIncluded ? table : null;\n};\n\nconst findAllORMCalls = (root: SgNode) => {\n  return Object.keys(ormFunctions).map((ormf) => ({\n    method: ormf as keyof typeof ormFunctions,\n    nodes: root.findAll(`$TABLE.${ormf}($_)`),\n  }));\n};\n\n// const printNodes = (nodes: SgNode[]) => {\n//   for (const node of nodes) {\n//     console.log(node.text());\n//   }\n// };\n\nconst helperFunctionName = (node: SgNode) => {\n  const arrowFuncAncestor = node\n    .ancestors()\n    .filter((n) => n.kind() === \"arrow_function\");\n\n  const arrowFuncName = arrowFuncAncestor.map((f) =>\n    f\n      .prevAll()\n      .find((a) => a.kind() === \"identifier\")\n      ?.text(),\n  );\n\n  const funcDeclarAncestor = node\n    .ancestors()\n    .filter((n) => n.kind() === \"function_declaration\");\n\n  const funcDeclarName = funcDeclarAncestor.map((f) =>\n    f\n      .children()\n      .find((c) => c.kind() === \"identifier\")\n      ?.text(),\n  );\n\n  return [...arrowFuncName, ...funcDeclarName].filter(\n    (name) => !!name,\n  ) as string[];\n};\n\nexport type TableAccess = {\n  table: string;\n  indexingFunctionKey: string;\n  access: \"read\" | \"write\";\n}[];\n\nexport const parseAst = ({\n  tableNames,\n  filePaths,\n}: {\n  tableNames: string[];\n  indexingFunctionKeys: string[];\n  filePaths: string[];\n}) => {\n  const tableAccessMap = [] as TableAccess;\n\n  const helperFunctionAccess: Record<\n    string,\n    {\n      table: string | null;\n      method: keyof typeof ormFunctions;\n      filePath: string;\n    }[]\n  > = {};\n\n  const addToTableAccess = (\n    table: string | null,\n    indexingFunctionKey: string,\n    method: keyof typeof ormFunctions,\n  ) => {\n    if (table) {\n      for (const access of ormFunctions[method]) {\n        tableAccessMap.push({\n          table: table,\n          indexingFunctionKey,\n          access,\n        });\n      }\n    } else {\n      for (const table of tableNames) {\n        for (const access of ormFunctions[method]) {\n          tableAccessMap.push({\n            table: table,\n            indexingFunctionKey,\n            access,\n          });\n        }\n      }\n    }\n  };\n\n  // Register all helper functions\n  for (const filePath of filePaths) {\n    const file = fs.readFileSync(filePath).toString();\n\n    const isJs = path.extname(filePath) === \".js\";\n    const ast = isJs ? js.parse(file) : ts.parse(file);\n    const root = ast.root();\n\n    const ormCalls = findAllORMCalls(root);\n\n    for (const call of ormCalls) {\n      for (const node of call.nodes) {\n        const helperNames = helperFunctionName(node);\n        const table = parseTableReference(node, tableNames);\n\n        for (const helperName of helperNames) {\n          if (helperFunctionAccess[helperName] === undefined) {\n            helperFunctionAccess[helperName] = [];\n          }\n          helperFunctionAccess[helperName].push({\n            table,\n            method: call.method,\n            filePath,\n          });\n        }\n      }\n    }\n  }\n\n  // Build tableAccess\n  for (const filePath of filePaths) {\n    const file = fs.readFileSync(filePath).toString();\n\n    const isJs = path.extname(filePath) === \".js\";\n    const ast = isJs ? js.parse(file) : ts.parse(file);\n    const root = ast.root();\n\n    const nodes = root\n      .findAll('ponder.on(\"$NAME\", $FUNC)')\n      .concat(root.findAll(\"ponder.on('$NAME', $FUNC)\"))\n      .concat(root.findAll(\"ponder.on(`$NAME`, $FUNC)\"));\n\n    for (const node of nodes) {\n      const indexingFunctionKey = getEventSignature(node);\n\n      const funcNode = node.getMatch(\"FUNC\")!;\n\n      const ormCalls = findAllORMCalls(funcNode);\n\n      // Search for calls to helper function\n      for (const [name, helperFunctionState] of Object.entries(\n        helperFunctionAccess,\n      )) {\n        if (funcNode.find(`${name}`) !== null) {\n          for (const state of helperFunctionState) {\n            addToTableAccess(state.table, indexingFunctionKey, state.method);\n          }\n        }\n      }\n\n      // Search for table access in indexing function\n      for (const call of ormCalls) {\n        for (const n of call.nodes) {\n          const table = parseTableReference(n, tableNames);\n          addToTableAccess(table, indexingFunctionKey, call.method);\n        }\n      }\n    }\n  }\n\n  return tableAccessMap;\n};\n","import MagicString from \"magic-string\";\nimport type { Plugin } from \"vite\";\n\nexport const regex =\n  /^import\\s+\\{[^}]*\\bponder\\b[^}]*\\}\\s+from\\s+[\"']@\\/generated[\"'];?.*$/gm;\n\nexport const shim = `export let ponder = {\n  fns: [],\n  on(name, fn) {\n    this.fns.push({ name, fn });\n  },\n};\n`;\n\nexport function replaceStateless(code: string) {\n  const s = new MagicString(code);\n  // MagicString.replace calls regex.exec(), which increments `lastIndex`\n  // on a match. We have to set this back to zero to use the same regex\n  // multiple times.\n  regex.lastIndex = 0;\n  s.replace(regex, shim);\n  return s;\n}\n\nexport const vitePluginPonder = (): Plugin => {\n  return {\n    name: \"ponder\",\n    transform: (code, id) => {\n      if (regex.test(code)) {\n        const s = replaceStateless(code);\n        const transformed = s.toString();\n        const sourcemap = s.generateMap({ source: id });\n        return { code: transformed, map: sourcemap };\n      } else {\n        return null;\n      }\n    },\n  };\n};\n","import { readFileSync } from \"node:fs\";\n\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { parse as parseStackTrace } from \"stacktrace-parser\";\n\nclass ESBuildTransformError extends Error {\n  override name = \"ESBuildTransformError\";\n}\n\nclass ESBuildBuildError extends Error {\n  override name = \"ESBuildBuildError\";\n}\n\nclass ESBuildContextError extends Error {\n  override name = \"ESBuildContextError\";\n}\n\nexport type ViteNodeError =\n  | ESBuildTransformError\n  | ESBuildBuildError\n  | ESBuildContextError\n  | Error;\n\nexport function parseViteNodeError(file: string, error: Error): ViteNodeError {\n  let resolvedError: ViteNodeError;\n\n  if (/^(Transform failed|Build failed|Context failed)/.test(error.message)) {\n    // Handle ESBuild errors based on this error message construction logic:\n    // https://github.com/evanw/esbuild/blob/4e11b50fe3178ed0a78c077df78788d66304d379/lib/shared/common.ts#L1659\n    const errorKind = error.message.split(\" with \")[0] as\n      | \"Transform failed\"\n      | \"Build failed\"\n      | \"Context failed\";\n    const innerError = error.message\n      .split(\"\\n\")\n      .slice(1)\n      .map((message) => {\n        let location: string | undefined = undefined;\n        let detail: string | undefined = undefined;\n        if (message.includes(\": ERROR: \")) {\n          // /path/to/file.ts:11:9: ERROR: Expected \")\" but found \";\"\n          const s = message.split(\": ERROR: \");\n          location = s[0];\n          detail = s[1];\n        } else {\n          // error: some error without a location\n          detail = message.slice(7);\n        }\n        return { location, detail };\n      })[0];\n\n    // If we aren't able to extract an inner error, just return the original.\n    if (!innerError) return error;\n\n    resolvedError =\n      errorKind === \"Transform failed\"\n        ? new ESBuildTransformError(innerError.detail)\n        : errorKind === \"Build failed\"\n          ? new ESBuildBuildError(innerError.detail)\n          : new ESBuildContextError(innerError.detail);\n    if (innerError.location)\n      resolvedError.stack = `    at ${innerError.location}`;\n  }\n  // If it's not an ESBuild error, it's a user-land vm.runModuleInContext execution error.\n  // Attempt to build a user-land stack trace.\n  else if (error.stack) {\n    const stackFrames = parseStackTrace(error.stack);\n\n    const userStackFrames = [];\n    for (const rawStackFrame of stackFrames) {\n      if (rawStackFrame.methodName.includes(\"ViteNodeRunner.runModule\")) break;\n      userStackFrames.push(rawStackFrame);\n    }\n\n    const userStack = userStackFrames\n      .map(({ file, lineNumber, column, methodName }) => {\n        const prefix = \"    at\";\n        const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n          column !== null ? `:${column}` : \"\"\n        }`;\n        if (methodName === null || methodName === \"<unknown>\") {\n          return `${prefix} ${path}`;\n        } else {\n          return `${prefix} ${methodName} (${path})`;\n        }\n      })\n      .join(\"\\n\");\n\n    resolvedError = error;\n    resolvedError.stack = userStack;\n  }\n  // Still a vm.runModuleInContext execution error, but no stack.\n  else {\n    resolvedError = error;\n  }\n\n  // Attempt to build a code frame for the top of the user stack. This works for\n  // both ESBuild and vm.runModuleInContext errors.\n  if (resolvedError.stack) {\n    const userStackFrames = parseStackTrace(resolvedError.stack);\n\n    let codeFrame: string | undefined = undefined;\n    for (const { file, lineNumber, column } of userStackFrames) {\n      if (file !== null && lineNumber !== null) {\n        try {\n          const sourceFileContents = readFileSync(file, { encoding: \"utf-8\" });\n          codeFrame = codeFrameColumns(\n            sourceFileContents,\n            { start: { line: lineNumber, column: column ?? undefined } },\n            { highlightCode: true },\n          );\n          break;\n        } catch (err) {\n          // No-op.\n        }\n      }\n    }\n\n    resolvedError.stack = `${resolvedError.name}: ${resolvedError.message}\\n${resolvedError.stack}`;\n    if (codeFrame) resolvedError.stack += `\\n${codeFrame}`;\n  }\n\n  // Finally, add a useful relative file name and verb to the error message.\n  const verb =\n    resolvedError.name === \"ESBuildTransformError\"\n      ? \"transforming\"\n      : resolvedError.name === \"ESBuildBuildError\" ||\n          resolvedError.name === \"ESBuildContextError\"\n        ? \"building\"\n        : \"executing\";\n  resolvedError.message = `Error while ${verb} ${file}: ${resolvedError.message}`;\n\n  return resolvedError;\n}\n","import { writeFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/Ponder.js\";\nimport { Emittery } from \"@/utils/emittery.js\";\nimport { ensureDirExists } from \"@/utils/exists.js\";\nimport type { GraphQLSchema } from \"graphql\";\nimport { printSchema } from \"graphql\";\nimport { ponderEnv } from \"./ponderEnv.js\";\n\nexport class CodegenService extends Emittery {\n  private common: Common;\n\n  constructor({ common }: { common: Common }) {\n    super();\n    this.common = common;\n  }\n\n  generatePonderEnv() {\n    const filePath = path.join(this.common.options.rootDir, \"ponder-env.d.ts\");\n    writeFileSync(filePath, ponderEnv, \"utf8\");\n\n    this.common.logger.debug({\n      service: \"codegen\",\n      msg: \"Wrote new file at ponder-env.d.ts\",\n    });\n  }\n\n  generateGraphqlSchemaFile({\n    graphqlSchema,\n  }: {\n    graphqlSchema: GraphQLSchema;\n  }) {\n    const final = printSchema(graphqlSchema);\n\n    const filePath = path.join(\n      this.common.options.generatedDir,\n      \"schema.graphql\",\n    );\n    ensureDirExists(filePath);\n    writeFileSync(filePath, final, \"utf8\");\n\n    this.common.logger.debug({\n      service: \"codegen\",\n      msg: \"Wrote new file at generated/schema.graphql\",\n    });\n  }\n}\n","import { existsSync, mkdirSync } from \"node:fs\";\nimport path from \"node:path\";\n\nexport const ensureDirExists = (filePath: string) => {\n  const dirname = path.dirname(filePath);\n  if (existsSync(dirname)) {\n    return;\n  }\n  mkdirSync(dirname, { recursive: true });\n};\n","export const ponderEnv = `// This file enables type checking and editor autocomplete for this Ponder project.\n// After upgrading, you may find that changes have been made to this file.\n// If this happens, please commit the changes. Do not manually edit this file.\n// See https://ponder.sh/docs/guides/typescript for more information.\n\ndeclare module \"@/generated\" {\n  import type { Virtual } from \"@ponder/core\";\n\n  type config = typeof import(\"./ponder.config.ts\").default;\n  type schema = typeof import(\"./ponder.schema.ts\").default;\n\n  export const ponder: Virtual.Registry<config, schema>;\n\n  export type EventNames = Virtual.EventNames<config>;\n  export type Event<name extends EventNames = EventNames> = Virtual.Event<\n    config,\n    name\n  >;\n  export type Context<name extends EventNames = EventNames> = Virtual.Context<\n    config,\n    schema,\n    name\n  >;\n  export type IndexingFunctionArgs<name extends EventNames = EventNames> =\n    Virtual.IndexingFunctionArgs<config, schema, name>;\n  export type Schema = Virtual.Schema<schema>;\n}\n`;\n","import path from \"node:path\";\nimport type { Common } from \"@/Ponder.js\";\nimport type { Config } from \"@/config/config.js\";\nimport { createPool } from \"@/utils/pg.js\";\nimport { type SqliteDatabase, createSqliteDatabase } from \"@/utils/sqlite.js\";\nimport type { Pool } from \"pg\";\nimport parse from \"pg-connection-string\";\n\nconst getDatabaseName = (connectionString: string) => {\n  const parsed = (parse as unknown as typeof parse.parse)(connectionString);\n  return `${parsed.host}:${parsed.port}/${parsed.database}`;\n};\n\ntype StoreConfig =\n  | { kind: \"sqlite\"; database: SqliteDatabase }\n  | { kind: \"postgres\"; pool: Pool };\n\nexport type DatabaseConfig = {\n  sync: StoreConfig;\n  indexing: StoreConfig;\n};\n\nexport const buildDatabase = ({\n  common,\n  config,\n}: {\n  common: Common;\n  config: Config;\n}): DatabaseConfig => {\n  const { ponderDir, rootDir } = common.options;\n  const defaultStorePath = path.join(ponderDir, \"store\");\n  const defaultSyncFilePath = path.join(defaultStorePath, \"sync.db\");\n  const defaultIndexingFilePath = path.join(defaultStorePath, \"indexing.db\");\n  const sqlitePrintPath = path.relative(rootDir, defaultStorePath);\n\n  // If the user manually specified a database, use it.\n  if (config.database?.kind) {\n    if (config.database.kind === \"postgres\") {\n      let connectionString: string | undefined = undefined;\n      let source: string | undefined = undefined;\n\n      if (config.database.connectionString) {\n        connectionString = config.database.connectionString;\n        source = \"ponder.config.ts\";\n      } else if (process.env.DATABASE_PRIVATE_URL) {\n        connectionString = process.env.DATABASE_PRIVATE_URL;\n        source = \"DATABASE_PRIVATE_URL env var\";\n      } else if (process.env.DATABASE_URL) {\n        connectionString = process.env.DATABASE_URL;\n        source = \"DATABASE_URL env var\";\n      } else {\n        throw new Error(\n          `Invalid database configuration: \"kind\" is set to \"postgres\" but no connection string was provided.`,\n        );\n      }\n\n      common.logger.info({\n        service: \"database\",\n        msg: `Using Postgres database ${getDatabaseName(\n          connectionString,\n        )} (from ${source})`,\n      });\n\n      const pool = createPool({ connectionString });\n\n      return {\n        sync: { kind: \"postgres\", pool },\n        indexing: { kind: \"postgres\", pool },\n      } satisfies DatabaseConfig;\n    }\n\n    // Otherwise, it's SQLite.\n    common.logger.info({\n      service: \"database\",\n      msg: `Using SQLite database at ${sqlitePrintPath} (from ponder.config.ts)`,\n    });\n    return {\n      sync: {\n        kind: \"sqlite\",\n        database: createSqliteDatabase(defaultSyncFilePath),\n      },\n      indexing: {\n        kind: \"sqlite\",\n        database: createSqliteDatabase(defaultIndexingFilePath),\n      },\n    } satisfies DatabaseConfig;\n  }\n\n  let connectionString: string | undefined = undefined;\n  let source: string | undefined = undefined;\n\n  if (process.env.DATABASE_PRIVATE_URL) {\n    connectionString = process.env.DATABASE_PRIVATE_URL;\n    source = \"DATABASE_PRIVATE_URL env var\";\n  } else if (process.env.DATABASE_URL) {\n    connectionString = process.env.DATABASE_URL;\n    source = \"DATABASE_URL env var\";\n  }\n\n  // If either of the DATABASE_URL env vars are set, use them.\n  if (connectionString !== undefined) {\n    const pool = createPool({ connectionString });\n\n    common.logger.info({\n      service: \"database\",\n      msg: `Using Postgres database ${getDatabaseName(\n        connectionString,\n      )} (from ${source})`,\n    });\n\n    return {\n      sync: { kind: \"postgres\", pool },\n      indexing: { kind: \"postgres\", pool },\n    } satisfies DatabaseConfig;\n  }\n\n  // Fall back to SQLite.\n  common.logger.info({\n    service: \"database\",\n    msg: `Using SQLite database at ${sqlitePrintPath} (default)`,\n  });\n\n  return {\n    sync: {\n      kind: \"sqlite\",\n      database: createSqliteDatabase(defaultSyncFilePath),\n    },\n    indexing: {\n      kind: \"sqlite\",\n      database: createSqliteDatabase(defaultIndexingFilePath),\n    },\n  } satisfies DatabaseConfig;\n};\n","import pg, { type PoolConfig } from \"pg\";\nimport { prettyPrint } from \"./print.js\";\n\n// See https://github.com/brianc/node-pg-types for details.\n// Use BigInt for `numeric` types.\npg.types.setTypeParser(pg.types.builtins.NUMERIC, BigInt);\n// Use Number for `bigint`/`int8` types. We use these for chain IDs.\npg.types.setTypeParser(pg.types.builtins.INT8, Number);\n\n// Monkeypatch Pool.query to get more informative stack traces. I have no idea why this works.\n// https://stackoverflow.com/a/70601114\nconst originalClientQuery = pg.Client.prototype.query;\n// @ts-ignore\npg.Client.prototype.query = function query(\n  ...args: [queryText: string, values: any[], callback: () => void]\n) {\n  try {\n    return originalClientQuery.apply(this, args);\n  } catch (error_) {\n    const error = error_ as Error & { detail?: string; meta?: string };\n    const [statement, parameters_] = args ?? [\"empty\", []];\n\n    error.name = \"PostgresError\";\n\n    let parameters = parameters_ ?? [];\n    parameters =\n      parameters.length <= 25\n        ? parameters\n        : parameters.slice(0, 26).concat([\"...\"]);\n    const params = parameters.reduce<Record<number, any>>(\n      (acc, parameter, idx) => {\n        acc[idx + 1] = parameter;\n        return acc;\n      },\n      {},\n    );\n\n    const metaMessages = [];\n    if (error.detail) metaMessages.push(`Detail:\\n  ${error.detail}`);\n    metaMessages.push(`Statement:\\n  ${statement}`);\n    metaMessages.push(`Parameters:\\n${prettyPrint(params)}`);\n\n    error.meta = metaMessages.join(\"\\n\");\n\n    throw error;\n  }\n};\n\nexport function createPool(config: PoolConfig) {\n  return new pg.Pool({\n    // https://stackoverflow.com/questions/59155572/how-to-set-query-timeout-in-relation-to-statement-timeout\n    statement_timeout: 30_000,\n    ...config,\n  });\n}\n","// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/021ce8e5a3fb02db6139564345a91fc77cba08a6/src/errors/transaction.ts#L6-L19\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null;\n\n      const trimmedValue =\n        typeof value === \"string\" && value.length > 80\n          ? value.slice(0, 80).concat(\"...\")\n          : value;\n\n      return [key, trimmedValue];\n    })\n    .filter(Boolean) as [string, string][];\n  const maxLength = entries.reduce(\n    (acc, [key]) => Math.max(acc, key.length),\n    0,\n  );\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join(\"\\n\");\n}\n","import BetterSqlite3 from \"better-sqlite3\";\n\nimport { ensureDirExists } from \"./exists.js\";\nimport { prettyPrint } from \"./print.js\";\n\nfunction improveSqliteErrors(database: BetterSqlite3.Database) {\n  const originalPrepare = database.prepare;\n  // @ts-ignore\n  database.prepare = (source: string) => {\n    const statement = originalPrepare.apply(database, [source]);\n    const wrapper =\n      (fn: (...args: any) => void) =>\n      (...args: any) => {\n        try {\n          return fn.apply(statement, args);\n        } catch (error_) {\n          const error = error_ as Error & { detail?: string; meta?: string };\n          error.name = \"SqliteError\";\n\n          let parameters = (args[0] ?? []) as string[];\n          parameters =\n            parameters.length <= 25\n              ? parameters\n              : parameters.slice(0, 26).concat([\"...\"]);\n          const params = parameters.reduce<Record<number, any>>(\n            (acc, parameter, idx) => {\n              acc[idx + 1] = parameter;\n              return acc;\n            },\n            {},\n          );\n\n          const metaMessages = [];\n          if (error.detail) metaMessages.push(`Detail:\\n  ${error.detail}`);\n          metaMessages.push(`Statement:\\n  ${source}`);\n          metaMessages.push(`Parameters:\\n${prettyPrint(params)}`);\n\n          error.meta = metaMessages.join(\"\\n\");\n\n          throw error;\n        }\n      };\n\n    for (const method of [\"run\", \"get\", \"all\"]) {\n      // @ts-ignore\n      statement[method] = wrapper(statement[method]);\n    }\n\n    return statement;\n  };\n}\n\nexport type SqliteDatabase = BetterSqlite3.Database;\n\nexport function createSqliteDatabase(file: string): SqliteDatabase {\n  ensureDirExists(file);\n  const database = new BetterSqlite3(file);\n  improveSqliteErrors(database);\n  database.pragma(\"journal_mode = WAL\");\n  return database;\n}\n","import path from \"node:path\";\n\nimport type { LevelWithSilent } from \"pino\";\n\nimport type { CliOptions } from \"@/bin/ponder.js\";\n\nexport type Options = {\n  configFile: string;\n  schemaFile: string;\n  rootDir: string;\n  srcDir: string;\n  generatedDir: string;\n  ponderDir: string;\n  logDir: string;\n\n  port: number;\n  hostname?: string;\n  maxHealthcheckDuration: number;\n\n  telemetryUrl: string;\n  telemetryDisabled: boolean;\n  telemetryIsExampleProject: boolean;\n\n  logLevel: LevelWithSilent;\n  uiEnabled: boolean;\n};\n\nexport const buildOptions = ({\n  cliOptions,\n}: {\n  cliOptions: CliOptions;\n}): Options => {\n  let rootDir: string;\n  if (cliOptions.root !== undefined) {\n    rootDir = path.resolve(cliOptions.root);\n  } else {\n    rootDir = path.resolve(\".\");\n  }\n\n  let logLevel: LevelWithSilent;\n  if (cliOptions.trace) {\n    logLevel = \"trace\";\n  } else if (cliOptions.v !== undefined) {\n    if (Array.isArray(cliOptions.v)) {\n      logLevel = \"trace\";\n    } else {\n      logLevel = \"debug\";\n    }\n  } else if (\n    process.env.PONDER_LOG_LEVEL !== undefined &&\n    [\"silent\", \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"].includes(\n      process.env.PONDER_LOG_LEVEL,\n    )\n  ) {\n    logLevel = process.env.PONDER_LOG_LEVEL as LevelWithSilent;\n  } else {\n    logLevel = \"info\";\n  }\n\n  let port: number;\n  if (cliOptions.port !== undefined) {\n    port = Number(cliOptions.port);\n  } else if (process.env.PORT !== undefined) {\n    port = Number(process.env.PORT);\n  } else {\n    port = 42069;\n  }\n\n  const hostname = cliOptions.hostname;\n\n  let maxHealthcheckDuration: number;\n  if (process.env.RAILWAY_HEALTHCHECK_TIMEOUT_SEC) {\n    const railwayTimeout = Number(process.env.RAILWAY_HEALTHCHECK_TIMEOUT_SEC);\n    maxHealthcheckDuration = Math.max(railwayTimeout - 5, 0);\n  } else {\n    maxHealthcheckDuration = 240;\n  }\n\n  return {\n    rootDir,\n    configFile: path.join(rootDir, cliOptions.config),\n    schemaFile: path.join(rootDir, \"ponder.schema.ts\"),\n    srcDir: path.join(rootDir, \"src\"),\n    generatedDir: path.join(rootDir, \"generated\"),\n    ponderDir: path.join(rootDir, \".ponder\"),\n    logDir: path.join(rootDir, \".ponder\", \"logs\"),\n\n    port,\n    hostname,\n    maxHealthcheckDuration,\n\n    telemetryUrl: \"https://ponder.sh/api/telemetry\",\n    telemetryDisabled: Boolean(process.env.PONDER_TELEMETRY_DISABLED),\n    telemetryIsExampleProject: Boolean(\n      process.env.PONDER_TELEMETRY_IS_EXAMPLE_PROJECT,\n    ),\n\n    logLevel,\n    uiEnabled: true,\n  };\n};\n","import type { Common } from \"@/Ponder.js\";\nimport type { Schema } from \"@/schema/types.js\";\nimport { isEnumColumn, isManyColumn, isOneColumn } from \"@/schema/utils.js\";\nimport { type Checkpoint, encodeCheckpoint } from \"@/utils/checkpoint.js\";\nimport { Kysely, PostgresDialect, WithSchemaPlugin, sql } from \"kysely\";\nimport type { Pool } from \"pg\";\nimport type { IndexingStore, OrderByInput, Row, WhereInput } from \"../store.js\";\nimport {\n  buildCursorConditions,\n  decodeCursor,\n  encodeCursor,\n} from \"../utils/cursor.js\";\nimport { decodeRow, encodeRow, encodeValue } from \"../utils/encoding.js\";\nimport { buildWhereConditions } from \"../utils/filter.js\";\nimport { buildOrderByConditions } from \"../utils/sort.js\";\n\nconst MAX_BATCH_SIZE = 1_000 as const;\n\nconst DEFAULT_LIMIT = 50 as const;\nconst MAX_LIMIT = 1_000 as const;\n\nconst scalarToSqlType = {\n  boolean: \"integer\",\n  int: \"integer\",\n  float: \"text\",\n  string: \"text\",\n  bigint: \"numeric(78, 0)\",\n  hex: \"bytea\",\n} as const;\n\nexport class PostgresIndexingStore implements IndexingStore {\n  kind = \"postgres\" as const;\n  private common: Common;\n\n  db: Kysely<any>;\n  schema?: Schema;\n\n  private databaseSchemaName: string;\n\n  constructor({\n    common,\n    pool,\n    usePublic = false,\n  }: { common: Common; pool: Pool; usePublic?: boolean }) {\n    this.databaseSchemaName = usePublic\n      ? \"public\"\n      : `ponder`;\n    this.common = common;\n\n    this.common.logger.debug({\n      msg: `Using schema '${this.databaseSchemaName}'`,\n      service: \"indexing\",\n    });\n\n    this.db = new Kysely({\n      dialect: new PostgresDialect({ pool }),\n      log(event) {\n        if (event.level === \"query\")\n          common.metrics.ponder_postgres_query_count?.inc({ kind: \"indexing\" });\n      },\n    }).withPlugin(new WithSchemaPlugin(this.databaseSchemaName));\n  }\n\n  async teardown() {\n    if (this.databaseSchemaName === \"public\") return;\n    return this.wrap({ method: \"teardown\" }, async () => {\n      await this.db.schema\n        .dropSchema(this.databaseSchemaName)\n        .ifExists()\n        .cascade()\n        .execute();\n    });\n  }\n\n  kill = async () => {\n    return this.wrap({ method: \"kill\" }, async () => {\n      try {\n        await this.db.destroy();\n      } catch (e) {\n        const error = e as Error;\n        if (error.message !== \"Called end on pool more than once\") {\n          throw error;\n        }\n      }\n    });\n  };\n\n  /**\n   * Resets the database by dropping existing tables and creating new tables.\n   * If no new schema is provided, the existing schema is used.\n   *\n   * @param options.schema New schema to be used.\n   */\n  reload = async ({ schema }: { schema?: Schema } = {}) => {\n    return this.wrap({ method: \"reload\" }, async () => {\n      // If there is no existing schema and no new schema was provided, do nothing.\n      if (!this.schema && !schema) return;\n\n      // Set the new schema.\n      if (schema) this.schema = schema;\n\n      await this.db.transaction().execute(async (tx) => {\n        await tx.schema\n          .createSchema(this.databaseSchemaName)\n          .ifNotExists()\n          .execute();\n\n        // Create tables for new schema.\n        await Promise.all(\n          Object.entries(this.schema!.tables).map(\n            async ([tableName, columns]) => {\n              const table = `${tableName}_versioned`;\n\n              // Drop existing table with the same name if it exists.\n              // Note that \"cascade\" here will drop the views in the public schema\n              // if the current schema has been published.\n              await tx.schema.dropTable(table).ifExists().cascade().execute();\n\n              let tableBuilder = tx.schema.createTable(table);\n\n              Object.entries(columns).forEach(([columnName, column]) => {\n                if (isOneColumn(column)) return;\n                if (isManyColumn(column)) return;\n                if (isEnumColumn(column)) {\n                  // Handle enum types\n                  tableBuilder = tableBuilder.addColumn(\n                    columnName,\n                    \"text\",\n                    (col) => {\n                      if (!column.optional) col = col.notNull();\n                      if (!column.list) {\n                        col = col.check(\n                          sql`${sql.ref(columnName)} in (${sql.join(\n                            schema!.enums[column.type].map((v) => sql.lit(v)),\n                          )})`,\n                        );\n                      }\n                      return col;\n                    },\n                  );\n                } else if (column.list) {\n                  tableBuilder = tableBuilder.addColumn(\n                    columnName,\n                    \"text\",\n                    (col) => {\n                      if (!column.optional) col = col.notNull();\n                      return col;\n                    },\n                  );\n                } else {\n                  // Non-list base column\n                  tableBuilder = tableBuilder.addColumn(\n                    columnName,\n                    scalarToSqlType[column.type],\n                    (col) => {\n                      if (!column.optional) col = col.notNull();\n                      return col;\n                    },\n                  );\n                }\n              });\n\n              tableBuilder = tableBuilder.addColumn(\n                \"effectiveFromCheckpoint\",\n                \"varchar(58)\",\n                (col) => col.notNull(),\n              );\n              tableBuilder = tableBuilder.addColumn(\n                \"effectiveToCheckpoint\",\n                \"varchar(58)\",\n                (col) => col.notNull(),\n              );\n              tableBuilder = tableBuilder.addPrimaryKeyConstraint(\n                `${table}_effectiveToCheckpoint_unique`,\n                [\"id\", \"effectiveToCheckpoint\"] as never[],\n              );\n\n              await tableBuilder.execute();\n            },\n          ),\n        );\n      });\n    });\n  };\n\n  publish = async () => {\n    return this.wrap({ method: \"publish\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        // Create views in the public schema pointing at tables in the private schema.\n        await Promise.all(\n          Object.entries(this.schema!.tables).map(\n            async ([tableName, columns]) => {\n              await tx.schema\n                .withSchema(\"public\")\n                .dropView(`${tableName}_versioned`)\n                .ifExists()\n                .execute();\n              await tx.schema\n                .withSchema(\"public\")\n                .createView(`${tableName}_versioned`)\n                .as(\n                  tx\n                    .withSchema(this.databaseSchemaName)\n                    .selectFrom(`${tableName}_versioned`)\n                    .selectAll(),\n                )\n                .execute();\n\n              const columnNames = Object.entries(columns)\n                .filter(([, c]) => !isOneColumn(c) && !isManyColumn(c))\n                .map(([name]) => name);\n              await tx.schema\n                .withSchema(\"public\")\n                .dropView(tableName)\n                .ifExists()\n                .execute();\n              await tx.schema\n                .withSchema(\"public\")\n                .createView(tableName)\n                .as(\n                  tx\n                    .withSchema(this.databaseSchemaName)\n                    .selectFrom(`${tableName}_versioned`)\n                    .select(columnNames)\n                    .where(\"effectiveToCheckpoint\", \"=\", \"latest\"),\n                )\n                .execute();\n            },\n          ),\n        );\n      });\n    });\n  };\n\n  /**\n   * Revert any changes that occurred during or after the specified checkpoint.\n   */\n  revert = async ({ checkpoint }: { checkpoint: Checkpoint }) => {\n    return this.wrap({ method: \"revert\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await Promise.all(\n          Object.keys(this.schema?.tables ?? {}).map(async (tableName) => {\n            const table = `${tableName}_versioned`;\n            const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n            // Delete any versions that are newer than the safe checkpoint.\n            await tx\n              .deleteFrom(table)\n              .where(\"effectiveFromCheckpoint\", \">=\", encodedCheckpoint)\n              .execute();\n\n            // Now, any versions with effectiveToCheckpoint greater than or equal\n            // to the safe checkpoint are the new latest version.\n            await tx\n              .updateTable(table)\n              .where(\"effectiveToCheckpoint\", \">=\", encodedCheckpoint)\n              .set({ effectiveToCheckpoint: \"latest\" })\n              .execute();\n          }),\n        );\n      });\n    });\n  };\n\n  findUnique = async ({\n    tableName,\n    checkpoint = \"latest\",\n    id,\n  }: {\n    tableName: string;\n    checkpoint?: Checkpoint | \"latest\";\n    id: string | number | bigint;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"findUnique\", tableName }, async () => {\n      const formattedId = encodeValue(id, table.id, \"postgres\");\n\n      let query = this.db\n        .selectFrom(versionedTableName)\n        .selectAll()\n        .where(\"id\", \"=\", formattedId);\n\n      if (checkpoint === \"latest\") {\n        query = query.where(\"effectiveToCheckpoint\", \"=\", \"latest\");\n      } else {\n        const encodedCheckpoint = encodeCheckpoint(checkpoint);\n        query = query\n          .where(\"effectiveFromCheckpoint\", \"<=\", encodedCheckpoint)\n          .where(({ eb, or }) =>\n            or([\n              eb(\"effectiveToCheckpoint\", \">\", encodedCheckpoint),\n              eb(\"effectiveToCheckpoint\", \"=\", \"latest\"),\n            ]),\n          );\n      }\n\n      const row = await query.executeTakeFirst();\n      if (row === undefined) return null;\n\n      return decodeRow(row, table, \"postgres\");\n    });\n  };\n\n  findMany = async ({\n    tableName,\n    checkpoint = \"latest\",\n    where,\n    orderBy,\n    before = null,\n    after = null,\n    limit = DEFAULT_LIMIT,\n  }: {\n    tableName: string;\n    checkpoint?: Checkpoint | \"latest\";\n    where?: WhereInput<any>;\n    orderBy?: OrderByInput<any>;\n    before?: string | null;\n    after?: string | null;\n    limit?: number;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"findMany\", tableName }, async () => {\n      let query = this.db.selectFrom(versionedTableName).selectAll();\n\n      if (checkpoint === \"latest\") {\n        query = query.where(\"effectiveToCheckpoint\", \"=\", \"latest\");\n      } else {\n        const encodedCheckpoint = encodeCheckpoint(checkpoint);\n        query = query\n          .where(\"effectiveFromCheckpoint\", \"<=\", encodedCheckpoint)\n          .where(({ eb, or }) =>\n            or([\n              eb(\"effectiveToCheckpoint\", \">\", encodedCheckpoint),\n              eb(\"effectiveToCheckpoint\", \"=\", \"latest\"),\n            ]),\n          );\n      }\n\n      const whereConditions = buildWhereConditions({\n        where,\n        table,\n        encoding: \"postgres\",\n      });\n      for (const [columnName, comparator, value] of whereConditions) {\n        query = query.where(columnName, comparator, value);\n      }\n\n      const orderByConditions = buildOrderByConditions({ orderBy, table });\n      for (const [column, direction] of orderByConditions) {\n        query = query.orderBy(\n          column,\n          direction === \"asc\" || direction === undefined\n            ? sql`asc nulls first`\n            : sql`desc nulls last`,\n        );\n      }\n      const orderDirection = orderByConditions[0][1];\n\n      if (limit > MAX_LIMIT) {\n        throw new Error(\n          `Invalid limit. Got ${limit}, expected <=${MAX_LIMIT}.`,\n        );\n      }\n\n      let startCursor = null;\n      let endCursor = null;\n      let hasPreviousPage = false;\n      let hasNextPage = false;\n\n      // Neither cursors are specified, apply the order conditions and execute.\n      if (after === null && before === null) {\n        query = query.limit(limit + 1);\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, \"sqlite\"));\n\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n\n      if (after !== null) {\n        // User specified an 'after' cursor.\n        const rawCursorValues = decodeCursor(after, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue(value, table[columnName], \"postgres\"),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"after\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, \"postgres\"));\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n          };\n        }\n\n        // If the cursor of the first returned record equals the `after` cursor,\n        // `hasPreviousPage` is true. Remove that record.\n        if (encodeCursor(records[0], orderByConditions) === after) {\n          records.shift();\n          hasPreviousPage = true;\n        } else {\n          // Otherwise, remove the last record.\n          records.pop();\n        }\n\n        // Now if the length of the records is still equal to limit + 1,\n        // there is a next page.\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      } else {\n        // User specified a 'before' cursor.\n        const rawCursorValues = decodeCursor(before!, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue(value, table[columnName], \"postgres\"),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"before\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, \"postgres\"));\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n          };\n        }\n\n        // If the cursor of the last returned record equals the `before` cursor,\n        // `hasNextPage` is true. Remove that record.\n        if (\n          encodeCursor(records[records.length - 1], orderByConditions) ===\n          before\n        ) {\n          records.pop();\n          hasNextPage = true;\n        } else {\n          // Otherwise, remove the first record.\n          records.shift();\n        }\n\n        // Now if the length of the records is equal to limit + 1, we know\n        // there is a previous page.\n        if (records.length === limit + 1) {\n          records.shift();\n          hasPreviousPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n    });\n  };\n\n  create = async ({\n    tableName,\n    checkpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n    data?: Omit<Row, \"id\">;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"create\", tableName }, async () => {\n      const createRow = encodeRow({ id, ...data }, table, \"postgres\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const row = await this.db\n        .insertInto(versionedTableName)\n        .values({\n          ...createRow,\n          effectiveFromCheckpoint: encodedCheckpoint,\n          effectiveToCheckpoint: \"latest\",\n        })\n        .returningAll()\n        .executeTakeFirstOrThrow();\n\n      return decodeRow(row, table, \"postgres\");\n    });\n  };\n\n  createMany = async ({\n    tableName,\n    checkpoint,\n    data,\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    data: Row[];\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"createMany\", tableName }, async () => {\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n      const createRows = data.map((d) => ({\n        ...encodeRow({ ...d }, table, \"postgres\"),\n        effectiveFromCheckpoint: encodedCheckpoint,\n        effectiveToCheckpoint: \"latest\",\n      }));\n\n      const chunkedRows = [];\n      for (let i = 0, len = createRows.length; i < len; i += MAX_BATCH_SIZE)\n        chunkedRows.push(createRows.slice(i, i + MAX_BATCH_SIZE));\n\n      const rows = await Promise.all(\n        chunkedRows.map((c) =>\n          this.db\n            .insertInto(versionedTableName)\n            .values(c)\n            .returningAll()\n            .execute(),\n        ),\n      );\n\n      return rows.flat().map((row) => decodeRow(row, table, \"postgres\"));\n    });\n  };\n\n  update = async ({\n    tableName,\n    checkpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n    data?:\n      | Partial<Omit<Row, \"id\">>\n      | ((args: { current: Row }) => Partial<Omit<Row, \"id\">>);\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"update\", tableName }, async () => {\n      const formattedId = encodeValue(id, table.id, \"postgres\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const row = await this.db.transaction().execute(async (tx) => {\n        // Find the latest version of this instance.\n        const latestRow = await tx\n          .selectFrom(versionedTableName)\n          .selectAll()\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .executeTakeFirstOrThrow();\n\n        // If the user passed an update function, call it with the current instance.\n        let updateRow: ReturnType<typeof encodeRow>;\n        if (typeof data === \"function\") {\n          const current = decodeRow(latestRow, table, \"postgres\");\n          const updateObject = data({ current });\n          updateRow = encodeRow({ id, ...updateObject }, table, \"postgres\");\n        } else {\n          updateRow = encodeRow({ id, ...data }, table, \"postgres\");\n        }\n\n        // If the update would be applied to a record other than the latest\n        // record, throw an error.\n        if (latestRow.effectiveFromCheckpoint > encodedCheckpoint) {\n          throw new Error(\"Cannot update a record in the past\");\n        }\n\n        // If the latest version has the same effectiveFromCheckpoint as the update,\n        // this update is occurring within the same indexing function. Update in place.\n        if (latestRow.effectiveFromCheckpoint === encodedCheckpoint) {\n          return await tx\n            .updateTable(versionedTableName)\n            .set(updateRow)\n            .where(\"id\", \"=\", formattedId)\n            .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n            .returningAll()\n            .executeTakeFirstOrThrow();\n        }\n\n        // If the latest version has an earlier effectiveFromCheckpoint than the update,\n        // we need to update the latest version AND insert a new version.\n        await tx\n          .updateTable(versionedTableName)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .set({ effectiveToCheckpoint: encodedCheckpoint })\n          .execute();\n        const row = await tx\n          .insertInto(versionedTableName)\n          .values({\n            ...latestRow,\n            ...updateRow,\n            effectiveFromCheckpoint: encodedCheckpoint,\n            effectiveToCheckpoint: \"latest\",\n          })\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        return row;\n      });\n\n      const result = decodeRow(row, table, \"postgres\");\n\n      return result;\n    });\n  };\n\n  updateMany = async ({\n    tableName,\n    checkpoint,\n    where,\n    data = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    where: WhereInput<any>;\n    data?:\n      | Partial<Omit<Row, \"id\">>\n      | ((args: { current: Row }) => Partial<Omit<Row, \"id\">>);\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"updateMany\", tableName }, async () => {\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const rows = await this.db.transaction().execute(async (tx) => {\n        // Get all IDs that match the filter.\n        let query = tx\n          .selectFrom(versionedTableName)\n          .selectAll()\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\");\n\n        const whereConditions = buildWhereConditions({\n          where,\n          table,\n          encoding: \"postgres\",\n        });\n        for (const [columnName, comparator, value] of whereConditions) {\n          query = query.where(columnName, comparator, value);\n        }\n\n        const latestRows = await query.execute();\n\n        // TODO: This is probably incredibly slow. Ideally, we'd do most of this in the database.\n        return await Promise.all(\n          latestRows.map(async (latestRow) => {\n            const formattedId = latestRow.id;\n\n            // If the user passed an update function, call it with the current instance.\n            let updateRow: ReturnType<typeof encodeRow>;\n            if (typeof data === \"function\") {\n              const current = decodeRow(latestRow, table, \"postgres\");\n              const updateObject = data({ current });\n              updateRow = encodeRow(updateObject, table, \"postgres\");\n            } else {\n              updateRow = encodeRow(data, table, \"postgres\");\n            }\n\n            // If the update would be applied to a record other than the latest\n            // record, throw an error.\n            if (latestRow.effectiveFromCheckpoint > encodedCheckpoint) {\n              throw new Error(\"Cannot update a record in the past\");\n            }\n\n            // If the latest version has the same effectiveFrom timestamp as the update,\n            // this update is occurring within the same block/second. Update in place.\n            if (latestRow.effectiveFromCheckpoint === encodedCheckpoint) {\n              return await tx\n                .updateTable(versionedTableName)\n                .set(updateRow)\n                .where(\"id\", \"=\", formattedId)\n                .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n                .returningAll()\n                .executeTakeFirstOrThrow();\n            }\n\n            // If the latest version has an earlier effectiveFromCheckpoint than the update,\n            // we need to update the latest version AND insert a new version.\n            await tx\n              .updateTable(versionedTableName)\n              .where(\"id\", \"=\", formattedId)\n              .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n              .set({ effectiveToCheckpoint: encodedCheckpoint })\n              .execute();\n            const row = await tx\n              .insertInto(versionedTableName)\n              .values({\n                ...latestRow,\n                ...updateRow,\n                effectiveFromCheckpoint: encodedCheckpoint,\n                effectiveToCheckpoint: \"latest\",\n              })\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            return row;\n          }),\n        );\n      });\n\n      return rows.map((row) => decodeRow(row, table, \"postgres\"));\n    });\n  };\n\n  upsert = async ({\n    tableName,\n    checkpoint,\n    id,\n    create = {},\n    update = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n    create?: Omit<Row, \"id\">;\n    update?:\n      | Partial<Omit<Row, \"id\">>\n      | ((args: { current: Row }) => Partial<Omit<Row, \"id\">>);\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"upsert\", tableName }, async () => {\n      const formattedId = encodeValue(id, table.id, \"postgres\");\n      const createRow = encodeRow({ id, ...create }, table, \"postgres\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const row = await this.db.transaction().execute(async (tx) => {\n        // Find the latest version of this instance.\n        const latestRow = await tx\n          .selectFrom(versionedTableName)\n          .selectAll()\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .executeTakeFirst();\n\n        // If there is no latest version, insert a new version using the create data.\n        if (latestRow === undefined) {\n          return await tx\n            .insertInto(versionedTableName)\n            .values({\n              ...createRow,\n              effectiveFromCheckpoint: encodedCheckpoint,\n              effectiveToCheckpoint: \"latest\",\n            })\n            .returningAll()\n            .executeTakeFirstOrThrow();\n        }\n\n        // If the user passed an update function, call it with the current instance.\n        let updateRow: ReturnType<typeof encodeRow>;\n        if (typeof update === \"function\") {\n          const current = decodeRow(latestRow, table, \"postgres\");\n          const updateObject = update({ current });\n          updateRow = encodeRow({ id, ...updateObject }, table, \"postgres\");\n        } else {\n          updateRow = encodeRow({ id, ...update }, table, \"postgres\");\n        }\n\n        // If the update would be applied to a record other than the latest\n        // record, throw an error.\n        if (latestRow.effectiveFromCheckpoint > encodedCheckpoint) {\n          throw new Error(\"Cannot update a record in the past\");\n        }\n\n        // If the latest version has the same effectiveFromCheckpoint as the update,\n        // this update is occurring within the same indexing function. Update in place.\n        if (latestRow.effectiveFromCheckpoint === encodedCheckpoint) {\n          return await tx\n            .updateTable(versionedTableName)\n            .set(updateRow)\n            .where(\"id\", \"=\", formattedId)\n            .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n            .returningAll()\n            .executeTakeFirstOrThrow();\n        }\n\n        // If the latest version has an earlier effectiveFromCheckpoint than the update,\n        // we need to update the latest version AND insert a new version.\n        await tx\n          .updateTable(versionedTableName)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .set({ effectiveToCheckpoint: encodedCheckpoint })\n          .execute();\n        const row = await tx\n          .insertInto(versionedTableName)\n          .values({\n            ...latestRow,\n            ...updateRow,\n            effectiveFromCheckpoint: encodedCheckpoint,\n            effectiveToCheckpoint: \"latest\",\n          })\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        return row;\n      });\n\n      return decodeRow(row, table, \"postgres\");\n    });\n  };\n\n  delete = async ({\n    tableName,\n    checkpoint,\n    id,\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"delete\", tableName }, async () => {\n      const formattedId = encodeValue(id, table.id, \"postgres\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n      const isDeleted = await this.db.transaction().execute(async (tx) => {\n        // If the latest version has effectiveFromCheckpoint equal to current checkpoint,\n        // this row was created within the same indexing function, and we can delete it.\n        let deletedRow = await tx\n          .deleteFrom(versionedTableName)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .returning([\"id\"])\n          .executeTakeFirst();\n\n        // If we did not take the shortcut above, update the latest record\n        // setting effectiveToCheckpoint to the current checkpoint.\n        if (!deletedRow) {\n          deletedRow = await tx\n            .updateTable(versionedTableName)\n            .set({ effectiveToCheckpoint: encodedCheckpoint })\n            .where(\"id\", \"=\", formattedId)\n            .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n            .returning([\"id\"])\n            .executeTakeFirst();\n        }\n\n        return !!deletedRow;\n      });\n\n      return isDeleted;\n    });\n  };\n\n  private wrap = async <T>(\n    options: { method: string; tableName?: string },\n    fn: () => Promise<T>,\n  ) => {\n    const start = performance.now();\n    const result = await fn();\n    this.common.metrics.ponder_indexing_store_method_duration.observe(\n      { method: options.method, table: options.tableName },\n      performance.now() - start,\n    );\n    return result;\n  };\n}\n","/**\n * Serialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to stringify\n * @returns the stringified output\n */\nexport function serialize(value: any) {\n  return JSON.stringify(value, (_, v) =>\n    typeof v === \"bigint\" ? { __type: \"bigint\", value: v.toString() } : v,\n  );\n}\n\n/**\n * Deserialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to parse\n * @returns the output object\n */\nexport function deserialize<type>(value: string): type {\n  return JSON.parse(value, (_, value_) =>\n    value_?.__type === \"bigint\" ? BigInt(value_.value) : value_,\n  );\n}\n","import { deserialize, serialize } from \"@/utils/serialize.js\";\nimport type { ExpressionBuilder } from \"kysely\";\nimport type { Row } from \"../store.js\";\nimport type { OrderByConditions } from \"./sort.js\";\n\nexport function encodeCursor(\n  record: Row,\n  orderByConditions: OrderByConditions,\n) {\n  const cursorValues = orderByConditions.map(([columnName]) => [\n    columnName,\n    record[columnName],\n  ]);\n\n  return Buffer.from(serialize(cursorValues)).toString(\"base64\");\n}\n\nexport function decodeCursor(\n  cursor: string,\n  orderByConditions: OrderByConditions,\n) {\n  const cursorValues = deserialize<[string, any][]>(\n    Buffer.from(cursor, \"base64\").toString(),\n  );\n\n  // Validate cursor values against order by conditions.\n  if (cursorValues.length !== orderByConditions.length) {\n    throw new Error(\n      `Invalid cursor. Got ${cursorValues.length}, ${orderByConditions.length} conditions`,\n    );\n  }\n\n  for (const [index, [columnName]] of orderByConditions.entries()) {\n    if (cursorValues[index][0] !== columnName) {\n      throw new Error(\n        `Invalid cursor. Got column '${cursorValues[index][0]}' at index ${index}, expected '${columnName}'.`,\n      );\n    }\n  }\n\n  return cursorValues;\n}\n\nexport function buildCursorConditions(\n  cursorValues: [string, any][],\n  kind: \"after\" | \"before\",\n  direction: \"asc\" | \"desc\",\n  eb: ExpressionBuilder<any, any>,\n) {\n  const comparator =\n    kind === \"after\"\n      ? direction === \"asc\"\n        ? \">\" // after, asc\n        : \"<\" // after, desc\n      : direction === \"asc\"\n        ? \"<\" // before, asc\n        : \">\"; // before, desc\n  const comparatorOrEquals = `${comparator}=` as const;\n\n  if (cursorValues.length === 1) {\n    const [columnName, value] = cursorValues[0];\n    return eb.eb(columnName, comparatorOrEquals, value);\n  } else if (cursorValues.length === 2) {\n    const [columnName1, value1] = cursorValues[0];\n    const [columnName2, value2] = cursorValues[1];\n\n    return eb.or([\n      eb.eb(columnName1, comparator, value1),\n      eb.and([\n        eb.eb(columnName1, \"=\", value1),\n        eb.eb(columnName2, comparatorOrEquals, value2),\n      ]),\n    ]);\n  } else {\n    throw new Error(\n      `Invalid cursor. Got ${cursorValues.length} value pairs, expected 1 or 2.`,\n    );\n  }\n}\n","import type { Hex } from \"viem\";\n\nexport const EVM_MAX_UINT =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n\nexport const EVM_MIN_INT =\n  -57896044618658097711785492504343953926634992332820282019728792003956564819968n;\n\n/**\n * Converts a integer into a 33-byte Buffer (sign byte followed by 32-byte value).\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function encodeAsText(value: bigint | number | Hex) {\n  if (typeof value === \"string\" || typeof value === \"number\")\n    value = BigInt(value);\n\n  if (value > EVM_MAX_UINT)\n    throw new Error(`Value cannot be greater than EVM_MAX_UINT (${value})`);\n  if (value < EVM_MIN_INT)\n    throw new Error(`Value cannot be less than EVM_MIN_INT (${value})`);\n\n  const signChar = value >= 0n ? \"0\" : \"-\";\n\n  // If the value is negative, add the minimum integer to it.\n  if (value < 0n) value = value - EVM_MIN_INT;\n\n  const chars = value.toString(10);\n\n  // Pad the hex string with leading zeros and add the sign byte.\n  return signChar + chars.padStart(78, \"0\");\n}\n\n/**\n * Converts an encoded 33-byte Buffer (sign byte followed by 32-byte value) into a BigInt.\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function decodeToBigInt(text: string) {\n  if (typeof text === \"bigint\") return text;\n\n  const signChar = text.at(0);\n  let valueChars = text.substring(1).replace(/^0+/, \"\");\n  // If the value is 0, valueChars will be an empty string.\n  if (valueChars.length === 0) valueChars = \"0\";\n  let value = BigInt(valueChars);\n\n  // If the sign byte is negative, invert the value\n\n  if (signChar === \"-\") value = value + EVM_MIN_INT;\n\n  return value;\n}\n","import type {\n  EnumColumn,\n  NonReferenceColumn,\n  ReferenceColumn,\n  Scalar,\n  Schema,\n} from \"@/schema/types.js\";\nimport { isBaseColumn, isEnumColumn } from \"@/schema/utils.js\";\nimport { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport { bytesToHex, hexToBytes, isHex } from \"viem\";\nimport type { Row } from \"../store.js\";\n\nconst scalarToTsType = {\n  int: \"number\",\n  float: \"number\",\n  bigint: \"bigint\",\n  boolean: \"boolean\",\n  string: \"string\",\n  hex: \"`0x${string}`\",\n} as const satisfies { [key in Scalar]: string };\n\n/**\n * Convert a user-land row into a database-ready object.\n */\nexport function encodeRow(\n  data: Partial<Row>,\n  table: Schema[\"tables\"][keyof Schema[\"tables\"]],\n  encoding: \"sqlite\" | \"postgres\",\n) {\n  const instance: { [key: string]: string | number | null | bigint | Buffer } =\n    {};\n\n  for (const [columnName, value] of Object.entries(data)) {\n    const column = table[columnName];\n    if (!column) {\n      throw Error(\n        `Invalid record: Column does not exist. Got ${columnName}, expected one of [${Object.keys(\n          table,\n        )\n          .filter((key) => isBaseColumn(table[key]) || isEnumColumn(table[key]))\n          .join(\", \")}]`,\n      );\n    }\n\n    instance[columnName] = encodeValue(value, column, encoding);\n  }\n\n  return instance;\n}\n\n/**\n * Convert a user-land value into a database-ready value.\n */\nexport function encodeValue(\n  value: unknown,\n  column: Schema[\"tables\"][keyof Schema[\"tables\"]][string],\n  encoding: \"sqlite\" | \"postgres\",\n): string | number | null | bigint | Buffer {\n  if (isEnumColumn(column)) {\n    if (column.optional && (value === undefined || value === null)) {\n      return null;\n    }\n\n    if (column.list) {\n      if (!Array.isArray(value)) {\n        throw Error(\n          `Unable to encode ${value} as a list. Got type '${typeof value}' but expected type 'string[]'.`,\n        );\n      }\n\n      return JSON.stringify(value);\n    } else if (typeof value !== \"string\") {\n      throw Error(\n        `Unable to encode ${value} as an enum. Got type '${typeof value}' but expected type 'string'.`,\n      );\n    }\n    return value;\n  } else if (isBaseColumn(column)) {\n    if (column.optional && (value === undefined || value === null)) {\n      return null;\n    }\n\n    if (column.list) {\n      // Note: We are not checking the types of the list elements.\n      if (!Array.isArray(value)) {\n        throw Error(\n          `Unable to encode ${value} as a list. Got type '${typeof value}' but expected type '${\n            scalarToTsType[column.type]\n          }[]'.`,\n        );\n      }\n\n      if (column.type === \"bigint\") {\n        return JSON.stringify(value.map(String));\n      } else {\n        return JSON.stringify(value);\n      }\n    }\n\n    if (column.type === \"string\") {\n      if (typeof value !== \"string\") {\n        throw Error(\n          `Unable to encode ${value} as a string. Got type '${typeof value}' but expected type 'string'.`,\n        );\n      }\n      return value;\n    } else if (column.type === \"hex\") {\n      if (typeof value !== \"string\" || !isHex(value)) {\n        throw Error(\n          `Unable to encode ${value} as a hex. Got type '${typeof value}' but expected type '\\`0x\\${string}\\`'.`,\n        );\n      }\n      return Buffer.from(hexToBytes(value));\n    } else if (column.type === \"int\") {\n      if (typeof value !== \"number\") {\n        throw Error(\n          `Unable to encode ${value} as an int. Got type '${typeof value}' but expected type 'number'.`,\n        );\n      }\n      return value;\n    } else if (column.type === \"float\") {\n      if (typeof value !== \"number\") {\n        throw Error(\n          `Unable to encode ${value} as a float. Got type '${typeof value}' but expected type 'number'.`,\n        );\n      }\n      return value;\n    } else if (column.type === \"bigint\") {\n      if (typeof value !== \"bigint\") {\n        throw Error(\n          `Unable to encode ${value} as a bigint. Got type '${typeof value}' but expected type 'bigint'.`,\n        );\n      }\n      return encoding === \"sqlite\" ? encodeAsText(value) : value;\n    } else if (column.type === \"boolean\") {\n      if (typeof value !== \"boolean\") {\n        throw Error(\n          `Unable to encode ${value} as a boolean. Got type '${typeof value}' but expected type 'boolean'.`,\n        );\n      }\n      return value ? 1 : 0;\n    }\n\n    // Note: it should be impossible to get to this line\n    throw Error(\n      `Unable to encode ${value} as type ${column.type}. Please report this issue (https://github.com/ponder-sh/ponder/issues/new)`,\n    );\n  }\n\n  // Column is either \"many\" or \"one\"\n  throw Error(\n    `Unable to encode ${value} into a \"${\n      column._type === \"m\" ? \"many\" : \"one\"\n    }\" column. \"${\n      column._type === \"m\" ? \"many\" : \"one\"\n    }\" columns are virtual and therefore should not be given a value.`,\n  );\n}\n\nexport function decodeRow(\n  data: Partial<Row>,\n  table: Schema[\"tables\"][keyof Schema[\"tables\"]],\n  encoding: \"sqlite\" | \"postgres\",\n): Row {\n  const instance: { [key: string]: string | number | null | bigint | Buffer } =\n    {};\n\n  for (const [columnName, column] of Object.entries(table)) {\n    if (isBaseColumn(column) || isEnumColumn(column)) {\n      instance[columnName] = decodeValue(data[columnName], column, encoding);\n    }\n  }\n\n  return instance as Row;\n}\n\nfunction decodeValue(\n  value: unknown,\n  column: NonReferenceColumn | ReferenceColumn | EnumColumn,\n  encoding: \"sqlite\" | \"postgres\",\n) {\n  if (value === null) return null;\n  else if (column.list) {\n    return column.type === \"bigint\"\n      ? JSON.parse(value as string).map(BigInt)\n      : JSON.parse(value as string);\n  } else if (column.type === \"boolean\") {\n    return value === 1 ? true : false;\n  } else if (column.type === \"hex\") {\n    return bytesToHex(value as Buffer);\n  } else if (column.type === \"bigint\" && encoding === \"sqlite\") {\n    return decodeToBigInt(value as string);\n  } else {\n    return value;\n  }\n}\n","import type { Schema } from \"@/schema/types.js\";\nimport { isBaseColumn, isEnumColumn } from \"@/schema/utils.js\";\nimport type { ComparisonOperatorExpression } from \"kysely\";\nimport type { Table, WhereInput } from \"../store.js\";\nimport { encodeValue } from \"./encoding.js\";\n\nconst filterValidityMap = {\n  boolean: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  string: {\n    singular: [\n      \"equals\",\n      \"not\",\n      \"in\",\n      \"notIn\",\n      \"contains\",\n      \"notContains\",\n      \"startsWith\",\n      \"notStartsWith\",\n      \"endsWith\",\n      \"notEndsWith\",\n    ],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  hex: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  int: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  bigint: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n  float: {\n    singular: [\"equals\", \"not\", \"in\", \"notIn\", \"gt\", \"lt\", \"gte\", \"lte\"],\n    list: [\"equals\", \"not\", \"has\", \"notHas\"],\n  },\n};\n\nconst filterEncodingMap: {\n  [condition: string]: (\n    value: any,\n    encode: (v: any) => any,\n  ) => [comparator: string, value: any];\n} = {\n  // Universal\n  equals: (value, encode) =>\n    value === null ? [\"is\", null] : [\"=\", encode(value)],\n  not: (value, encode) =>\n    value === null ? [\"is not\", null] : [\"!=\", encode(value)],\n  // Singular\n  in: (value, encode) => [\"in\", value.map(encode)],\n  notIn: (value, encode) => [\"not in\", value.map(encode)],\n  // Plural/list\n  has: (value, encode) => [\"like\", `%${encode(value)}%`],\n  notHas: (value, encode) => [\"not like\", `%${encode(value)}%`],\n  // Numeric\n  gt: (value, encode) => [\">\", encode(value)],\n  lt: (value, encode) => [\"<\", encode(value)],\n  gte: (value, encode) => [\">=\", encode(value)],\n  lte: (value, encode) => [\"<=\", encode(value)],\n  // String\n  contains: (value, encode) => [\"like\", `%${encode(value)}%`],\n  notContains: (value, encode) => [\"not like\", `%${encode(value)}%`],\n  startsWith: (value, encode) => [\"like\", `${encode(value)}%`],\n  notStartsWith: (value, encode) => [\"not like\", `${encode(value)}%`],\n  endsWith: (value, encode) => [\"like\", `%${encode(value)}`],\n  notEndsWith: (value, encode) => [\"not like\", `%${encode(value)}`],\n} as const;\n\nexport function buildWhereConditions({\n  where,\n  table,\n  encoding,\n}: {\n  where: WhereInput<Table> | undefined;\n  table: Schema[\"tables\"][keyof Schema[\"tables\"]];\n  encoding: \"sqlite\" | \"postgres\";\n}) {\n  if (where === undefined) return [];\n\n  const conditions: [\n    columnName: string,\n    comparator: ComparisonOperatorExpression,\n    value: any,\n  ][] = [];\n\n  for (const [columnName, rhs] of Object.entries(where)) {\n    const column = table[columnName];\n\n    if (!column) {\n      throw Error(\n        `Invalid filter. Column does not exist. Got '${columnName}', expected one of [${Object.keys(\n          table,\n        )\n          .filter((key) => isBaseColumn(table[key]) || isEnumColumn(table[key]))\n          .map((c) => `'${c}'`)\n          .join(\", \")}]`,\n      );\n    }\n\n    if (column._type === \"m\" || column._type === \"o\") {\n      throw Error(\n        `Invalid filter. Cannot filter on virtual column '${columnName}'.`,\n      );\n    }\n\n    // Handle the shortcut case for `equals`, e.g. { user: \"abc\" }.\n    const conditionsForColumn =\n      Array.isArray(rhs) || typeof rhs !== \"object\" ? { equals: rhs } : rhs;\n\n    for (const [condition, value] of Object.entries(conditionsForColumn)) {\n      const filterType = column._type === \"e\" ? \"string\" : column.type;\n\n      const allowedConditions =\n        filterValidityMap[filterType]?.[column.list ? \"list\" : \"singular\"];\n      if (!allowedConditions.includes(condition)) {\n        throw new Error(\n          `Invalid filter condition for column '${columnName}'. Got '${condition}', expected one of [${allowedConditions\n            .map((c) => `'${c}'`)\n            .join(\", \")}]`,\n        );\n      }\n\n      const filterEncodingFn = filterEncodingMap[condition];\n\n      // Handle special case for list column types `has` and `notHas`.\n      // We need to use the singular encoding function for the arguments.\n      const encode =\n        column.list && (condition === \"has\" || condition === \"notHas\")\n          ? (v: any) => encodeValue(v, { ...column, list: false }, encoding)\n          : (v: any) => encodeValue(v, column, encoding);\n\n      const [comparator, encodedValue] = filterEncodingFn(value, encode);\n      conditions.push([\n        columnName,\n        comparator as ComparisonOperatorExpression,\n        encodedValue,\n      ]);\n    }\n  }\n\n  return conditions;\n}\n","import type { Schema } from \"@/schema/types.js\";\nimport { isBaseColumn, isEnumColumn } from \"@/schema/utils.js\";\nimport type { OrderByInput } from \"../store.js\";\n\nexport type OrderByConditions = [\n  columnName: string,\n  direction: \"asc\" | \"desc\",\n][];\n\nexport function buildOrderByConditions({\n  orderBy,\n  table,\n}: {\n  orderBy: OrderByInput<any> | undefined;\n  table: Schema[\"tables\"][keyof Schema[\"tables\"]];\n}): OrderByConditions {\n  if (!orderBy) {\n    return [[\"id\", \"asc\"]];\n  }\n\n  const conditions = Object.entries(orderBy);\n  if (conditions.length > 1)\n    throw new Error(\"Invalid sort. Cannot sort by multiple columns.\");\n\n  const [columnName, orderDirection] = conditions[0];\n\n  // Validate column name.\n  const column = table[columnName];\n  if (!column) {\n    throw Error(\n      `Invalid sort. Column does not exist. Got '${columnName}', expected one of [${Object.keys(\n        table,\n      )\n        .filter((key) => isBaseColumn(table[key]) || isEnumColumn(table[key]))\n        .map((c) => `'${c}'`)\n        .join(\", \")}]`,\n    );\n  }\n  if (column._type === \"m\" || column._type === \"o\") {\n    throw Error(\n      `Invalid sort. Cannot filter on virtual column '${columnName}'.`,\n    );\n  }\n\n  if (orderDirection === undefined || ![\"asc\", \"desc\"].includes(orderDirection))\n    throw new Error(\n      `Invalid sort direction. Got '${orderDirection}', expected 'asc' or 'desc'.`,\n    );\n\n  const orderByConditions: OrderByConditions = [[columnName, orderDirection]];\n\n  // If the specified order by column is not the ID column, add the ID column\n  // as a secondary using the same order to enforce a consistent sort.\n  if (columnName !== \"id\") {\n    orderByConditions.push([\"id\", orderDirection]);\n  }\n\n  return orderByConditions;\n}\n","import type { Common } from \"@/Ponder.js\";\nimport type { Schema } from \"@/schema/types.js\";\nimport { isEnumColumn, isManyColumn, isOneColumn } from \"@/schema/utils.js\";\nimport { type Checkpoint, encodeCheckpoint } from \"@/utils/checkpoint.js\";\nimport type { SqliteDatabase } from \"@/utils/sqlite.js\";\nimport { Kysely, SqliteDialect, sql } from \"kysely\";\nimport type { IndexingStore, OrderByInput, Row, WhereInput } from \"../store.js\";\nimport {\n  buildCursorConditions,\n  decodeCursor,\n  encodeCursor,\n} from \"../utils/cursor.js\";\nimport { decodeRow, encodeRow, encodeValue } from \"../utils/encoding.js\";\nimport { buildWhereConditions } from \"../utils/filter.js\";\nimport { buildOrderByConditions } from \"../utils/sort.js\";\n\nconst MAX_BATCH_SIZE = 1_000 as const;\n\nconst DEFAULT_LIMIT = 50 as const;\nconst MAX_LIMIT = 1_000 as const;\n\nconst scalarToSqlType = {\n  boolean: \"integer\",\n  int: \"integer\",\n  float: \"text\",\n  string: \"text\",\n  bigint: \"varchar(79)\",\n  hex: \"blob\",\n} as const;\n\nexport class SqliteIndexingStore implements IndexingStore {\n  kind = \"sqlite\" as const;\n  private common: Common;\n\n  db: Kysely<any>;\n\n  schema?: Schema;\n\n  constructor({\n    common,\n    database,\n  }: {\n    common: Common;\n    database: SqliteDatabase;\n  }) {\n    this.common = common;\n    this.db = new Kysely({\n      dialect: new SqliteDialect({ database }),\n      log(event) {\n        if (event.level === \"query\")\n          common.metrics.ponder_sqlite_query_count?.inc({ kind: \"indexing\" });\n      },\n    });\n  }\n\n  async teardown() {\n    return this.wrap({ method: \"teardown\" }, async () => {\n      const tableNames = Object.keys(this.schema?.tables ?? {});\n      if (tableNames.length > 0) {\n        await this.db.transaction().execute(async (tx) => {\n          await Promise.all(\n            tableNames.map(async (tableName) => {\n              const table = `${tableName}_versioned`;\n              await tx.schema.dropTable(table).ifExists().execute();\n            }),\n          );\n        });\n      }\n    });\n  }\n\n  async kill() {\n    return this.wrap({ method: \"kill\" }, async () => {\n      try {\n        await this.db.destroy();\n      } catch (e) {\n        const error = e as Error;\n        if (error.message !== \"Called end on pool more than once\") {\n          throw error;\n        }\n      }\n    });\n  }\n\n  /**\n   * Resets the database by dropping existing tables and creating new tables.\n   * If no new schema is provided, the existing schema is used.\n   *\n   * @param options.schema New schema to be used.\n   */\n  reload = async ({ schema }: { schema?: Schema } = {}) => {\n    return this.wrap({ method: \"reload\" }, async () => {\n      // If there is no existing schema and no new schema was provided, do nothing.\n      if (!this.schema && !schema) return;\n\n      // Set the new schema.\n      if (schema) this.schema = schema;\n\n      await this.db.transaction().execute(async (tx) => {\n        // Create tables for new schema.\n        await Promise.all(\n          Object.entries(this.schema!.tables).map(\n            async ([tableName, columns]) => {\n              const table = `${tableName}_versioned`;\n\n              // Drop existing table with the same name if it exists.\n              await tx.schema.dropTable(table).ifExists().execute();\n\n              let tableBuilder = tx.schema.createTable(table);\n\n              Object.entries(columns).forEach(([columnName, column]) => {\n                if (isOneColumn(column)) return;\n                if (isManyColumn(column)) return;\n                if (isEnumColumn(column)) {\n                  // Handle enum types\n                  tableBuilder = tableBuilder.addColumn(\n                    columnName,\n                    \"text\",\n                    (col) => {\n                      if (!column.optional) col = col.notNull();\n                      if (!column.list) {\n                        col = col.check(\n                          sql`${sql.ref(columnName)} in (${sql.join(\n                            schema!.enums[column.type].map((v) => sql.lit(v)),\n                          )})`,\n                        );\n                      }\n                      return col;\n                    },\n                  );\n                } else if (column.list) {\n                  // Handle scalar list columns\n                  tableBuilder = tableBuilder.addColumn(\n                    columnName,\n                    \"text\",\n                    (col) => {\n                      if (!column.optional) col = col.notNull();\n                      return col;\n                    },\n                  );\n                } else {\n                  // Non-list base columns\n                  tableBuilder = tableBuilder.addColumn(\n                    columnName,\n                    scalarToSqlType[column.type],\n                    (col) => {\n                      if (!column.optional) col = col.notNull();\n                      return col;\n                    },\n                  );\n                }\n              });\n\n              tableBuilder = tableBuilder.addColumn(\n                \"effectiveFromCheckpoint\",\n                \"varchar(58)\",\n                (col) => col.notNull(),\n              );\n              tableBuilder = tableBuilder.addColumn(\n                \"effectiveToCheckpoint\",\n                \"varchar(58)\",\n                (col) => col.notNull(),\n              );\n              tableBuilder = tableBuilder.addPrimaryKeyConstraint(\n                `${table}_effectiveToCheckpoint_unique`,\n                [\"id\", \"effectiveToCheckpoint\"] as never[],\n              );\n\n              await tableBuilder.execute();\n            },\n          ),\n        );\n      });\n    });\n  };\n\n  publish = async () => {\n    return this.wrap({ method: \"publish\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        // Create views for the latest version of each table.\n        await Promise.all(\n          Object.entries(this.schema!.tables).map(\n            async ([tableName, columns]) => {\n              await tx.schema.dropView(tableName).ifExists().execute();\n\n              const columnNames = Object.entries(columns)\n                .filter(([, c]) => !isOneColumn(c) && !isManyColumn(c))\n                .map(([name]) => name);\n              await tx.schema\n                .createView(tableName)\n                .as(\n                  tx\n                    .selectFrom(`${tableName}_versioned`)\n                    .select(columnNames)\n                    .where(\"effectiveToCheckpoint\", \"=\", \"latest\"),\n                )\n                .execute();\n            },\n          ),\n        );\n      });\n    });\n  };\n\n  /**\n   * Revert any changes that occurred during or after the specified checkpoint.\n   */\n  revert = async ({ checkpoint }: { checkpoint: Checkpoint }) => {\n    return this.wrap({ method: \"revert\" }, async () => {\n      await this.db.transaction().execute(async (tx) => {\n        await Promise.all(\n          Object.keys(this.schema?.tables ?? {}).map(async (tableName) => {\n            const table = `${tableName}_versioned`;\n            const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n            // Delete any versions that are newer than or equal to the safe checkpoint.\n            await tx\n              .deleteFrom(table)\n              .where(\"effectiveFromCheckpoint\", \">=\", encodedCheckpoint)\n              .execute();\n\n            // Now, any versions with effectiveToCheckpoint greater than or equal\n            // to the safe checkpoint are the new latest version.\n            await tx\n              .updateTable(table)\n              .set({ effectiveToCheckpoint: \"latest\" })\n              .where(\"effectiveToCheckpoint\", \">=\", encodedCheckpoint)\n              .execute();\n          }),\n        );\n      });\n    });\n  };\n\n  findUnique = async ({\n    tableName,\n    checkpoint = \"latest\",\n    id,\n  }: {\n    tableName: string;\n    checkpoint?: Checkpoint | \"latest\";\n    id: string | number | bigint;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"findUnique\", tableName }, async () => {\n      const encodedId = encodeValue(id, table.id, \"sqlite\");\n\n      let query = this.db\n        .selectFrom(versionedTableName)\n        .selectAll()\n        .where(\"id\", \"=\", encodedId);\n\n      if (checkpoint === \"latest\") {\n        query = query.where(\"effectiveToCheckpoint\", \"=\", \"latest\");\n      } else {\n        const encodedCheckpoint = encodeCheckpoint(checkpoint);\n        query = query\n          .where(\"effectiveFromCheckpoint\", \"<=\", encodedCheckpoint)\n          .where(({ eb, or }) =>\n            or([\n              eb(\"effectiveToCheckpoint\", \">\", encodedCheckpoint),\n              eb(\"effectiveToCheckpoint\", \"=\", \"latest\"),\n            ]),\n          );\n      }\n\n      const row = await query.executeTakeFirst();\n      if (row === undefined) return null;\n\n      return decodeRow(row, table, \"sqlite\");\n    });\n  };\n\n  findMany = async ({\n    tableName,\n    checkpoint = \"latest\",\n    where,\n    orderBy,\n    before = null,\n    after = null,\n    limit = DEFAULT_LIMIT,\n  }: {\n    tableName: string;\n    checkpoint?: Checkpoint | \"latest\";\n    where?: WhereInput<any>;\n    orderBy?: OrderByInput<any>;\n    before?: string | null;\n    after?: string | null;\n    limit?: number;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"findMany\", tableName }, async () => {\n      let query = this.db.selectFrom(versionedTableName).selectAll();\n\n      if (checkpoint === \"latest\") {\n        query = query.where(\"effectiveToCheckpoint\", \"=\", \"latest\");\n      } else {\n        const encodedCheckpoint = encodeCheckpoint(checkpoint);\n        query = query\n          .where(\"effectiveFromCheckpoint\", \"<=\", encodedCheckpoint)\n          .where(({ eb, or }) =>\n            or([\n              eb(\"effectiveToCheckpoint\", \">\", encodedCheckpoint),\n              eb(\"effectiveToCheckpoint\", \"=\", \"latest\"),\n            ]),\n          );\n      }\n\n      const whereConditions = buildWhereConditions({\n        where,\n        table,\n        encoding: \"sqlite\",\n      });\n      for (const [columnName, comparator, value] of whereConditions) {\n        query = query.where(columnName, comparator, value);\n      }\n\n      const orderByConditions = buildOrderByConditions({ orderBy, table });\n      for (const [column, direction] of orderByConditions) {\n        query = query.orderBy(column, direction);\n      }\n      const orderDirection = orderByConditions[0][1];\n\n      if (limit > MAX_LIMIT) {\n        throw new Error(\n          `Invalid limit. Got ${limit}, expected <=${MAX_LIMIT}.`,\n        );\n      }\n\n      if (after !== null && before !== null) {\n        throw new Error(\"Cannot specify both before and after cursors.\");\n      }\n\n      let startCursor = null;\n      let endCursor = null;\n      let hasPreviousPage = false;\n      let hasNextPage = false;\n\n      // Neither cursors are specified, apply the order conditions and execute.\n      if (after === null && before === null) {\n        query = query.limit(limit + 1);\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, \"sqlite\"));\n\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n\n      if (after !== null) {\n        // User specified an 'after' cursor.\n        const rawCursorValues = decodeCursor(after, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue(value, table[columnName], \"sqlite\"),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"after\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, \"sqlite\"));\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n          };\n        }\n\n        // If the cursor of the first returned record equals the `after` cursor,\n        // `hasPreviousPage` is true. Remove that record.\n        if (encodeCursor(records[0], orderByConditions) === after) {\n          records.shift();\n          hasPreviousPage = true;\n        } else {\n          // Otherwise, remove the last record.\n          records.pop();\n        }\n\n        // Now if the length of the records is still equal to limit + 1,\n        // there is a next page.\n        if (records.length === limit + 1) {\n          records.pop();\n          hasNextPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      } else {\n        // User specified a 'before' cursor.\n        const rawCursorValues = decodeCursor(before!, orderByConditions);\n        const cursorValues = rawCursorValues.map(([columnName, value]) => [\n          columnName,\n          encodeValue(value, table[columnName], \"sqlite\"),\n        ]) satisfies [string, any][];\n        query = query\n          .where((eb) =>\n            buildCursorConditions(cursorValues, \"before\", orderDirection, eb),\n          )\n          .limit(limit + 2);\n\n        const rows = await query.execute();\n        const records = rows.map((row) => decodeRow(row, table, \"sqlite\"));\n\n        if (records.length === 0) {\n          return {\n            items: records,\n            pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n          };\n        }\n\n        // If the cursor of the last returned record equals the `before` cursor,\n        // `hasNextPage` is true. Remove that record.\n        if (\n          encodeCursor(records[records.length - 1], orderByConditions) ===\n          before\n        ) {\n          records.pop();\n          hasNextPage = true;\n        } else {\n          // Otherwise, remove the first record.\n          records.shift();\n        }\n\n        // Now if the length of the records is equal to limit + 1, we know\n        // there is a previous page.\n        if (records.length === limit + 1) {\n          records.shift();\n          hasPreviousPage = true;\n        }\n\n        // Now calculate the cursors.\n        startCursor =\n          records.length > 0\n            ? encodeCursor(records[0], orderByConditions)\n            : null;\n        endCursor =\n          records.length > 0\n            ? encodeCursor(records[records.length - 1], orderByConditions)\n            : null;\n\n        return {\n          items: records,\n          pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n        };\n      }\n    });\n  };\n\n  create = async ({\n    tableName,\n    checkpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n    data?: Omit<Row, \"id\">;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"create\", tableName }, async () => {\n      const createRow = encodeRow({ id, ...data }, table, \"sqlite\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const row = await this.db\n        .insertInto(versionedTableName)\n        .values({\n          ...createRow,\n          effectiveFromCheckpoint: encodedCheckpoint,\n          effectiveToCheckpoint: \"latest\",\n        })\n        .returningAll()\n        .executeTakeFirstOrThrow();\n\n      return decodeRow(row, this.schema!.tables[tableName], \"sqlite\");\n    });\n  };\n\n  createMany = async ({\n    tableName,\n    checkpoint,\n    data,\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    data: Row[];\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"createMany\", tableName }, async () => {\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n      const createRows = data.map((d) => ({\n        ...encodeRow({ ...d }, table, \"sqlite\"),\n        effectiveFromCheckpoint: encodedCheckpoint,\n        effectiveToCheckpoint: \"latest\",\n      }));\n\n      const chunkedRows = [];\n      for (let i = 0, len = createRows.length; i < len; i += MAX_BATCH_SIZE)\n        chunkedRows.push(createRows.slice(i, i + MAX_BATCH_SIZE));\n\n      const rows = await Promise.all(\n        chunkedRows.map((c) =>\n          this.db\n            .insertInto(versionedTableName)\n            .values(c)\n            .returningAll()\n            .execute(),\n        ),\n      );\n\n      return rows\n        .flat()\n        .map((row) => decodeRow(row, this.schema!.tables[tableName], \"sqlite\"));\n    });\n  };\n\n  update = async ({\n    tableName,\n    checkpoint,\n    id,\n    data = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n    data?:\n      | Partial<Omit<Row, \"id\">>\n      | ((args: { current: Row }) => Partial<Omit<Row, \"id\">>);\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"update\", tableName }, async () => {\n      const encodedId = encodeValue(id, table.id, \"sqlite\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const row = await this.db.transaction().execute(async (tx) => {\n        // Find the latest version of this instance.\n        const latestRow = await tx\n          .selectFrom(versionedTableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .executeTakeFirstOrThrow();\n\n        // If the user passed an update function, call it with the current instance.\n        let updateRow: ReturnType<typeof encodeRow>;\n        if (typeof data === \"function\") {\n          const current = decodeRow(latestRow, table, \"sqlite\");\n          const updateObject = data({ current });\n          updateRow = encodeRow({ id, ...updateObject }, table, \"sqlite\");\n        } else {\n          updateRow = encodeRow({ id, ...data }, table, \"sqlite\");\n        }\n\n        // If the update would be applied to a record other than the latest\n        // record, throw an error.\n        if (latestRow.effectiveFromCheckpoint > encodedCheckpoint) {\n          throw new Error(\"Cannot update a record in the past\");\n        }\n\n        // If the latest version has the same effectiveFromCheckpoint as the update,\n        // this update is occurring within the same indexing function. Update in place.\n        if (latestRow.effectiveFromCheckpoint === encodedCheckpoint) {\n          return await tx\n            .updateTable(versionedTableName)\n            .set(updateRow)\n            .where(\"id\", \"=\", encodedId)\n            .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n            .returningAll()\n            .executeTakeFirstOrThrow();\n        }\n\n        // If the latest version has an earlier effectiveFromCheckpoint than the update,\n        // we need to update the latest version AND insert a new version.\n        await tx\n          .updateTable(versionedTableName)\n          .where(\"id\", \"=\", encodedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .set({ effectiveToCheckpoint: encodedCheckpoint })\n          .execute();\n        const row = tx\n          .insertInto(versionedTableName)\n          .values({\n            ...latestRow,\n            ...updateRow,\n            effectiveFromCheckpoint: encodedCheckpoint,\n            effectiveToCheckpoint: \"latest\",\n          })\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        return row;\n      });\n\n      const result = decodeRow(row, table, \"sqlite\");\n\n      return result;\n    });\n  };\n\n  updateMany = async ({\n    tableName,\n    checkpoint,\n    where,\n    data = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    where: WhereInput<any>;\n    data?:\n      | Partial<Omit<Row, \"id\">>\n      | ((args: { current: Row }) => Partial<Omit<Row, \"id\">>);\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"updateMany\", tableName }, async () => {\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const rows = await this.db.transaction().execute(async (tx) => {\n        // Get all IDs that match the filter.\n        let query = tx\n          .selectFrom(versionedTableName)\n          .selectAll()\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\");\n\n        const whereConditions = buildWhereConditions({\n          where,\n          table,\n          encoding: \"sqlite\",\n        });\n        for (const [columnName, comparator, value] of whereConditions) {\n          query = query.where(columnName, comparator, value);\n        }\n\n        const latestRows = await query.execute();\n\n        // TODO: This is probably incredibly slow. Ideally, we'd do most of this in the database.\n        return await Promise.all(\n          latestRows.map(async (latestRow) => {\n            const encodedId = latestRow.id;\n\n            // If the user passed an update function, call it with the current instance.\n            let updateRow: ReturnType<typeof encodeRow>;\n            if (typeof data === \"function\") {\n              const current = decodeRow(latestRow, table, \"sqlite\");\n              const updateObject = data({ current });\n              updateRow = encodeRow(updateObject, table, \"sqlite\");\n            } else {\n              updateRow = encodeRow(data, table, \"sqlite\");\n            }\n\n            // If the update would be applied to a record other than the latest\n            // record, throw an error.\n            if (latestRow.effectiveFromCheckpoint > encodedCheckpoint) {\n              throw new Error(\"Cannot update a record in the past\");\n            }\n\n            // If the latest version has the same effectiveFrom timestamp as the update,\n            // this update is occurring within the same block/second. Update in place.\n            if (latestRow.effectiveFromCheckpoint === encodedCheckpoint) {\n              return await tx\n                .updateTable(versionedTableName)\n                .set(updateRow)\n                .where(\"id\", \"=\", encodedId)\n                .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n                .returningAll()\n                .executeTakeFirstOrThrow();\n            }\n\n            // If the latest version has an earlier effectiveFromCheckpoint than the update,\n            // we need to update the latest version AND insert a new version.\n            await tx\n              .updateTable(versionedTableName)\n              .where(\"id\", \"=\", encodedId)\n              .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n              .set({ effectiveToCheckpoint: encodedCheckpoint })\n              .execute();\n            const row = tx\n              .insertInto(versionedTableName)\n              .values({\n                ...latestRow,\n                ...updateRow,\n                effectiveFromCheckpoint: encodedCheckpoint,\n                effectiveToCheckpoint: \"latest\",\n              })\n              .returningAll()\n              .executeTakeFirstOrThrow();\n\n            return row;\n          }),\n        );\n      });\n\n      return rows.map((row) => decodeRow(row, table, \"sqlite\"));\n    });\n  };\n\n  upsert = async ({\n    tableName,\n    checkpoint,\n    id,\n    create = {},\n    update = {},\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n    create?: Omit<Row, \"id\">;\n    update?:\n      | Partial<Omit<Row, \"id\">>\n      | ((args: { current: Row }) => Partial<Omit<Row, \"id\">>);\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"upsert\", tableName }, async () => {\n      const encodedId = encodeValue(id, table.id, \"sqlite\");\n      const createRow = encodeRow({ id, ...create }, table, \"sqlite\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const row = await this.db.transaction().execute(async (tx) => {\n        // Find the latest version of this instance.\n        const latestRow = await tx\n          .selectFrom(versionedTableName)\n          .selectAll()\n          .where(\"id\", \"=\", encodedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .executeTakeFirst();\n\n        // If there is no latest version, insert a new version using the create data.\n        if (latestRow === undefined) {\n          return await tx\n            .insertInto(versionedTableName)\n            .values({\n              ...createRow,\n              effectiveFromCheckpoint: encodedCheckpoint,\n              effectiveToCheckpoint: \"latest\",\n            })\n            .returningAll()\n            .executeTakeFirstOrThrow();\n        }\n\n        // If the user passed an update function, call it with the current instance.\n        let updateRow: ReturnType<typeof encodeRow>;\n        if (typeof update === \"function\") {\n          const current = decodeRow(latestRow, table, \"sqlite\");\n          const updateObject = update({ current });\n          updateRow = encodeRow({ id, ...updateObject }, table, \"sqlite\");\n        } else {\n          updateRow = encodeRow({ id, ...update }, table, \"sqlite\");\n        }\n\n        // If the update would be applied to a record other than the latest\n        // record, throw an error.\n        if (latestRow.effectiveFromCheckpoint > encodedCheckpoint) {\n          throw new Error(\"Cannot update a record in the past\");\n        }\n\n        // If the latest version has the same effectiveFromCheckpoint as the update,\n        // this update is occurring within the same indexing function. Update in place.\n        if (latestRow.effectiveFromCheckpoint === encodedCheckpoint) {\n          return await tx\n            .updateTable(versionedTableName)\n            .set(updateRow)\n            .where(\"id\", \"=\", encodedId)\n            .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n            .returningAll()\n            .executeTakeFirstOrThrow();\n        }\n\n        // If the latest version has an earlier effectiveFromCheckpoint than the update,\n        // we need to update the latest version AND insert a new version.\n        await tx\n          .updateTable(versionedTableName)\n          .where(\"id\", \"=\", encodedId)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .set({ effectiveToCheckpoint: encodedCheckpoint })\n          .execute();\n        const row = tx\n          .insertInto(versionedTableName)\n          .values({\n            ...latestRow,\n            ...updateRow,\n            effectiveFromCheckpoint: encodedCheckpoint,\n            effectiveToCheckpoint: \"latest\",\n          })\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        return row;\n      });\n\n      return decodeRow(row, table, \"sqlite\");\n    });\n  };\n\n  delete = async ({\n    tableName,\n    checkpoint,\n    id,\n  }: {\n    tableName: string;\n    checkpoint: Checkpoint;\n    id: string | number | bigint;\n  }) => {\n    const versionedTableName = `${tableName}_versioned`;\n    const table = this.schema!.tables[tableName];\n\n    return this.wrap({ method: \"delete\", tableName }, async () => {\n      const encodedId = encodeValue(id, table.id, \"sqlite\");\n      const encodedCheckpoint = encodeCheckpoint(checkpoint);\n\n      const isDeleted = await this.db.transaction().execute(async (tx) => {\n        // If the latest version has effectiveFromCheckpoint equal to current checkpoint,\n        // this row was created within the same indexing function, and we can delete it.\n        let deletedRow = await tx\n          .deleteFrom(versionedTableName)\n          .where(\"id\", \"=\", encodedId)\n          .where(\"effectiveFromCheckpoint\", \"=\", encodedCheckpoint)\n          .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n          .returning([\"id\"])\n          .executeTakeFirst();\n\n        // If we did not take the shortcut above, update the latest record\n        // setting effectiveToCheckpoint to the current checkpoint.\n        if (!deletedRow) {\n          deletedRow = await tx\n            .updateTable(versionedTableName)\n            .set({ effectiveToCheckpoint: encodedCheckpoint })\n            .where(\"id\", \"=\", encodedId)\n            .where(\"effectiveToCheckpoint\", \"=\", \"latest\")\n            .returning([\"id\"])\n            .executeTakeFirst();\n        }\n\n        return !!deletedRow;\n      });\n\n      return isDeleted;\n    });\n  };\n\n  private wrap = async <T>(\n    options: { method: string; tableName?: string },\n    fn: () => Promise<T>,\n  ) => {\n    const start = performance.now();\n    const result = await fn();\n    this.common.metrics.ponder_indexing_store_method_duration.observe(\n      { method: options.method, table: options.tableName },\n      performance.now() - start,\n    );\n    return result;\n  };\n}\n","import type { Abi, Address, Hex } from \"viem\";\nimport type { AbiEvents } from \"./abi.js\";\n\n/**\n * There are up to 4 topics in an EVM log, so given that this could be more strict.\n */\nexport type Topics = (Hex | Hex[] | null)[];\n\nexport type LogFilterCriteria = {\n  address?: Address | Address[];\n  topics?: Topics;\n};\n\nexport type FactoryCriteria = {\n  address: Address;\n  eventSelector: Hex;\n  childAddressLocation: \"topic1\" | \"topic2\" | \"topic3\" | `offset${number}`;\n  topics?: Topics;\n};\n\ntype BaseSource = {\n  id: string;\n  contractName: string;\n  networkName: string;\n  chainId: number;\n  abi: Abi;\n  abiEvents: AbiEvents;\n  startBlock: number;\n  endBlock?: number;\n  maxBlockRange?: number;\n};\n\nexport type LogFilter = BaseSource & {\n  type: \"logFilter\";\n  criteria: LogFilterCriteria;\n};\n\nexport type Factory = BaseSource & {\n  type: \"factory\";\n  criteria: FactoryCriteria;\n};\n\nexport type Source = LogFilter | Factory;\n\nexport const sourceIsLogFilter = (source: Source): source is LogFilter =>\n  source.type === \"logFilter\";\n\nexport const sourceIsFactory = (source: Source): source is Factory =>\n  source.type === \"factory\";\n","export const dedupe = <T>(arr: T[]): T[] => {\n  const seen = new Set<T>();\n\n  return arr.filter((x) => {\n    if (seen.has(x)) return false;\n\n    seen.add(x);\n    return true;\n  });\n};\n","import type { Prettify } from \"@/types/utils.js\";\nimport type { DefaultAddOptions, Options, Queue as TPQueue } from \"p-queue\";\nimport PQueue from \"p-queue\";\n\ntype TaskOptions = { priority?: number };\n\nexport type Queue<TTask> = PQueue & {\n  addTask: (task: TTask, options?: TaskOptions) => Promise<void>;\n};\n\ntype QueueOptions = Prettify<\n  Options<TPQueue<() => Promise<unknown>, DefaultAddOptions>, DefaultAddOptions>\n>;\n\nexport type Worker<TTask, TReturn = void> = (arg: {\n  task: TTask;\n  queue: Queue<TTask>;\n}) => Promise<TReturn>;\n\ntype OnError<TTask> = (arg: {\n  error: Error;\n  task: TTask;\n  queue: Queue<TTask>;\n}) => unknown;\n\n/**\n * Creates a Queue object that has a number of features tailored\n * to Ponder's indexing engine, including:\n * - A shared context object accessible by all tasks\n * - An onError callback that is called _within_ the failed task scope,\n *   allowing the user to retry/add more tasks without the queue going idle.\n */\nexport function createQueue<TTask, TReturn = void>({\n  worker,\n  options,\n  onError,\n  onIdle,\n}: {\n  worker: Worker<TTask, TReturn>;\n  options?: QueueOptions;\n  onError?: OnError<TTask>;\n  onIdle?: () => unknown;\n}): Queue<TTask> {\n  const queue = new PQueue(options) as Queue<TTask>;\n\n  if (onIdle) {\n    queue.on(\"idle\", () => onIdle());\n  }\n\n  queue.addTask = async (task, taskOptions) => {\n    const priority = taskOptions?.priority ?? 0;\n\n    try {\n      await queue.add(\n        () => {\n          return worker({\n            task,\n            queue,\n          });\n        },\n        {\n          priority,\n        },\n      );\n    } catch (error_: any) {\n      await onError?.({ error: error_ as Error, task, queue });\n    }\n  };\n\n  return queue;\n}\n","/** Waits a specified amount of time.\n *\n * @param milliseconds Number of milliseconds to wait.\n */\nexport async function wait(milliseconds: number) {\n  return new Promise<void>((res) => setTimeout(res, milliseconds));\n}\n","import type { Common } from \"@/Ponder.js\";\nimport type { IndexingFunctions } from \"@/build/functions/functions.js\";\nimport type { TableAccess } from \"@/build/functions/parseAst.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type Source,\n  sourceIsFactory,\n  sourceIsLogFilter,\n} from \"@/config/sources.js\";\nimport type { IndexingStore } from \"@/indexing-store/store.js\";\nimport type { Schema } from \"@/schema/types.js\";\nimport type { SyncGateway } from \"@/sync-gateway/service.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport type { Block, Log, Transaction } from \"@/types/eth.js\";\nimport {\n  type Checkpoint,\n  checkpointMax,\n  checkpointMin,\n  isCheckpointEqual,\n  isCheckpointGreaterThan,\n  isCheckpointGreaterThanOrEqualTo,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { dedupe } from \"@/utils/dedupe.js\";\nimport { Emittery } from \"@/utils/emittery.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport { type Queue, type Worker, createQueue } from \"@/utils/queue.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport type { AbiEvent } from \"abitype\";\nimport { E_CANCELED, Mutex, type MutexInterface } from \"async-mutex\";\nimport { type Hex, decodeEventLog } from \"viem\";\nimport {\n  type Context,\n  buildClient,\n  buildContracts,\n  buildDb,\n  buildNetwork,\n} from \"./context.js\";\nimport { addUserStackTrace } from \"./trace.js\";\n\ntype IndexingEvents = {\n  eventsProcessed: { toCheckpoint: Checkpoint };\n  error: { error: Error };\n};\n\ntype SetupTask = {\n  kind: \"SETUP\";\n  data: {\n    networkName: string;\n    contractName: string;\n    checkpoint: Checkpoint;\n  };\n};\ntype LogEventTask = {\n  kind: \"LOG\";\n  data: {\n    networkName: string;\n    contractName: string;\n    eventName: string;\n    event: {\n      args: any;\n      log: Log;\n      block: Block;\n      transaction: Transaction;\n    };\n    checkpoint: Checkpoint;\n    endCheckpoint?: Checkpoint;\n    eventsProcessed?: number;\n  };\n};\n\ntype IndexingFunctionTask = SetupTask | LogEventTask;\ntype IndexingFunctionQueue = Queue<IndexingFunctionTask>;\n\nconst MAX_BATCH_SIZE = 10_000;\n\nexport class IndexingService extends Emittery<IndexingEvents> {\n  private common: Common;\n  private indexingStore: IndexingStore;\n  private syncGatewayService: SyncGateway;\n  private sources: Source[];\n  private networks: Network[];\n\n  private isPaused = false;\n\n  private indexingFunctions?: IndexingFunctions;\n  private schema?: Schema;\n  private tableAccess?: TableAccess;\n\n  queue?: IndexingFunctionQueue;\n\n  private getNetwork: (checkpoint: Checkpoint) => Context[\"network\"] =\n    undefined!;\n  private getClient: (checkpoint: Checkpoint) => Context[\"client\"] = undefined!;\n  private getDB: (checkpoint: Checkpoint) => Context[\"db\"] = undefined!;\n  private getContracts: (checkpoint: Checkpoint) => Context[\"contracts\"] =\n    undefined!;\n\n  private isSetupStarted;\n\n  private indexingFunctionStates: Record<\n    /* Indexing function key: \"{ContractName}:{EventName}\" */\n    string,\n    {\n      contractName: string;\n      eventName: string;\n      /* Indexing function keys that write to tables that this indexing function key reads from. */\n      parents: string[];\n      /* True if this key is a parent of itself. */\n      isSelfDependent: boolean;\n      /* Sources that contribute to this indexing function. */\n      sources: Source[];\n      abiEvent: AbiEvent;\n      eventSelector: Hex;\n\n      /* Checkpoint of max completed task. */\n      tasksProcessedToCheckpoint: Checkpoint;\n      /* Checkpoint of the least recent task loaded from db. */\n      tasksLoadedFromCheckpoint: Checkpoint;\n      /* Checkpoint of the most recent task loaded from db. */\n      tasksLoadedToCheckpoint: Checkpoint;\n      /* Buffer of in memory tasks that haven't been enqueued yet. */\n      loadedTasks: LogEventTask[];\n      /* Mutex ensuring tasks are not loaded twice. */\n      loadingMutex: Mutex;\n      /* Checkpoint of the first loaded event (for metrics). */\n      firstEventCheckpoint?: Checkpoint;\n      /* Checkpoint of the last loaded event (for metrics). */\n      lastEventCheckpoint?: Checkpoint;\n    }\n  > = {};\n  private taskBatchSize: number = MAX_BATCH_SIZE;\n\n  private sourceById: { [sourceId: Source[\"id\"]]: Source } = {};\n\n  constructor({\n    common,\n    syncStore,\n    indexingStore,\n    syncGatewayService,\n    networks,\n    requestQueues,\n    sources,\n  }: {\n    common: Common;\n    syncStore: SyncStore;\n    indexingStore: IndexingStore;\n    syncGatewayService: SyncGateway;\n    networks: Network[];\n    requestQueues: RequestQueue[];\n    sources: Source[];\n  }) {\n    super();\n    this.common = common;\n    this.indexingStore = indexingStore;\n    this.syncGatewayService = syncGatewayService;\n    this.sources = sources;\n    this.networks = networks;\n\n    this.isSetupStarted = false;\n\n    this.buildSourceById();\n\n    this.getNetwork = buildNetwork({\n      networks,\n    });\n    this.getClient = buildClient({\n      networks,\n      requestQueues,\n      syncStore,\n    });\n    this.getContracts = buildContracts({\n      sources,\n    });\n  }\n\n  kill = () => {\n    this.isPaused = true;\n\n    this.queue?.pause();\n    this.queue?.clear();\n    for (const key of Object.keys(this.indexingFunctionStates)) {\n      this.indexingFunctionStates[key].loadingMutex.cancel();\n    }\n    this.common.logger.debug({\n      service: \"indexing\",\n      msg: \"Killed indexing service\",\n    });\n  };\n\n  onIdle = () => this.queue!.onIdle();\n\n  /**\n   * Registers a new set of indexing functions, schema, or table accesss, cancels\n   * the database mutexes & event queue, drops and re-creates\n   * all tables from the indexing store, and rebuilds the indexing function map state.\n   *\n   * Note: Caller should (probably) immediately call processEvents after this method.\n   */\n  reset = async ({\n    indexingFunctions: newIndexingFunctions,\n    schema: newSchema,\n    tableAccess: newTableAccess,\n  }: {\n    indexingFunctions?: IndexingFunctions;\n    schema?: Schema;\n    tableAccess?: TableAccess;\n  } = {}) => {\n    if (newSchema) {\n      this.schema = newSchema;\n\n      this.getDB = buildDb({\n        common: this.common,\n        indexingStore: this.indexingStore,\n        schema: this.schema,\n      });\n    }\n\n    if (newIndexingFunctions) {\n      this.indexingFunctions = newIndexingFunctions;\n    }\n\n    if (newTableAccess) {\n      this.tableAccess = newTableAccess;\n    }\n\n    if (\n      this.indexingFunctions === undefined ||\n      this.sources === undefined ||\n      this.tableAccess === undefined\n    )\n      return;\n\n    this.isPaused = true;\n    this.queue?.pause();\n\n    for (const state of Object.values(this.indexingFunctionStates)) {\n      state.loadingMutex.cancel();\n    }\n\n    this.queue?.clear();\n    await this.queue?.onIdle();\n\n    this.isSetupStarted = false;\n\n    this.buildIndexingFunctionStates();\n    this.createEventQueue();\n\n    this.common.logger.debug({\n      service: \"indexing\",\n      msg: \"Paused event queue\",\n    });\n\n    this.isPaused = false;\n    this.common.metrics.ponder_indexing_has_error.set(0);\n\n    this.common.metrics.ponder_indexing_total_seconds.reset();\n    this.common.metrics.ponder_indexing_completed_seconds.reset();\n    this.common.metrics.ponder_indexing_completed_events.reset();\n\n    await this.indexingStore.reload({ schema: this.schema });\n    this.common.logger.debug({\n      service: \"indexing\",\n      msg: \"Reset indexing store\",\n    });\n\n    this.common.metrics.ponder_indexing_completed_timestamp.set(0);\n  };\n\n  /**\n   * Processes all newly available events.\n   */\n  processEvents = async () => {\n    if (\n      Object.keys(this.indexingFunctionStates).length === 0 ||\n      this.queue === undefined ||\n      this.isPaused\n    )\n      return;\n\n    // Only enqueue setup tasks if no checkpoints have been advanced.\n    if (!this.isSetupStarted) {\n      this.isSetupStarted = true;\n      this.enqueueSetupTasks();\n    }\n\n    this.queue!.start();\n    await this.queue.onIdle();\n\n    await Promise.all(\n      Object.entries(this.indexingFunctionStates).map(([key, state]) =>\n        state.loadingMutex.runExclusive(() =>\n          this.loadIndexingFunctionTasks(key),\n        ),\n      ),\n    );\n\n    this.enqueueLogEventTasks();\n\n    await this.queue.onIdle();\n  };\n\n  /**\n   * This method is triggered by the realtime sync service detecting a reorg,\n   * which can happen at any time. The event queue and the indexing store can be\n   * in one of several different states that we need to keep in mind:\n   *\n   * 1) No events have been added to the queue yet.\n   * 2) No unsafe events have been processed (checkpoint <= safeCheckpoint).\n   * 3) Unsafe events may have been processed (checkpoint > safeCheckpoint).\n   * 4) The queue has encountered a user error and is waiting for a reload.\n   *\n   * Note: It's crucial that we acquire all mutex locks while handling the reorg.\n   * This will only ever run while the queue is idle, so we can be confident\n   * that checkpoint matches the current state of the indexing store,\n   * and that no unsafe events will get processed after handling the reorg.\n   *\n   * Note: Caller should (probably) immediately call processEvents after this method.\n   */\n  handleReorg = async (safeCheckpoint: Checkpoint) => {\n    if (this.isPaused) return;\n\n    let releases: MutexInterface.Releaser[] = [];\n    try {\n      releases = await Promise.all(\n        Object.values(this.indexingFunctionStates).map((indexFunc) =>\n          indexFunc.loadingMutex.acquire(),\n        ),\n      );\n      const hasProcessedInvalidEvents = Object.values(\n        this.indexingFunctionStates,\n      ).some((state) =>\n        isCheckpointGreaterThan(\n          state.tasksProcessedToCheckpoint,\n          safeCheckpoint,\n        ),\n      );\n\n      if (!hasProcessedInvalidEvents) {\n        // No unsafe events have been processed, so no need to revert (case 1 & case 2).\n        this.common.logger.debug({\n          service: \"indexing\",\n          msg: \"No unsafe events were detected while reconciling a reorg, no-op\",\n        });\n        return;\n      }\n\n      // Unsafe events have been processed, must revert the indexing store and update\n      // eventsProcessedToTimestamp accordingly (case 3).\n      await this.indexingStore.revert({ checkpoint: safeCheckpoint });\n\n      this.common.metrics.ponder_indexing_completed_timestamp.set(\n        safeCheckpoint.blockTimestamp,\n      );\n\n      // Note: There's currently no way to know how many events are \"thrown out\"\n      // during the reorg reconciliation, so the event count metrics\n      // (e.g. ponder_indexing_processed_events) will be slightly inflated.\n\n      this.common.logger.debug({\n        service: \"indexing\",\n        msg: `Reverted indexing store to safe timestamp ${safeCheckpoint.blockTimestamp}`,\n      });\n\n      for (const state of Object.values(this.indexingFunctionStates)) {\n        if (\n          isCheckpointGreaterThan(\n            state.tasksProcessedToCheckpoint,\n            safeCheckpoint,\n          )\n        ) {\n          state.tasksProcessedToCheckpoint = safeCheckpoint;\n        }\n        if (\n          isCheckpointGreaterThan(\n            state.tasksLoadedFromCheckpoint,\n            safeCheckpoint,\n          )\n        ) {\n          state.tasksLoadedFromCheckpoint = safeCheckpoint;\n        }\n        if (\n          isCheckpointGreaterThan(state.tasksLoadedToCheckpoint, safeCheckpoint)\n        ) {\n          state.tasksLoadedToCheckpoint = safeCheckpoint;\n        }\n      }\n    } catch (error) {\n      // Pending locks get cancelled in reset(). This is expected, so it's safe to\n      // ignore the error that is thrown when a pending lock is cancelled.\n      if (error !== E_CANCELED) throw error;\n    } finally {\n      for (const release of releases) {\n        release();\n      }\n    }\n  };\n\n  /**\n   * Adds \"setup\" tasks to the queue for all chains if the indexing function is defined.\n   */\n  enqueueSetupTasks = () => {\n    for (const contractName of Object.keys(this.indexingFunctions!)) {\n      if (this.indexingFunctions![contractName].setup === undefined) continue;\n\n      for (const network of this.networks) {\n        const source = this.sources.find(\n          (s) =>\n            s.contractName === contractName && s.chainId === network.chainId,\n        )!;\n\n        // The \"setup\" event uses the contract start block number for contract calls.\n        // TODO: Consider implications of this \"synthetic\" checkpoint on record versioning.\n        const checkpoint = {\n          ...zeroCheckpoint,\n          chainId: network.chainId,\n          blockNumber: source.startBlock,\n        };\n\n        this.queue!.addTask({\n          kind: \"SETUP\",\n          data: {\n            networkName: network.name,\n            contractName,\n            checkpoint,\n          },\n        });\n      }\n    }\n  };\n\n  /**\n   * Implements the core concurrency engine, responsible for ordering tasks.\n   * There are several cases to consider and optimize:\n   *\n   * 1) A task is only dependent on itself, should be run serially.\n   * 2) A task is not dependent, can be run entirely concurrently.\n   * 3) A task is dependent on a combination of parents and itself,\n   *    should be run serially.\n   * 4) A task is dependent on parents, and should onlybe run when\n   *    all previous dependent tasks are complete.\n   */\n  enqueueLogEventTasks = () => {\n    for (const key of Object.keys(this.indexingFunctionStates)) {\n      const state = this.indexingFunctionStates[key];\n      const tasks = state.loadedTasks;\n\n      if (tasks.length === 0) continue;\n\n      if (\n        state.parents.length === 0 &&\n        state.isSelfDependent &&\n        isCheckpointGreaterThanOrEqualTo(\n          state.tasksLoadedFromCheckpoint,\n          tasks[0].data.checkpoint,\n        )\n      ) {\n        // Case 1\n        const taskToEnqueue = tasks.shift()!;\n        this.queue!.addTask(taskToEnqueue);\n      } else if (state.parents.length === 0 && !state.isSelfDependent) {\n        // Case 2\n        for (const task of tasks) {\n          this.queue!.addTask(task);\n        }\n        state.loadedTasks = [];\n      } else if (state.parents.length !== 0) {\n        const parentLoadedFromCheckpoints = state.parents.map(\n          (p) => this.indexingFunctionStates[p].tasksLoadedFromCheckpoint,\n        );\n\n        if (\n          state.isSelfDependent &&\n          isCheckpointGreaterThanOrEqualTo(\n            checkpointMin(\n              ...parentLoadedFromCheckpoints,\n              state.tasksLoadedFromCheckpoint,\n            ),\n            tasks[0].data.checkpoint,\n          )\n        ) {\n          // Case 3\n          const taskToEnqueue = tasks.shift()!;\n          this.queue!.addTask(taskToEnqueue);\n        } else if (!state.isSelfDependent) {\n          // Case 4\n          // Determine limiting factor and enqueue tasks up to that limit.\n          const minParentCheckpoint = checkpointMin(\n            ...parentLoadedFromCheckpoints,\n          );\n\n          // Maximum checkpoint that is less than `minParentCheckpoint`.\n          const maxCheckpointIndex = tasks.findIndex((task) =>\n            isCheckpointGreaterThan(task.data.checkpoint, minParentCheckpoint),\n          );\n\n          if (maxCheckpointIndex === -1) {\n            for (const task of tasks) {\n              this.queue!.addTask(task);\n            }\n            state.loadedTasks = [];\n          } else {\n            const tasksToEnqueue = tasks.splice(0, maxCheckpointIndex);\n            for (const task of tasksToEnqueue) {\n              this.queue!.addTask(task);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  private executeSetupTask = async (task: SetupTask) => {\n    const data = task.data;\n\n    const fullEventName = `${data.contractName}:setup`;\n    const indexingFunction = this.indexingFunctions![data.contractName].setup;\n\n    for (let i = 0; i < 4; i++) {\n      try {\n        this.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${fullEventName}\", block=${data.checkpoint.blockNumber})`,\n        });\n\n        if (this.isPaused) return;\n\n        // Running user code here!\n        await indexingFunction({\n          context: {\n            network: this.getNetwork(data.checkpoint),\n            client: this.getClient(data.checkpoint),\n            db: this.getDB(data.checkpoint),\n            contracts: this.getContracts(data.checkpoint),\n          },\n        });\n\n        this.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${fullEventName}\", block=${data.checkpoint.blockNumber})`,\n        });\n\n        const labels = {\n          network: data.networkName,\n          event: `${data.contractName}:setup`,\n        };\n        this.common.metrics.ponder_indexing_completed_events.inc(labels);\n\n        break;\n      } catch (error_) {\n        const error = error_ as Error & { meta: string };\n\n        if (i === 3) {\n          this.isPaused = true;\n          this.queue!.pause();\n          this.queue!.clear();\n\n          addUserStackTrace(error, this.common.options);\n\n          this.common.logger.error({\n            service: \"indexing\",\n            msg: `Error while processing \"setup\" event: ${error.message}`,\n            error,\n          });\n\n          this.common.metrics.ponder_indexing_has_error.set(1);\n          this.emit(\"error\", { error });\n        } else {\n          this.common.logger.warn({\n            service: \"indexing\",\n            msg: `Indexing function failed, retrying... (event=${fullEventName}, error=${error.name}: ${error.message})`,\n          });\n          await this.indexingStore.revert({\n            checkpoint: data.checkpoint,\n          });\n        }\n      }\n    }\n  };\n\n  private executeLogEventTask = async (task: LogEventTask) => {\n    const data = task.data;\n\n    const fullEventName = `${data.contractName}:${data.eventName}`;\n\n    const indexingFunction =\n      this.indexingFunctions![data.contractName][data.eventName];\n\n    for (let i = 0; i < 4; i++) {\n      try {\n        if (this.isPaused) return;\n\n        this.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${fullEventName}\", block=${data.checkpoint.blockNumber})`,\n        });\n\n        // Running user code here!\n        await indexingFunction({\n          event: {\n            name: data.eventName,\n            ...data.event,\n          },\n          context: {\n            network: this.getNetwork(data.checkpoint),\n            client: this.getClient(data.checkpoint),\n            db: this.getDB(data.checkpoint),\n            contracts: this.getContracts(data.checkpoint),\n          },\n        });\n\n        // Update tasksProcessedToCheckpoint\n        const state = this.indexingFunctionStates[fullEventName];\n        if (data.endCheckpoint === undefined) {\n          state.tasksProcessedToCheckpoint = checkpointMax(\n            state.tasksProcessedToCheckpoint,\n            data.checkpoint,\n          );\n        } else {\n          state.tasksProcessedToCheckpoint = checkpointMax(\n            state.tasksProcessedToCheckpoint,\n            data.endCheckpoint,\n          );\n          this.emitCheckpoint();\n        }\n\n        // Update tasksLoadedFromCheckpoint\n        if (state.loadedTasks.length > 0) {\n          state.tasksLoadedFromCheckpoint =\n            state.loadedTasks[0].data.checkpoint;\n        } else {\n          state.tasksLoadedFromCheckpoint = state.tasksLoadedToCheckpoint;\n        }\n\n        // Emit log if this is the end of a batch of logs\n        if (data.eventsProcessed) {\n          const num = data.eventsProcessed;\n          this.common.logger.info({\n            service: \"indexing\",\n            msg: `Indexed ${\n              num === 1\n                ? `1 ${fullEventName} event`\n                : `${num} ${fullEventName} events`\n            } (chainId=${data.checkpoint.chainId} block=${\n              data.checkpoint.blockNumber\n            } logIndex=${data.checkpoint.logIndex})`,\n          });\n        }\n\n        this.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${fullEventName}\", block=${data.checkpoint.blockNumber})`,\n        });\n\n        this.updateCompletedSeconds(fullEventName);\n\n        const labels = {\n          network: data.networkName,\n          event: `${data.contractName}:${data.eventName}`,\n        };\n        this.common.metrics.ponder_indexing_completed_events.inc(labels);\n\n        break;\n      } catch (error_) {\n        const error = error_ as Error & { meta?: string };\n\n        if (i === 3) {\n          this.isPaused = true;\n          this.queue!.pause();\n          this.queue!.clear();\n\n          addUserStackTrace(error, this.common.options);\n\n          if (error.meta) {\n            error.meta += `\\nEvent args:\\n${prettyPrint(data.event.args)}`;\n          } else {\n            error.meta = `Event args:\\n${prettyPrint(data.event.args)}`;\n          }\n\n          this.common.logger.error({\n            service: \"indexing\",\n            msg: `Error while processing \"${fullEventName}\" event at block ${data.checkpoint.blockNumber}:`,\n            error,\n          });\n\n          this.common.metrics.ponder_indexing_has_error.set(1);\n          this.emit(\"error\", { error });\n        } else {\n          this.common.logger.warn({\n            service: \"indexing\",\n            msg: `Indexing function failed, retrying... (event=${fullEventName}, block=${\n              data.checkpoint.blockNumber\n            }, error=${`${error.name}: ${error.message}`})`,\n          });\n          await this.indexingStore.revert({\n            checkpoint: data.checkpoint,\n          });\n        }\n      }\n    }\n\n    if (this.isPaused) return;\n\n    await this.indexingFunctionStates[fullEventName].loadingMutex.runExclusive(\n      () => this.loadIndexingFunctionTasks(fullEventName),\n    );\n\n    if (this.isPaused) return;\n\n    this.enqueueLogEventTasks();\n  };\n\n  private createEventQueue = () => {\n    const indexingFunctionWorker: Worker<IndexingFunctionTask> = async ({\n      task,\n    }) => {\n      // This is a hack to ensure that the eventsProcessed method is called and updates\n      // the UI when using SQLite. It also allows the process to GC and handle SIGINT events.\n      // It does, however, slow down event processing a bit. Too frequent waits cause massive performance loses.\n      if (Math.floor(Math.random() * 100) === 69) await wait(0);\n\n      switch (task.kind) {\n        case \"SETUP\": {\n          await this.executeSetupTask(task);\n          break;\n        }\n        case \"LOG\": {\n          await this.executeLogEventTask(task);\n          break;\n        }\n      }\n    };\n\n    this.queue = createQueue({\n      worker: indexingFunctionWorker,\n      options: {\n        concurrency: 10,\n        autoStart: false,\n      },\n    });\n  };\n\n  /**\n   * Load a batch of indexing function tasks from the sync store into memory.\n   */\n  loadIndexingFunctionTasks = async (key: string) => {\n    const state = this.indexingFunctionStates[key];\n    const tasks = state.loadedTasks;\n\n    if (\n      tasks.length > 0 ||\n      isCheckpointEqual(\n        state.tasksLoadedToCheckpoint,\n        this.syncGatewayService.checkpoint,\n      )\n    ) {\n      return;\n    }\n\n    // TODO: Deep copy these.\n    const fromCheckpoint = state.tasksLoadedToCheckpoint;\n    const toCheckpoint = this.syncGatewayService.checkpoint;\n\n    const result = await this.syncGatewayService.getEvents({\n      fromCheckpoint,\n      toCheckpoint,\n      limit: this.taskBatchSize,\n      logFilters: state.sources.filter(sourceIsLogFilter).map((logFilter) => ({\n        id: logFilter.id,\n        chainId: logFilter.chainId,\n        criteria: logFilter.criteria,\n        fromBlock: logFilter.startBlock,\n        toBlock: logFilter.endBlock,\n        includeEventSelectors: [state.eventSelector],\n      })),\n      factories: state.sources.filter(sourceIsFactory).map((factory) => ({\n        id: factory.id,\n        chainId: factory.chainId,\n        criteria: factory.criteria,\n        fromBlock: factory.startBlock,\n        toBlock: factory.endBlock,\n        includeEventSelectors: [state.eventSelector],\n      })),\n    });\n\n    const { events, hasNextPage, lastCheckpointInPage, lastCheckpoint } =\n      result;\n\n    for (const event of events) {\n      try {\n        const decodedLog = decodeEventLog({\n          abi: [state.abiEvent],\n          data: event.log.data,\n          topics: event.log.topics,\n        });\n\n        tasks.push({\n          kind: \"LOG\",\n          data: {\n            networkName: this.sourceById[event.sourceId].networkName,\n            contractName: state.contractName,\n            eventName: state.eventName,\n            event: {\n              args: decodedLog.args ?? {},\n              log: event.log,\n              block: event.block,\n              transaction: event.transaction,\n            },\n            checkpoint: {\n              blockNumber: Number(event.block.number),\n              blockTimestamp: Number(event.block.timestamp),\n              chainId: event.chainId,\n              logIndex: event.log.logIndex,\n            },\n          },\n        });\n      } catch (err) {\n        // Sometimes, logs match a selector but cannot be decoded using the provided ABI.\n        // This happens often when using custom event filters, because the indexed-ness\n        // of an event parameter is not taken into account when generating the selector.\n        this.common.logger.debug({\n          service: \"app\",\n          msg: `Unable to decode log, skipping it. id: ${event.log.id}, data: ${event.log.data}, topics: ${event.log.topics}`,\n        });\n      }\n    }\n\n    // Update checkpoints\n    state.tasksLoadedToCheckpoint = hasNextPage\n      ? lastCheckpointInPage\n      : toCheckpoint;\n\n    if (tasks.length > 0) {\n      state.tasksLoadedFromCheckpoint = tasks[0].data.checkpoint;\n\n      // Set special tasks properties necessary for advancing tasksProcessedToCheckpoint\n      // as far into the future as possible, mostly for emitting events.\n      tasks[tasks.length - 1].data.endCheckpoint =\n        state.tasksLoadedToCheckpoint;\n      tasks[tasks.length - 1].data.eventsProcessed = events.length;\n    } else {\n      state.tasksProcessedToCheckpoint = state.tasksLoadedToCheckpoint;\n      state.tasksLoadedFromCheckpoint = state.tasksLoadedToCheckpoint;\n      this.emitCheckpoint();\n    }\n\n    // Set if this is the first event we have loaded for this indexing function.\n    if (state.firstEventCheckpoint === undefined && tasks.length > 0) {\n      state.firstEventCheckpoint = tasks[0].data.checkpoint;\n    }\n    state.lastEventCheckpoint = lastCheckpoint ?? toCheckpoint;\n\n    this.updateTotalSeconds(key);\n  };\n\n  private emitCheckpoint = () => {\n    const checkpoint = checkpointMin(\n      ...Object.values(this.indexingFunctionStates).map(\n        (state) => state.tasksProcessedToCheckpoint,\n      ),\n    );\n\n    this.emit(\"eventsProcessed\", { toCheckpoint: checkpoint });\n    this.common.metrics.ponder_indexing_completed_timestamp.set(\n      checkpoint.blockTimestamp,\n    );\n  };\n\n  private buildSourceById = () => {\n    for (const source of this.sources) {\n      this.sourceById[source.id] = source;\n    }\n  };\n\n  private buildIndexingFunctionStates = () => {\n    if (\n      this.indexingFunctions === undefined ||\n      this.sources === undefined ||\n      this.tableAccess === undefined\n    )\n      return;\n\n    // clear in case of reloads\n    this.indexingFunctionStates = {};\n\n    for (const contractName of Object.keys(this.indexingFunctions)) {\n      // Not sure why this is necessary\n      // @ts-ignore\n      for (const eventName of Object.keys(\n        this.indexingFunctions[contractName],\n      )) {\n        if (eventName === \"setup\") continue;\n\n        const indexingFunctionKey = `${contractName}:${eventName}`;\n\n        // All tables that this indexing function key reads\n        const tableReads = this.tableAccess\n          .filter(\n            (t) =>\n              t.indexingFunctionKey === indexingFunctionKey &&\n              t.access === \"read\",\n          )\n          .map((t) => t.table);\n\n        // All indexing function keys that write to a table in `tableReads`\n        // except for itself.\n        const parents = this.tableAccess\n          .filter(\n            (t) =>\n              !t.indexingFunctionKey.includes(\":setup\") &&\n              t.access === \"write\" &&\n              tableReads.includes(t.table) &&\n              t.indexingFunctionKey !== indexingFunctionKey,\n          )\n          .map((t) => t.indexingFunctionKey);\n\n        const isSelfDependent = this.tableAccess.some(\n          (t) =>\n            t.access === \"write\" &&\n            tableReads.includes(t.table) &&\n            t.indexingFunctionKey === indexingFunctionKey,\n        );\n\n        const keySources = this.sources.filter(\n          (s) => s.contractName === contractName,\n        );\n\n        // Note: Assumption is that all sources with the same contract name have the same abi.\n        const i = this.sources.findIndex(\n          (s) =>\n            s.contractName === contractName &&\n            s.abiEvents.bySafeName[eventName] !== undefined,\n        );\n\n        const abiEvent = this.sources[i].abiEvents.bySafeName[eventName]!.item;\n        const eventSelector =\n          this.sources[i].abiEvents.bySafeName[eventName]!.selector;\n\n        this.common.logger.debug({\n          service: \"indexing\",\n          msg: `Registered indexing function ${indexingFunctionKey} (selfDependent=${isSelfDependent}, parents=[${dedupe(\n            parents,\n          ).join(\", \")}])`,\n        });\n\n        this.indexingFunctionStates[indexingFunctionKey] = {\n          eventName,\n          contractName,\n          parents: dedupe(parents),\n          isSelfDependent,\n          sources: keySources,\n          abiEvent,\n          eventSelector,\n\n          tasksProcessedToCheckpoint: zeroCheckpoint,\n          tasksLoadedFromCheckpoint: zeroCheckpoint,\n          tasksLoadedToCheckpoint: zeroCheckpoint,\n          loadedTasks: [],\n          loadingMutex: new Mutex(),\n        };\n      }\n    }\n\n    this.taskBatchSize = Math.floor(\n      MAX_BATCH_SIZE / Object.keys(this.indexingFunctionStates).length,\n    );\n  };\n\n  private updateCompletedSeconds = (key: string) => {\n    const state = this.indexingFunctionStates[key];\n    if (\n      state.firstEventCheckpoint === undefined ||\n      state.lastEventCheckpoint === undefined\n    )\n      return;\n\n    this.common.metrics.ponder_indexing_completed_seconds.set(\n      { event: `${state.contractName}:${state.eventName}` },\n      Math.min(\n        state.tasksProcessedToCheckpoint.blockTimestamp,\n        state.lastEventCheckpoint.blockTimestamp,\n      ) - state.firstEventCheckpoint.blockTimestamp,\n    );\n  };\n\n  private updateTotalSeconds = (key: string) => {\n    const state = this.indexingFunctionStates[key];\n    if (\n      state.firstEventCheckpoint === undefined ||\n      state.lastEventCheckpoint === undefined\n    )\n      return;\n\n    this.common.metrics.ponder_indexing_total_seconds.set(\n      { event: `${state.contractName}:${state.eventName}` },\n      state.lastEventCheckpoint.blockTimestamp -\n        state.firstEventCheckpoint.blockTimestamp,\n    );\n  };\n}\n","import type { Common } from \"@/Ponder.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { Source } from \"@/config/sources.js\";\nimport type { IndexingStore, Row } from \"@/indexing-store/store.js\";\nimport type { Schema } from \"@/schema/types.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport type { DatabaseModel } from \"@/types/model.js\";\nimport type { Checkpoint } from \"@/utils/checkpoint.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  type Abi,\n  type Address,\n  type Client,\n  checksumAddress,\n  createClient,\n} from \"viem\";\nimport { ponderActions } from \"./ponderActions.js\";\nimport { ponderTransport } from \"./transport.js\";\n\nexport type Context = {\n  network: { chainId: number; name: string };\n  client: Client;\n  db: Record<string, DatabaseModel<any>>;\n  contracts: Record<\n    string,\n    {\n      abi: Abi;\n      address?: Address | readonly Address[];\n      startBlock: number;\n      endBlock?: number;\n      maxBlockRange?: number;\n    }\n  >;\n};\n\nexport const buildNetwork = ({ networks }: { networks: Network[] }) => {\n  const _networks = {} as Record<number, string>;\n\n  for (const network of networks) {\n    _networks[network.chainId] = network.name;\n  }\n\n  return (checkpoint: Checkpoint) => ({\n    chainId: checkpoint.chainId,\n    name: _networks[checkpoint.chainId],\n  });\n};\n\nexport const buildClient =\n  ({\n    networks,\n    requestQueues,\n    syncStore,\n  }: {\n    networks: Network[];\n    requestQueues: RequestQueue[];\n    syncStore: SyncStore;\n  }) =>\n  (checkpoint: Checkpoint) => {\n    const index = networks.findIndex((n) => n.chainId === checkpoint.chainId);\n\n    return createClient({\n      transport: ponderTransport({\n        requestQueue: requestQueues[index],\n        syncStore,\n      }),\n      chain: networks[index].chain,\n    }).extend(ponderActions(BigInt(checkpoint.blockNumber)));\n  };\n\nexport const buildDb =\n  ({\n    common,\n    indexingStore,\n    schema,\n  }: {\n    common: Common;\n    indexingStore: IndexingStore;\n    schema: Schema;\n  }) =>\n  (checkpoint: Checkpoint) => {\n    return Object.keys(schema.tables).reduce<\n      Record<string, DatabaseModel<Row>>\n    >((acc, tableName) => {\n      acc[tableName] = {\n        findUnique: async ({ id }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.findUnique(id=${id})`,\n          });\n          return await indexingStore.findUnique({\n            tableName,\n            checkpoint,\n            id,\n          });\n        },\n        findMany: async ({ where, orderBy, limit, before, after } = {}) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.findMany`,\n          });\n          return await indexingStore.findMany({\n            tableName,\n            checkpoint,\n            where,\n            orderBy,\n            limit,\n            before,\n            after,\n          });\n        },\n        create: async ({ id, data }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.create(id=${id})`,\n          });\n          return await indexingStore.create({\n            tableName,\n            checkpoint,\n            id,\n            data,\n          });\n        },\n        createMany: async ({ data }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.createMany(count=${data.length})`,\n          });\n          return await indexingStore.createMany({\n            tableName,\n            checkpoint,\n            data,\n          });\n        },\n        update: async ({ id, data }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.update(id=${id})`,\n          });\n          return await indexingStore.update({\n            tableName,\n            checkpoint,\n            id,\n            data,\n          });\n        },\n        updateMany: async ({ where, data }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.updateMany`,\n          });\n          return await indexingStore.updateMany({\n            tableName,\n            checkpoint,\n            where,\n            data,\n          });\n        },\n        upsert: async ({ id, create, update }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.upsert(id=${id})`,\n          });\n          return await indexingStore.upsert({\n            tableName,\n            checkpoint,\n            id,\n            create,\n            update,\n          });\n        },\n        delete: async ({ id }) => {\n          common.logger.trace({\n            service: \"store\",\n            msg: `${tableName}.delete(id=${id})`,\n          });\n          return await indexingStore.delete({\n            tableName,\n            checkpoint,\n            id,\n          });\n        },\n      };\n      return acc;\n    }, {});\n  };\n\nexport const buildContracts = ({ sources }: { sources: Source[] }) => {\n  const contracts: Record<number, Context[\"contracts\"]> = {};\n\n  for (const source of sources) {\n    const address =\n      typeof source.criteria.address === \"string\"\n        ? source.criteria.address\n        : undefined;\n\n    if (contracts[source.chainId] === undefined) {\n      contracts[source.chainId] = {};\n    }\n\n    contracts[source.chainId][source.contractName] = {\n      abi: source.abi,\n      address: address ? checksumAddress(address) : address,\n      startBlock: source.startBlock,\n      endBlock: source.endBlock,\n      maxBlockRange: source.maxBlockRange,\n    };\n  }\n\n  return (checkpoint: Checkpoint) => contracts[checkpoint.chainId]!;\n};\n","import type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionConfig,\n  GetBalanceParameters,\n  GetBalanceReturnType,\n  GetBytecodeParameters,\n  GetBytecodeReturnType,\n  GetStorageAtParameters,\n  GetStorageAtReturnType,\n  MulticallParameters,\n  MulticallReturnType,\n  PublicRpcSchema,\n  ReadContractParameters,\n  ReadContractReturnType,\n  Transport,\n} from \"viem\";\nimport {\n  getBalance as viemGetBalance,\n  getBytecode as viemGetBytecode,\n  getStorageAt as viemGetStorageAt,\n  multicall as viemMulticall,\n  readContract as viemReadContract,\n} from \"viem/actions\";\n\nimport type { Prettify } from \"@/types/utils.js\";\n\nexport type PonderActions = {\n  getBalance: (\n    args: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> & {\n      cache?: \"immutable\";\n    },\n  ) => Promise<GetBalanceReturnType>;\n  getBytecode: (\n    args: Omit<GetBytecodeParameters, \"blockTag\" | \"blockNumber\"> & {\n      cache?: \"immutable\";\n    },\n  ) => Promise<GetBytecodeReturnType>;\n  getStorageAt: (\n    args: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> & {\n      cache?: \"immutable\";\n    },\n  ) => Promise<GetStorageAtReturnType>;\n  multicall: <\n    TContracts extends ContractFunctionConfig[],\n    TAllowFailure extends boolean = true,\n  >(\n    args: Omit<\n      MulticallParameters<TContracts, TAllowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > & {\n      cache?: \"immutable\";\n    },\n  ) => Promise<MulticallReturnType<TContracts, TAllowFailure>>;\n  readContract: <\n    const TAbi extends Abi | readonly unknown[],\n    TFunctionName extends string,\n  >(\n    args: Omit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      \"blockTag\" | \"blockNumber\"\n    > & {\n      cache?: \"immutable\";\n    },\n  ) => Promise<ReadContractReturnType<TAbi, TFunctionName>>;\n};\n\nexport type ReadOnlyClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n> = Prettify<\n  Client<transport, chain, undefined, PublicRpcSchema, PonderActions>\n>;\n\nexport const ponderActions =\n  (blockNumber: bigint) =>\n  <\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): PonderActions => ({\n    getBalance: ({\n      cache,\n      ...args\n    }: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> & {\n      cache?: \"immutable\";\n    }): Promise<GetBalanceReturnType> =>\n      viemGetBalance(client, {\n        ...args,\n        ...(cache === \"immutable\" ? { blockTag: \"latest\" } : { blockNumber }),\n      }),\n    getBytecode: ({\n      cache,\n      ...args\n    }: Omit<GetBytecodeParameters, \"blockTag\" | \"blockNumber\"> & {\n      cache?: \"immutable\";\n    }): Promise<GetBytecodeReturnType> =>\n      viemGetBytecode(client, {\n        ...args,\n        ...(cache === \"immutable\" ? { blockTag: \"latest\" } : { blockNumber }),\n      }),\n    getStorageAt: ({\n      cache,\n      ...args\n    }: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> & {\n      cache?: \"immutable\";\n    }): Promise<GetStorageAtReturnType> =>\n      viemGetStorageAt(client, {\n        ...args,\n        ...(cache === \"immutable\" ? { blockTag: \"latest\" } : { blockNumber }),\n      }),\n    multicall: <\n      TContracts extends ContractFunctionConfig[],\n      TAllowFailure extends boolean = true,\n    >({\n      cache,\n      ...args\n    }: Omit<\n      MulticallParameters<TContracts, TAllowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > & {\n      cache?: \"immutable\";\n    }): Promise<MulticallReturnType<TContracts, TAllowFailure>> =>\n      viemMulticall(client, {\n        ...args,\n        ...(cache === \"immutable\" ? { blockTag: \"latest\" } : { blockNumber }),\n      }),\n    // @ts-ignore\n    readContract: <\n      const TAbi extends Abi | readonly unknown[],\n      TFunctionName extends string,\n    >({\n      cache,\n      ...args\n    }: Omit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      \"blockTag\" | \"blockNumber\"\n    > & {\n      cache?: \"immutable\";\n    }): Promise<ReadContractReturnType<TAbi, TFunctionName>> =>\n      viemReadContract(client, {\n        ...args,\n        ...(cache === \"immutable\" ? { blockTag: \"latest\" } : { blockNumber }),\n      } as ReadContractParameters<TAbi, TFunctionName>),\n  });\n","import type { SyncStore } from \"@/sync-store/store.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport type { Address, Hex, Transport } from \"viem\";\nimport { custom, hexToBigInt, maxUint256 } from \"viem\";\n\nconst cachedMethods = [\n  \"eth_call\",\n  \"eth_getBalance\",\n  \"eth_getCode\",\n  \"eth_getStorageAt\",\n] as const;\n\nexport const ponderTransport = ({\n  requestQueue,\n  syncStore,\n}: {\n  requestQueue: RequestQueue;\n  syncStore: SyncStore;\n}): Transport => {\n  return ({ chain }) => {\n    const c = custom({\n      async request({ method, params }) {\n        const body = { method, params };\n\n        if (cachedMethods.includes(method)) {\n          let request: string = undefined!;\n          let blockNumber: Hex | \"latest\" = undefined!;\n\n          if (method === \"eth_call\") {\n            const [{ data, to }, _blockNumber] = params as [\n              { data: Hex; to: Hex },\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(to)}_${toLowerCase(\n              data,\n            )}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getBalance\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getCode\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getStorageAt\") {\n            const [address, slot, _blockNumber] = params as [\n              Address,\n              Hex,\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(\n              address,\n            )}_${toLowerCase(slot)}`;\n            blockNumber = _blockNumber;\n          }\n\n          const blockNumberBigInt =\n            blockNumber === \"latest\" ? maxUint256 : hexToBigInt(blockNumber);\n\n          const cachedResult = await syncStore.getRpcRequestResult({\n            blockNumber: blockNumberBigInt,\n            chainId: chain!.id,\n            request,\n          });\n\n          if (cachedResult?.result) return cachedResult.result;\n          else {\n            const response = await requestQueue.request(body);\n            await syncStore.insertRpcRequestResult({\n              blockNumber: blockNumberBigInt,\n              chainId: chain!.id,\n              request,\n              result: response as string,\n            });\n            return response;\n          }\n        } else {\n          return requestQueue.request(body);\n        }\n      },\n    });\n    return c({ chain });\n  };\n};\n","import { readFileSync } from \"node:fs\";\n\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { type StackFrame, parse as parseStackTrace } from \"stacktrace-parser\";\n\nimport type { Options } from \"@/config/options.js\";\n\nexport const addUserStackTrace = (error: Error, options: Options) => {\n  if (!error.stack) return;\n\n  const stackTrace = parseStackTrace(error.stack);\n\n  let codeFrame: string | undefined;\n  let userStackTrace: StackFrame[];\n\n  // Find first frame that occurred within user code.\n  const firstUserFrameIndex = stackTrace.findIndex((frame) =>\n    frame.file?.includes(options.srcDir),\n  );\n\n  if (firstUserFrameIndex >= 0) {\n    userStackTrace = stackTrace.filter((frame) =>\n      frame.file?.includes(options.srcDir),\n    );\n\n    const firstUserFrame = stackTrace[firstUserFrameIndex];\n    if (firstUserFrame?.file && firstUserFrame?.lineNumber) {\n      try {\n        const sourceContent = readFileSync(firstUserFrame.file, {\n          encoding: \"utf-8\",\n        });\n        codeFrame = codeFrameColumns(\n          sourceContent,\n          {\n            start: {\n              line: firstUserFrame.lineNumber,\n              column: firstUserFrame.column ?? undefined,\n            },\n          },\n          { highlightCode: true },\n        );\n      } catch (err) {\n        // Ignore errors here.\n      }\n    }\n  } else {\n    userStackTrace = stackTrace;\n  }\n\n  const formattedStackTrace = [\n    `${error.name}: ${error.message}`,\n    ...userStackTrace.map(({ file, lineNumber, column, methodName }) => {\n      const prefix = \"    at\";\n      const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n        column !== null ? `:${column}` : \"\"\n      }`;\n      if (methodName === null || methodName === \"<unknown>\") {\n        return `${prefix} ${path}`;\n      } else {\n        return `${prefix} ${methodName} (${path})`;\n      }\n    }),\n    codeFrame,\n  ].join(\"\\n\");\n\n  error.stack = formattedStackTrace;\n};\n","import path from \"node:path\";\n\nimport pc from \"picocolors\";\nimport { type LevelWithSilent, type Logger, pino } from \"pino\";\n\ntype LogOptions = { msg?: string; service?: string } & { [key: string]: any };\n\nconst timeFormatter = new Intl.DateTimeFormat(undefined, {\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\",\n});\n\nexport class LoggerService {\n  private logger: Logger;\n\n  constructor({\n    level = \"info\",\n    dir,\n  }: { level?: LevelWithSilent; dir?: string } = {}) {\n    const streams: (pino.DestinationStream | pino.StreamEntry)[] = [];\n\n    if (level !== \"silent\") {\n      streams.push({\n        level,\n        stream: {\n          write(logString: string) {\n            const log = JSON.parse(logString);\n            const prettyLog = formatMessage(log);\n            console.log(prettyLog);\n\n            // If there is an \"error\" property, log the stack trace.\n            if (log.error?.stack) console.log(log.error.stack);\n            if (log.error?.meta) console.log(log.error.meta);\n\n            // TODO: Consider also logging any inner `cause` errors.\n            // if (log.error?.cause?.stack) {\n            //   console.log(\"Details:\");\n            //   console.log(\"  \" + log.error.cause.stack);\n            // }\n          },\n        },\n      });\n    }\n\n    if (dir) {\n      const timestamp = new Date().toISOString().replace(/[-:.]/g, \"_\");\n      const logFile = path.join(dir, `${timestamp}.log`);\n      streams.push({\n        level: \"trace\",\n        stream: pino.destination({ dest: logFile, sync: false, mkdir: true }),\n      });\n    }\n\n    this.logger = pino(\n      {\n        level: \"trace\",\n        serializers: { error: pino.stdSerializers.errWithCause },\n      },\n      pino.multistream(streams),\n    );\n  }\n\n  fatal = (options: LogOptions & { error?: Error }) => {\n    this.logger.fatal(options);\n  };\n  error = (options: LogOptions & { error: Error; msg?: string }) => {\n    this.logger.error(options);\n  };\n  warn = (options: LogOptions & { msg: string }) => {\n    this.logger.warn(options);\n  };\n  info = (options: LogOptions & { msg: string }) => {\n    this.logger.info(options);\n  };\n  debug = (options: LogOptions & { msg: string }) => {\n    this.logger.debug(options);\n  };\n  trace = (options: LogOptions & { msg: string }) => {\n    this.logger.trace(options);\n  };\n}\n\nconst levels = {\n  60: { label: \"FATAL\", colorize: (s: string) => pc.bgRed(s) },\n  50: { label: \"ERROR\", colorize: (s: string) => pc.red(s) },\n  40: { label: \"WARN \", colorize: (s: string) => pc.yellow(s) },\n  30: { label: \"INFO \", colorize: (s: string) => pc.green(s) },\n  20: { label: \"DEBUG\", colorize: (s: string) => pc.blue(s) },\n  10: { label: \"TRACE\", colorize: (s: string) => pc.gray(s) },\n} as const;\n\nconst formatMessage = (log: { [key: string]: any }) => {\n  let result = \"\";\n\n  const timestamp = log.time as number;\n  const time = timeFormatter.format(new Date(timestamp));\n  const level = levels[(log.level as keyof typeof levels) ?? 30];\n  const msg = log.msg as string | undefined;\n  const errorMessage = log.error?.message as string | undefined;\n  const message = msg ?? errorMessage;\n  const service = log.service as string | undefined;\n\n  result += pc.isColorSupported ? pc.gray(`${time} `) : `${time} `;\n  result += pc.isColorSupported ? level.colorize(level.label) : level.label;\n  if (service)\n    result += pc.isColorSupported\n      ? ` ${pc.cyan(service.padEnd(10, \" \"))}`\n      : ` ${service.padEnd(10, \" \")}`;\n  result += pc.reset(` ${message}`);\n  return result;\n};\n","import type { DatabaseConfig } from \"@/config/database.js\";\nimport type { Pool } from \"pg\";\nimport prometheus from \"prom-client\";\n\nconst httpRequestBucketsInMs = [\n  0.1, 0.25, 0.5, 0.75, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1_000, 2_000,\n  4_000, 8_000, 16_000, 32_000,\n];\n\nconst httpRequestSizeInBytes = [\n  10, 50, 100, 250, 500, 1_000, 2_500, 5_000, 10_000, 50_000, 100_000, 250_000,\n  500_000, 1_000_000, 5_000_000, 10_000_000,\n];\n\nexport class MetricsService {\n  private registry: prometheus.Registry;\n\n  ponder_rpc_request_duration: prometheus.Histogram<\"network\" | \"method\">;\n  ponder_rpc_request_lag: prometheus.Histogram<\"network\" | \"method\">;\n\n  ponder_historical_start_timestamp: prometheus.Gauge<\"network\">;\n  ponder_historical_total_blocks: prometheus.Gauge<\"network\" | \"contract\">;\n  ponder_historical_cached_blocks: prometheus.Gauge<\"network\" | \"contract\">;\n  ponder_historical_completed_blocks: prometheus.Gauge<\"network\" | \"contract\">;\n\n  ponder_realtime_is_connected: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_number: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_timestamp: prometheus.Gauge<\"network\">;\n  ponder_realtime_reorg_total: prometheus.Counter<\"network\">;\n\n  ponder_indexing_total_seconds: prometheus.Gauge<\"event\">;\n  ponder_indexing_completed_seconds: prometheus.Gauge<\"event\">;\n  ponder_indexing_completed_events: prometheus.Gauge<\"network\" | \"event\">;\n  ponder_indexing_completed_timestamp: prometheus.Gauge;\n  ponder_indexing_has_error: prometheus.Gauge;\n\n  ponder_server_port: prometheus.Gauge;\n  ponder_server_request_size: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_server_response_size: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_server_response_duration: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n\n  ponder_sync_store_method_duration: prometheus.Histogram<\"method\">;\n  ponder_indexing_store_method_duration: prometheus.Histogram<\n    \"table\" | \"method\"\n  >;\n\n  ponder_postgres_idle_connection_count: prometheus.Counter = null!;\n  ponder_postgres_total_connection_count: prometheus.Counter = null!;\n  ponder_postgres_request_queue_count: prometheus.Counter = null!;\n  ponder_postgres_query_count: prometheus.Counter = null!;\n\n  ponder_sqlite_query_count: prometheus.Counter = null!;\n\n  constructor() {\n    this.registry = new prometheus.Registry();\n\n    prometheus.collectDefaultMetrics({\n      register: this.registry,\n      prefix: \"ponder_default_\",\n    });\n\n    this.ponder_rpc_request_duration = new prometheus.Histogram({\n      name: \"ponder_rpc_request_duration\",\n      help: \"Duration of RPC requests\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestBucketsInMs,\n      registers: [this.registry],\n    });\n    this.ponder_rpc_request_lag = new prometheus.Histogram({\n      name: \"ponder_rpc_request_lag\",\n      help: \"Time RPC requests spend waiting in the request queue\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestBucketsInMs,\n      registers: [this.registry],\n    });\n\n    this.ponder_historical_start_timestamp = new prometheus.Gauge({\n      name: \"ponder_historical_start_timestamp\",\n      help: \"Unix timestamp (ms) when the historical sync service started\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_total_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_total_blocks\",\n      help: \"Number of blocks required for the historical sync\",\n      labelNames: [\"network\", \"contract\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_cached_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_cached_blocks\",\n      help: \"Number of blocks that were found in the cache for the historical sync\",\n      labelNames: [\"network\", \"contract\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completed_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_completed_blocks\",\n      help: \"Number of blocks that have been processed for the historical sync\",\n      labelNames: [\"network\", \"contract\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_realtime_is_connected = new prometheus.Gauge({\n      name: \"ponder_realtime_is_connected\",\n      help: \"Boolean (0 or 1) indicating if the historical sync service is connected\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_number = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_number\",\n      help: \"Block number of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_timestamp = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_timestamp\",\n      help: \"Block timestamp of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_reorg_total = new prometheus.Counter({\n      name: \"ponder_realtime_reorg_total\",\n      help: \"Count of how many re-orgs have occurred.\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_indexing_total_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_total_seconds\",\n      help: \"Total number of seconds that are required\",\n      labelNames: [\"event\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_seconds\",\n      help: \"Number of seconds that have been completed\",\n      labelNames: [\"event\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_events = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_events\",\n      help: \"Number of events that have been processed\",\n      labelNames: [\"network\", \"event\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_timestamp = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_timestamp\",\n      help: \"Timestamp through which all events have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_has_error = new prometheus.Gauge({\n      name: \"ponder_indexing_has_error\",\n      help: \"Boolean (0 or 1) indicating if an error was encountered while running user code\",\n      registers: [this.registry],\n    });\n\n    this.ponder_server_port = new prometheus.Gauge({\n      name: \"ponder_server_port\",\n      help: \"Port that the server is listening on\",\n      registers: [this.registry],\n    });\n    this.ponder_server_request_size = new prometheus.Histogram({\n      name: \"ponder_server_request_size\",\n      help: \"Size of HTTP requests received by the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeInBytes,\n      registers: [this.registry],\n    });\n    this.ponder_server_response_size = new prometheus.Histogram({\n      name: \"ponder_server_response_size\",\n      help: \"Size of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeInBytes,\n      registers: [this.registry],\n    });\n    this.ponder_server_response_duration = new prometheus.Histogram({\n      name: \"ponder_server_response_duration\",\n      help: \"Duration of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeInBytes,\n      registers: [this.registry],\n    });\n\n    this.ponder_sync_store_method_duration = new prometheus.Histogram({\n      name: \"ponder_sync_store_method_duration\",\n      help: \"Duration of database operations in the sync store\",\n      labelNames: [\"method\"] as const,\n      buckets: httpRequestBucketsInMs,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_store_method_duration = new prometheus.Histogram({\n      name: \"ponder_indexing_store_method_duration\",\n      help: \"Duration of database operations in the sync store\",\n      labelNames: [\"table\", \"method\"] as const,\n      buckets: httpRequestBucketsInMs,\n      registers: [this.registry],\n    });\n  }\n\n  registerDatabaseMetrics(database: DatabaseConfig) {\n    if (database.sync.kind === \"postgres\") {\n      this.registry.removeSingleMetric(\"ponder_postgres_query_count\");\n      this.ponder_postgres_query_count = new prometheus.Counter({\n        name: \"ponder_postgres_query_count\",\n        help: \"Number of queries executed by Postgres\",\n        labelNames: [\"kind\"] as const,\n        registers: [this.registry],\n      });\n\n      const pool = database.sync.pool as unknown as Pool;\n      this.registry.removeSingleMetric(\"ponder_postgres_idle_connection_count\");\n      this.ponder_postgres_idle_connection_count = new prometheus.Gauge({\n        name: \"ponder_postgres_idle_connection_count\",\n        help: \"Number of idle connections in the pool\",\n        registers: [this.registry],\n        collect() {\n          this.set(pool.idleCount);\n        },\n      });\n      this.registry.removeSingleMetric(\n        \"ponder_postgres_total_connection_count\",\n      );\n      this.ponder_postgres_total_connection_count = new prometheus.Gauge({\n        name: \"ponder_postgres_total_connection_count\",\n        help: \"Total number of connections in the pool\",\n        registers: [this.registry],\n        collect() {\n          this.set(pool.totalCount);\n        },\n      });\n      this.registry.removeSingleMetric(\"ponder_postgres_request_queue_count\");\n      this.ponder_postgres_request_queue_count = new prometheus.Gauge({\n        name: \"ponder_postgres_request_queue_count\",\n        help: \"Number of transaction or query requests waiting for an available connection\",\n        registers: [this.registry],\n        collect() {\n          this.set(pool.waitingCount);\n        },\n      });\n    } else {\n      this.registry.removeSingleMetric(\"ponder_sqlite_query_count\");\n      this.ponder_sqlite_query_count = new prometheus.Counter({\n        name: \"ponder_sqlite_query_count\",\n        help: \"Number of queries executed by SQLite\",\n        labelNames: [\"kind\"] as const,\n        registers: [this.registry],\n      });\n    }\n  }\n\n  /**\n   * Get string representation for all metrics.\n   * @returns Metrics encoded using Prometheus v0.0.4 format.\n   */\n  async getMetrics() {\n    return await this.registry.metrics();\n  }\n\n  async resetMetrics() {\n    this.registry.resetMetrics();\n  }\n}\n","import type { Server } from \"node:http\";\nimport { createServer } from \"node:http\";\n\nimport { Emittery } from \"@/utils/emittery.js\";\nimport cors from \"cors\";\nimport express, { type Handler } from \"express\";\nimport type { FormattedExecutionResult, GraphQLSchema } from \"graphql\";\nimport { GraphQLError, formatError } from \"graphql\";\nimport { createHandler } from \"graphql-http/lib/use/express\";\nimport { createHttpTerminator } from \"http-terminator\";\n\nimport type { Common } from \"@/Ponder.js\";\nimport type { IndexingStore } from \"@/indexing-store/store.js\";\nimport { graphiQLHtml } from \"@/ui/graphiql.html.js\";\n\ntype ServerEvents = {\n  \"admin:reload\": { chainId: number };\n};\n\nexport class ServerService extends Emittery<ServerEvents> {\n  app: express.Express;\n\n  private common: Common;\n  private indexingStore: IndexingStore;\n\n  private port: number;\n  private terminate?: () => Promise<void>;\n  private graphqlMiddleware?: Handler;\n\n  isHistoricalIndexingComplete = false;\n\n  constructor({\n    common,\n    indexingStore,\n  }: {\n    common: Common;\n    indexingStore: IndexingStore;\n  }) {\n    super();\n\n    this.common = common;\n    this.indexingStore = indexingStore;\n    this.app = express();\n\n    // This gets updated to the resolved port if the requested port is in use.\n    this.port = this.common.options.port;\n  }\n\n  setup({ registerDevRoutes }: { registerDevRoutes: boolean }) {\n    // Middleware.\n    this.app.use(cors({ methods: [\"GET\", \"POST\", \"OPTIONS\", \"HEAD\"] }));\n\n    // Observability routes.\n    this.app.all(\"/metrics\", this.handleMetrics());\n    this.app.get(\"/health\", this.handleHealthGet());\n\n    // GraphQL routes.\n    this.app?.all(\n      \"/graphql\",\n      this.handleGraphql({ shouldWaitForHistoricalSync: true }),\n    );\n    this.app?.all(\n      \"/\",\n      this.handleGraphql({ shouldWaitForHistoricalSync: false }),\n    );\n\n    if (registerDevRoutes) {\n      this.app.post(\"/admin/reload\", this.handleAdminReload());\n    }\n  }\n\n  async start() {\n    const server = await new Promise<Server>((resolve, reject) => {\n      const server = createServer(this.app)\n        .on(\"error\", (error) => {\n          if ((error as any).code === \"EADDRINUSE\") {\n            this.common.logger.warn({\n              service: \"server\",\n              msg: `Port ${this.port} was in use, trying port ${this.port + 1}`,\n            });\n            this.port += 1;\n            setTimeout(() => {\n              server.close();\n              server.listen(this.port, this.common.options.hostname);\n            }, 5);\n          } else {\n            reject(error);\n          }\n        })\n        .on(\"listening\", () => {\n          this.common.metrics.ponder_server_port.set(this.port);\n          resolve(server);\n        })\n        // Note that this.common.options.hostname can be undefined if the user did not specify one.\n        // In this case, Node.js uses `::` if IPv6 is available and `0.0.0.0` otherwise.\n        // https://nodejs.org/api/net.html#serverlistenport-host-backlog-callback\n        .listen(this.port, this.common.options.hostname);\n    });\n\n    const terminator = createHttpTerminator({ server });\n    this.terminate = () => terminator.terminate();\n\n    this.common.logger.info({\n      service: \"server\",\n      msg: `Started listening on port ${this.port}`,\n    });\n  }\n\n  async kill() {\n    await this.terminate?.();\n    this.common.logger.debug({\n      service: \"server\",\n      msg: `Killed server, stopped listening on port ${this.port}`,\n    });\n  }\n\n  reloadGraphqlSchema({ graphqlSchema }: { graphqlSchema: GraphQLSchema }) {\n    this.graphqlMiddleware = createHandler({\n      schema: graphqlSchema,\n      context: { store: this.indexingStore },\n    });\n  }\n\n  setIsHistoricalIndexingComplete() {\n    this.isHistoricalIndexingComplete = true;\n\n    this.common.logger.info({\n      service: \"server\",\n      msg: \"Started responding as healthy\",\n    });\n  }\n\n  // Route handlers.\n  private handleMetrics(): Handler {\n    return async (req, res) => {\n      if (req.method !== \"GET\" && req.method !== \"POST\") {\n        res.status(404).end();\n      }\n\n      try {\n        res.set(\"Content-Type\", \"text/plain; version=0.0.4; charset=utf-8\");\n        res.end(await this.common.metrics.getMetrics());\n      } catch (error) {\n        res.status(500).end(error);\n      }\n    };\n  }\n\n  private handleHealthGet(): Handler {\n    return (_, res) => {\n      if (this.isHistoricalIndexingComplete) {\n        return res.status(200).send();\n      }\n\n      const max = this.common.options.maxHealthcheckDuration;\n      const elapsed = Math.floor(process.uptime());\n\n      if (elapsed > max) {\n        this.common.logger.warn({\n          service: \"server\",\n          msg: `Historical sync duration has exceeded the max healthcheck duration of ${max} seconds (current: ${elapsed}). Sevice is now responding as healthy and may serve incomplete data.`,\n        });\n        return res.status(200).send();\n      }\n\n      return res.status(503).send();\n    };\n  }\n\n  private handleGraphql({\n    shouldWaitForHistoricalSync,\n  }: {\n    shouldWaitForHistoricalSync: boolean;\n  }): Handler {\n    return (req, res, next) => {\n      if (!this.graphqlMiddleware) {\n        return next();\n      }\n\n      // While waiting for historical indexing to complete, we want to respond back\n      // with an error to prevent the requester from accepting incomplete data.\n      if (shouldWaitForHistoricalSync && !this.isHistoricalIndexingComplete) {\n        // Respond back with a similar runtime query error as the GraphQL package.\n        // https://github.com/graphql/express-graphql/blob/3fab4b1e016cd27655f3b013f65a6b1344520d01/src/index.ts#L397-L400\n        const errors = [\n          formatError(new GraphQLError(\"Historical indexing is not complete\")),\n        ];\n        const result: FormattedExecutionResult = {\n          data: undefined,\n          errors,\n        };\n        return res.status(503).json(result);\n      }\n\n      switch (req.method) {\n        case \"POST\":\n          return this.graphqlMiddleware(req, res, next);\n        case \"GET\": {\n          return res\n            .status(200)\n            .setHeader(\"Content-Type\", \"text/html\")\n            .send(graphiQLHtml);\n        }\n        case \"HEAD\":\n          return res.status(200).send();\n        default:\n          return next();\n      }\n    };\n  }\n\n  private handleAdminReload(): Handler {\n    return async (req, res) => {\n      try {\n        const chainId = parseInt(req.query.chainId as string, 10);\n        if (Number.isNaN(chainId)) {\n          res.status(400).end(\"chainId must exist and be a valid integer\");\n          return;\n        }\n        this.emit(\"admin:reload\", { chainId });\n        res.status(200).end();\n      } catch (error) {\n        res.status(500).end(error);\n      }\n    };\n  }\n}\n","// https://github.com/graphql/graphiql/blob/main/examples/graphiql-cdn/index.html\n\nexport const graphiQLHtml = `<!--\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n-->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Ponder Playground</title>\n    <style>\n      body {\n        height: 100%;\n        margin: 0;\n        width: 100%;\n        overflow: hidden;\n      }\n      #graphiql {\n        height: 100vh;\n      }\n      *::-webkit-scrollbar {\n        height: 0.3rem;\n        width: 0.5rem;\n      }\n      *::-webkit-scrollbar-track {\n        -ms-overflow-style: none;\n        overflow: -moz-scrollbars-none;\n      }\n      *::-webkit-scrollbar-thumb {\n        -ms-overflow-style: none;\n        overflow: -moz-scrollbars-none;\n      }\n    </style>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/graphiql/graphiql.min.css\" />\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/@graphiql/plugin-explorer/dist/style.css\" />\n  </head>\n  <body>\n    <div id=\"graphiql\">Loading...</div>\n    <script crossorigin src=\"https://unpkg.com/react/umd/react.development.js\"></script>1\n    <script crossorigin src=\"https://unpkg.com/react-dom/umd/react-dom.development.js\"></script>\n    <script src=\"https://unpkg.com/graphiql/graphiql.min.js\" crossorigin=\"anonymous\"></script>\n    <script src=\"https://unpkg.com/@graphiql/plugin-explorer/dist/index.umd.js\" crossorigin=\"anonymous\"></script>\n    <script>\n      const fetcher = GraphiQL.createFetcher({ url: \"/\" });\n      const explorerPlugin = GraphiQLPluginExplorer.explorerPlugin();\n      const root = ReactDOM.createRoot(document.getElementById(\"graphiql\"));\n      root.render(\n        React.createElement(GraphiQL, {\n          fetcher,\n          plugins: [explorerPlugin],\n          defaultEditorToolsVisibility: false,\n        })\n      );\n    </script>\n  </body>\n</html>`;\n","import type { Common } from \"@/Ponder.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { FactoryCriteria, LogFilterCriteria } from \"@/config/sources.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport {\n  type Checkpoint,\n  checkpointMax,\n  checkpointMin,\n  isCheckpointGreaterThan,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { Emittery } from \"@/utils/emittery.js\";\nimport type { Hex } from \"viem\";\n\ntype SyncGatewayEvents = {\n  /**\n   * Emitted when a new event checkpoint is reached. This is the minimum timestamp\n   * at which events are available across all registered networks.\n   */\n  newCheckpoint: Checkpoint;\n  /**\n   * Emitted when a new finality checkpoint is reached. This is the minimum timestamp\n   * at which events are finalized across all registered networks.\n   */\n  newFinalityCheckpoint: Checkpoint;\n  /**\n   * Emitted when a reorg has been detected on any registered network. The value\n   * is the safe/\"common ancestor\" checkpoint.\n   */\n  reorg: Checkpoint;\n  /**\n   * Emitted when the historical sync has completed across all registered networks.\n   */\n  hasCompletedHistoricalSync: Checkpoint;\n};\n\ntype SyncGatewayMetrics = {};\n\nexport class SyncGateway extends Emittery<SyncGatewayEvents> {\n  private common: Common;\n  private syncStore: SyncStore;\n  private networks: Network[];\n\n  // Minimum timestamp at which events are available (across all networks).\n  checkpoint: Checkpoint;\n  // Minimum finalized timestamp (across all networks).\n  finalityCheckpoint: Checkpoint;\n\n  // Per-network event timestamp checkpoints.\n  private networkCheckpoints: Record<\n    number,\n    {\n      isHistoricalSyncComplete: boolean;\n      historicalCheckpoint: Checkpoint;\n      realtimeCheckpoint: Checkpoint;\n      finalityCheckpoint: Checkpoint;\n    }\n  >;\n\n  // Timestamp at which the historical sync was completed (across all networks).\n  historicalSyncCompletedAt?: number;\n\n  metrics: SyncGatewayMetrics;\n\n  constructor({\n    common,\n    syncStore,\n    networks,\n  }: {\n    common: Common;\n    syncStore: SyncStore;\n    networks: Network[];\n  }) {\n    super();\n\n    this.common = common;\n    this.syncStore = syncStore;\n    this.networks = networks;\n    this.metrics = {};\n\n    this.checkpoint = zeroCheckpoint;\n    this.finalityCheckpoint = zeroCheckpoint;\n\n    this.networkCheckpoints = {};\n    this.networks.forEach((network) => {\n      const { chainId } = network;\n      this.networkCheckpoints[chainId] = {\n        isHistoricalSyncComplete: false,\n        historicalCheckpoint: zeroCheckpoint,\n        realtimeCheckpoint: zeroCheckpoint,\n        finalityCheckpoint: zeroCheckpoint,\n      };\n    });\n  }\n\n  /** Fetches events for all registered log filters between the specified checkpoints.\n   *\n   * @param options.fromCheckpoint Checkpoint to include events from (exclusive).\n   * @param options.toCheckpoint Checkpoint to include events to (inclusive).\n   */\n  getEvents({\n    fromCheckpoint,\n    toCheckpoint,\n    limit,\n    logFilters,\n    factories,\n  }: {\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n    limit: number;\n    logFilters?: {\n      id: string;\n      chainId: number;\n      criteria: LogFilterCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n      includeEventSelectors?: Hex[];\n    }[];\n    factories?: {\n      id: string; // Note that this is the source ID of the child contract.\n      chainId: number;\n      criteria: FactoryCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n      includeEventSelectors?: Hex[];\n    }[];\n  }) {\n    return this.syncStore.getLogEvents({\n      fromCheckpoint,\n      toCheckpoint,\n      limit,\n      logFilters,\n      factories,\n    });\n  }\n\n  handleNewHistoricalCheckpoint = (checkpoint: Checkpoint) => {\n    const { blockTimestamp, chainId, blockNumber } = checkpoint;\n\n    this.networkCheckpoints[chainId].historicalCheckpoint = checkpoint;\n\n    this.common.logger.trace({\n      service: \"gateway\",\n      msg: `New historical checkpoint (timestamp=${blockTimestamp} chainId=${chainId} blockNumber=${blockNumber})`,\n    });\n\n    this.recalculateCheckpoint();\n  };\n\n  handleHistoricalSyncComplete = ({ chainId }: { chainId: number }) => {\n    this.networkCheckpoints[chainId].isHistoricalSyncComplete = true;\n    this.recalculateCheckpoint();\n\n    // If every network has completed the historical sync, set the metric.\n    const networkCheckpoints = Object.values(this.networkCheckpoints);\n    if (networkCheckpoints.every((n) => n.isHistoricalSyncComplete)) {\n      const maxHistoricalCheckpoint = checkpointMax(\n        ...networkCheckpoints.map((n) => n.historicalCheckpoint),\n      );\n      this.historicalSyncCompletedAt = maxHistoricalCheckpoint.blockTimestamp;\n\n      this.common.logger.debug({\n        service: \"gateway\",\n        msg: \"Completed historical sync across all networks\",\n      });\n    }\n  };\n\n  handleNewRealtimeCheckpoint = (checkpoint: Checkpoint) => {\n    const { blockTimestamp, chainId, blockNumber } = checkpoint;\n\n    this.networkCheckpoints[chainId].realtimeCheckpoint = checkpoint;\n\n    this.common.logger.trace({\n      service: \"gateway\",\n      msg: `New realtime checkpoint at (timestamp=${blockTimestamp} chainId=${chainId} blockNumber=${blockNumber})`,\n    });\n\n    this.recalculateCheckpoint();\n  };\n\n  handleNewFinalityCheckpoint = (checkpoint: Checkpoint) => {\n    const { chainId } = checkpoint;\n\n    this.networkCheckpoints[chainId].finalityCheckpoint = checkpoint;\n    this.recalculateFinalityCheckpoint();\n  };\n\n  handleReorg = (checkpoint: Checkpoint) => {\n    this.emit(\"reorg\", checkpoint);\n  };\n\n  /** Resets global checkpoints as well as the network checkpoint for the specified chain ID.\n   *  Keeps previous checkpoint values for other networks.\n   *\n   * @param options.chainId Chain ID for which to reset the checkpoint.\n   */\n  resetCheckpoints = ({ chainId }: { chainId: number }) => {\n    this.checkpoint = zeroCheckpoint;\n    this.finalityCheckpoint = zeroCheckpoint;\n    this.historicalSyncCompletedAt = 0;\n    this.networkCheckpoints[chainId] = {\n      isHistoricalSyncComplete: false,\n      historicalCheckpoint: zeroCheckpoint,\n      realtimeCheckpoint: zeroCheckpoint,\n      finalityCheckpoint: zeroCheckpoint,\n    };\n  };\n\n  private recalculateCheckpoint = () => {\n    const checkpoints = Object.values(this.networkCheckpoints).map((n) =>\n      n.isHistoricalSyncComplete\n        ? checkpointMax(n.historicalCheckpoint, n.realtimeCheckpoint)\n        : n.historicalCheckpoint,\n    );\n    const newCheckpoint = checkpointMin(...checkpoints);\n\n    if (isCheckpointGreaterThan(newCheckpoint, this.checkpoint)) {\n      this.checkpoint = newCheckpoint;\n\n      const { chainId, blockTimestamp, blockNumber } = this.checkpoint;\n      this.common.logger.trace({\n        service: \"gateway\",\n        msg: `New checkpoint (timestamp=${blockTimestamp} chainId=${chainId} blockNumber=${blockNumber})`,\n      });\n\n      this.emit(\"newCheckpoint\", this.checkpoint);\n    }\n  };\n\n  private recalculateFinalityCheckpoint = () => {\n    const newFinalityCheckpoint = checkpointMin(\n      ...Object.values(this.networkCheckpoints).map(\n        (n) => n.finalityCheckpoint,\n      ),\n    );\n\n    if (\n      isCheckpointGreaterThan(newFinalityCheckpoint, this.finalityCheckpoint)\n    ) {\n      this.finalityCheckpoint = newFinalityCheckpoint;\n\n      const { chainId, blockTimestamp, blockNumber } = this.finalityCheckpoint;\n      this.common.logger.trace({\n        service: \"gateway\",\n        msg: `New finality checkpoint (timestamp=${blockTimestamp} chainId=${chainId} blockNumber=${blockNumber})`,\n      });\n\n      this.emit(\"newFinalityCheckpoint\", this.finalityCheckpoint);\n    }\n  };\n}\n","import type { Source } from \"@/config/sources.js\";\nimport type { MetricsService } from \"./service.js\";\n\nexport async function getHistoricalSyncStats({\n  sources,\n  metrics,\n}: {\n  sources: Source[];\n  metrics: MetricsService;\n}) {\n  const startTimestampMetric = (\n    await metrics.ponder_historical_start_timestamp.get()\n  ).values?.[0]?.value;\n  const cachedBlocksMetric = (\n    await metrics.ponder_historical_cached_blocks.get()\n  ).values;\n  const totalBlocksMetric = (await metrics.ponder_historical_total_blocks.get())\n    .values;\n  const completedBlocksMetric = (\n    await metrics.ponder_historical_completed_blocks.get()\n  ).values;\n\n  return sources.map((source) => {\n    const { contractName, networkName } = source;\n\n    const totalBlocks = totalBlocksMetric.find(\n      ({ labels }) =>\n        labels.contract === contractName && labels.network === networkName,\n    )?.value;\n    const cachedBlocks = cachedBlocksMetric.find(\n      ({ labels }) =>\n        labels.contract === contractName && labels.network === networkName,\n    )?.value;\n    const completedBlocks =\n      completedBlocksMetric.find(\n        ({ labels }) =>\n          labels.contract === contractName && labels.network === networkName,\n      )?.value ?? 0;\n\n    // If the total_blocks metric is set and equals zero, the sync was skipped and\n    // should be considered complete.\n    if (totalBlocks === 0) {\n      return {\n        network: networkName,\n        contract: contractName,\n        rate: 1,\n        eta: 0,\n      };\n    }\n\n    // Any of these mean setup is not complete.\n    if (\n      totalBlocks === undefined ||\n      cachedBlocks === undefined ||\n      !startTimestampMetric\n    ) {\n      return { network: networkName, contract: contractName, rate: 0 };\n    }\n\n    const rate = (cachedBlocks + completedBlocks) / totalBlocks;\n\n    // If fewer than 3 blocks have been processsed, the ETA will be low quality.\n    if (completedBlocks < 3)\n      return { network: networkName, contract: contractName, rate };\n\n    // If rate is 1, sync is complete, so set the ETA to zero.\n    if (rate === 1)\n      return {\n        network: networkName,\n        contract: contractName,\n        rate,\n        eta: 0,\n      };\n\n    // (time elapsed) / (% completion of remaining block range)\n    const elapsed = Date.now() - startTimestampMetric;\n    const estimatedTotalDuration =\n      elapsed / (completedBlocks / (totalBlocks - cachedBlocks));\n    const estimatedTimeRemaining = estimatedTotalDuration - elapsed;\n\n    return {\n      network: networkName,\n      contract: contractName,\n      rate,\n      eta: estimatedTimeRemaining,\n    };\n  });\n}\n","export const formatEta = (ms: number) => {\n  // If less than 1 second, return ms.\n  if (ms < 1000) return `${Math.round(ms)}ms`;\n  const seconds = Math.floor(ms / 1000);\n\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds - h * 3600) / 60);\n  const s = seconds - h * 3600 - m * 60;\n\n  const hstr = h > 0 ? `${h}h ` : \"\";\n  const mstr = m > 0 || h > 0 ? `${m}m ` : \"\";\n  const sstr = s > 0 || m > 0 ? `${s}s` : \"\";\n\n  return `${hstr}${mstr}${sstr}`;\n};\n\nexport const formatPercentage = (cacheRate: number) => {\n  const decimal = Math.round(cacheRate * 1000) / 10;\n  return Number.isInteger(decimal) && decimal < 100\n    ? `${decimal}.0%`\n    : `${decimal}%`;\n};\n","/**\n * Return the total sum of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the sum of.\n * @returns Sum of the intervals.\n */\nexport function intervalSum(intervals: [number, number][]) {\n  let totalSum = 0;\n\n  for (const [start, end] of intervals) {\n    totalSum += end - start + 1;\n  }\n\n  return totalSum;\n}\n\n/**\n * Return the union of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the union of.\n * @returns Union of the intervals, represented as a list of intervals.\n */\nexport function intervalUnion(intervals: [number, number][]) {\n  if (intervals.length === 0) return [];\n\n  // Sort intervals based on the left end\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const result: [number, number][] = [];\n  let currentInterval = intervals[0];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const nextInterval = intervals[i];\n\n    if (currentInterval[1] >= nextInterval[0] - 1) {\n      // Merge overlapping intervals\n      currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);\n    } else {\n      // No overlap, add current interval to result\n      result.push(currentInterval);\n      currentInterval = nextInterval;\n    }\n  }\n\n  result.push(currentInterval); // Add the last interval\n  return result;\n}\n\n/**\n * Return the intersection of two lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersection(\n  list1: [number, number][],\n  list2: [number, number][],\n) {\n  const result: [number, number][] = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < list1.length && j < list2.length) {\n    const [start1, end1] = list1[i];\n    const [start2, end2] = list2[j];\n\n    const intersectionStart = Math.max(start1, start2);\n    const intersectionEnd = Math.min(end1, end2);\n\n    if (intersectionStart <= intersectionEnd) {\n      result.push([intersectionStart, intersectionEnd]);\n    }\n\n    if (end1 < end2) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  // Merge potentially overlapping intervals before returning.\n  return intervalUnion(result);\n}\n\n/**\n * Return the intersection of many lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Difference of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersectionMany(lists: [number, number][][]) {\n  if (lists.length === 0) return [];\n  if (lists.length === 1) return lists[0];\n\n  let result: [number, number][] = lists[0];\n\n  for (let i = 1; i < lists.length; i++) {\n    result = intervalIntersection(result, lists[i]);\n  }\n\n  return intervalUnion(result);\n}\n\n/**\n * Return the difference between two lists of numeric intervals (initial - remove).\n *\n * @param initial Starting/base list of numeric intervals.\n * @param remove List of numeric intervals to remove.\n * @returns Difference of the intervals, represented as a list of intervals.\n */\nexport function intervalDifference(\n  initial: [number, number][],\n  remove: [number, number][],\n) {\n  // Create copies to avoid mutating the originals.\n  const initial_ = initial.map((interval) => [...interval] as [number, number]);\n  const remove_ = remove.map((interval) => [...interval] as [number, number]);\n\n  const result: [number, number][] = [];\n\n  let i = 0;\n  let j = 0;\n\n  while (i < initial.length && j < remove.length) {\n    const interval1 = initial_[i];\n    const interval2 = remove_[j];\n\n    if (interval1[1] < interval2[0]) {\n      // No overlap, add interval1 to the result\n      result.push(interval1);\n      i++;\n    } else if (interval2[1] < interval1[0]) {\n      // No overlap, move to the next interval in remove\n      j++;\n    } else {\n      // There is an overlap\n      if (interval1[0] < interval2[0]) {\n        // Add the left part of interval1\n        result.push([interval1[0], interval2[0] - 1]);\n      }\n      if (interval1[1] > interval2[1]) {\n        // Update interval1's start to exclude the overlap\n        interval1[0] = interval2[1] + 1;\n        j++;\n      } else {\n        // No more overlap, move to the next interval in initial\n        i++;\n      }\n    }\n  }\n\n  // Add any remaining intervals from initial\n  while (i < initial_.length) {\n    result.push(initial_[i]);\n    i++;\n  }\n\n  return result;\n}\n\nexport function getChunks({\n  intervals,\n  maxChunkSize,\n}: {\n  intervals: [number, number][];\n  maxChunkSize: number;\n}) {\n  const _chunks: [number, number][] = [];\n\n  for (const interval of intervals) {\n    const [startBlock, endBlock] = interval;\n\n    let fromBlock = startBlock;\n    let toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n\n    while (fromBlock <= endBlock) {\n      _chunks.push([fromBlock, toBlock]);\n\n      fromBlock = toBlock + 1;\n      toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n    }\n  }\n\n  return _chunks;\n}\n\nexport class ProgressTracker {\n  target: [number, number];\n  private _completed: [number, number][];\n  private _required: [number, number][] | null = null;\n  private _checkpoint: number | null = null;\n\n  /**\n   * Constructs a new ProgressTracker object.\n\n   * @throws Will throw an error if the target interval is invalid.\n   */\n  constructor({\n    target,\n    completed,\n  }: {\n    target: [number, number];\n    completed: [number, number][];\n  }) {\n    if (target[0] > target[1])\n      throw new Error(\n        `Invalid interval: start (${target[0]}) is greater than end (${target[1]})`,\n      );\n\n    this.target = target;\n    this._completed = completed;\n  }\n\n  /**\n   * Adds a completed interval.\n   *\n   * @throws Will throw an error if the new interval is invalid.\n   */\n  addCompletedInterval(interval: [number, number]) {\n    if (interval[0] > interval[1])\n      throw new Error(\n        `Invalid interval: start (${interval[0]}) is greater than end (${interval[1]})`,\n      );\n\n    const prevCheckpoint = this.getCheckpoint();\n    this._completed = intervalUnion([...this._completed, interval]);\n    this.invalidateCache();\n    const newCheckpoint = this.getCheckpoint();\n\n    return {\n      isUpdated: newCheckpoint > prevCheckpoint,\n      prevCheckpoint,\n      newCheckpoint,\n    };\n  }\n\n  /**\n   * Returns the remaining required intervals.\n   */\n  getRequired() {\n    if (this._required === null) {\n      this._required = intervalDifference([this.target], this._completed);\n    }\n    return this._required;\n  }\n\n  /**\n   * Returns the checkpoint value. If no progress has been made, the checkpoint\n   * is equal to the target start minus one.\n   */\n  getCheckpoint() {\n    if (this._checkpoint !== null) return this._checkpoint;\n\n    const completedIntervalIncludingTargetStart = this._completed\n      .sort((a, b) => a[0] - b[0])\n      .find((i) => i[0] <= this.target[0] && i[1] >= this.target[0]);\n\n    if (completedIntervalIncludingTargetStart) {\n      this._checkpoint = completedIntervalIncludingTargetStart[1];\n    } else {\n      this._checkpoint = this.target[0] - 1;\n    }\n\n    return this._checkpoint;\n  }\n\n  private invalidateCache() {\n    this._required = null;\n    this._checkpoint = null;\n  }\n}\n\n/**\n * Need granular writes to db and retries at each step rather than at the task level\n */\n\nexport class BlockProgressTracker {\n  private pendingBlocks: number[] = [];\n  private completedBlocks: {\n    blockNumber: number;\n    blockTimestamp: number;\n  }[] = [];\n\n  checkpoint: { blockNumber: number; blockTimestamp: number } | null = null;\n\n  addPendingBlocks({ blockNumbers }: { blockNumbers: number[] }): void {\n    if (blockNumbers.length === 0) return;\n\n    const maxPendingBlock = this.pendingBlocks[this.pendingBlocks.length - 1];\n\n    const sorted = blockNumbers.sort((a, b) => a - b);\n    const minNewPendingBlock = sorted[0];\n\n    if (\n      this.pendingBlocks.length > 0 &&\n      minNewPendingBlock <= maxPendingBlock\n    ) {\n      throw new Error(\n        `New pending block number ${minNewPendingBlock} was added out of order. Already added block number ${maxPendingBlock}.`,\n      );\n    }\n\n    sorted.forEach((blockNumber) => {\n      this.pendingBlocks.push(blockNumber);\n    });\n  }\n\n  /**\n   * Add a new completed block. If adding this block moves the checkpoint, returns the\n   * new checkpoint. Otherwise, returns null.\n   */\n  addCompletedBlock({\n    blockNumber,\n    blockTimestamp,\n  }: {\n    blockNumber: number;\n    blockTimestamp: number;\n  }) {\n    // Find and remove the completed block from the pending list.\n    const pendingBlockIndex = this.pendingBlocks.findIndex(\n      (pendingBlock) => pendingBlock === blockNumber,\n    );\n    if (pendingBlockIndex === -1) {\n      throw new Error(\n        `Block number ${blockNumber} was not pending. Ensure to add blocks as pending before marking them as completed.`,\n      );\n    }\n    this.pendingBlocks.splice(pendingBlockIndex, 1);\n\n    // Add the new completed block to the completed block list, and maintain the sort order.\n    // Note that this could be optimized using a for loop with a break.\n    this.completedBlocks.push({ blockNumber, blockTimestamp });\n    this.completedBlocks.sort((a, b) => a.blockNumber - b.blockNumber);\n\n    // If the pending blocks list is now empty, return the max block present in\n    // the list of completed blocks. This happens at the end of the sync.\n    if (this.pendingBlocks.length === 0) {\n      this.checkpoint = this.completedBlocks[this.completedBlocks.length - 1];\n      return this.checkpoint;\n    }\n\n    // Find all completed blocks that are less than the minimum pending block.\n    // These blocks are \"safe\".\n    const safeCompletedBlocks = this.completedBlocks.filter(\n      ({ blockNumber }) => blockNumber < this.pendingBlocks[0],\n    );\n\n    // If there are no safe blocks, the first pending block has not been completed yet.\n    if (safeCompletedBlocks.length === 0) return null;\n\n    const maximumSafeCompletedBlock =\n      safeCompletedBlocks[safeCompletedBlocks.length - 1];\n\n    // Remove all safe completed blocks that are less than the new checkpoint.\n    // This avoid a memory leak and speeds up subsequent calls.\n    this.completedBlocks = this.completedBlocks.filter(\n      ({ blockNumber }) => blockNumber >= maximumSafeCompletedBlock.blockNumber,\n    );\n\n    // If this is the first checkpoint OR this checkpoint is greater than\n    // the previous checkpoint, store and return it as updated.\n    if (\n      !this.checkpoint ||\n      maximumSafeCompletedBlock.blockNumber > this.checkpoint.blockNumber\n    ) {\n      this.checkpoint = maximumSafeCompletedBlock;\n      return this.checkpoint;\n    }\n\n    // Otherwise, the checkpoint is not updated.\n    return null;\n  }\n}\n","import type { Common } from \"@/Ponder.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type Factory,\n  type LogFilter,\n  type LogFilterCriteria,\n  type Source,\n  type Topics,\n  sourceIsLogFilter,\n} from \"@/config/sources.js\";\nimport { getHistoricalSyncStats } from \"@/metrics/utils.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport type { Checkpoint } from \"@/utils/checkpoint.js\";\nimport { Emittery } from \"@/utils/emittery.js\";\nimport { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport {\n  BlockProgressTracker,\n  ProgressTracker,\n  getChunks,\n  intervalDifference,\n  intervalIntersection,\n  intervalSum,\n} from \"@/utils/interval.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { type Queue, type Worker, createQueue } from \"@/utils/queue.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  type Address,\n  BlockNotFoundError,\n  type Hash,\n  type Hex,\n  type RpcBlock,\n  type RpcLog,\n  hexToNumber,\n  numberToHex,\n  toHex,\n} from \"viem\";\nimport {\n  type LogFilterError,\n  getLogFilterRetryRanges,\n} from \"./getLogFilterRetryRanges.js\";\nimport { validateHistoricalBlockRange } from \"./validateHistoricalBlockRange.js\";\n\ntype HistoricalSyncEvents = {\n  /**\n   * Emitted when the service has finished processing all historical sync tasks.\n   */\n  syncComplete: undefined;\n  /**\n   * Emitted when the minimum cached timestamp among all registered sources moves forward.\n   * This indicates to consumers that the connected sync store now contains a complete history\n   * of events for all registered sources between their start block and this timestamp (inclusive).\n   */\n  historicalCheckpoint: Checkpoint;\n};\n\ntype LogFilterTask = {\n  kind: \"LOG_FILTER\";\n  logFilter: LogFilter;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype FactoryChildAddressTask = {\n  kind: \"FACTORY_CHILD_ADDRESS\";\n  factory: Factory;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype FactoryLogFilterTask = {\n  kind: \"FACTORY_LOG_FILTER\";\n  factory: Factory;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype BlockTask = {\n  kind: \"BLOCK\";\n  blockNumber: number;\n  callbacks: ((block: HistoricalBlock) => Promise<void>)[];\n};\n\ntype HistoricalSyncTask =\n  | LogFilterTask\n  | FactoryChildAddressTask\n  | FactoryLogFilterTask\n  | BlockTask;\n\ntype HistoricalBlock = RpcBlock<\"finalized\", true>;\n\ntype LogInterval = {\n  startBlock: number;\n  endBlock: number;\n  logs: RpcLog[];\n  transactionHashes: Set<Hash>;\n};\n\nexport class HistoricalSyncService extends Emittery<HistoricalSyncEvents> {\n  private common: Common;\n  private syncStore: SyncStore;\n  private network: Network;\n  private requestQueue: RequestQueue;\n\n  /**\n   * Service configuration. Will eventually be reloadable.\n   */\n  private finalizedBlockNumber: number = null!;\n  private sources: Source[];\n\n  /**\n   * Block progress trackers for each task type.\n   */\n  private logFilterProgressTrackers: Record<string, ProgressTracker> = {};\n  private factoryChildAddressProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private factoryLogFilterProgressTrackers: Record<string, ProgressTracker> =\n    {};\n  private blockProgressTracker: BlockProgressTracker =\n    new BlockProgressTracker();\n\n  /**\n   * Functions registered by log filter + child contract tasks. These functions accept\n   * a raw block object, get required data from it, then insert data and cache metadata\n   * into the sync store. The keys of this object are used to keep track of which blocks\n   * must be fetched.\n   */\n  private blockCallbacks: Record<\n    number,\n    ((block: HistoricalBlock) => Promise<void>)[]\n  > = {};\n\n  /**\n   * Block tasks have been added to the queue up to and including this block number.\n   * Used alongside blockCallbacks to keep track of which block tasks to add to the queue.\n   */\n  private blockTasksEnqueuedCheckpoint = 0;\n\n  private queue: Queue<HistoricalSyncTask>;\n\n  /** If true, failed tasks should not log errors or be retried. */\n  private isShuttingDown = false;\n  private progressLogInterval?: NodeJS.Timeout;\n\n  constructor({\n    common,\n    syncStore,\n    network,\n    requestQueue,\n    sources = [],\n  }: {\n    common: Common;\n    syncStore: SyncStore;\n    network: Network;\n    requestQueue: RequestQueue;\n    sources?: Source[];\n  }) {\n    super();\n\n    this.common = common;\n    this.syncStore = syncStore;\n    this.network = network;\n    this.requestQueue = requestQueue;\n    this.sources = sources;\n\n    this.queue = this.buildQueue();\n  }\n\n  async setup({\n    latestBlockNumber,\n    finalizedBlockNumber,\n  }: {\n    latestBlockNumber: number;\n    finalizedBlockNumber: number;\n  }) {\n    // Initialize state variables. Required when restarting the service.\n    this.isShuttingDown = false;\n    this.blockTasksEnqueuedCheckpoint = 0;\n\n    this.finalizedBlockNumber = finalizedBlockNumber;\n\n    await Promise.all(\n      this.sources.map(async (source) => {\n        const { isHistoricalSyncRequired, startBlock, endBlock } =\n          validateHistoricalBlockRange({\n            startBlock: source.startBlock,\n            endBlock: source.endBlock,\n            finalizedBlockNumber,\n            latestBlockNumber,\n          });\n\n        if (sourceIsLogFilter(source)) {\n          // Log filter\n          if (!isHistoricalSyncRequired) {\n            this.logFilterProgressTrackers[source.id] = new ProgressTracker({\n              target: [startBlock, finalizedBlockNumber],\n              completed: [[startBlock, finalizedBlockNumber]],\n            });\n            this.common.metrics.ponder_historical_total_blocks.set(\n              { network: this.network.name, contract: source.contractName },\n              0,\n            );\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Start block is in unfinalized range, skipping historical sync (contract=${source.id})`,\n            });\n            return;\n          }\n\n          const completedLogFilterIntervals =\n            await this.syncStore.getLogFilterIntervals({\n              chainId: source.chainId,\n              logFilter: {\n                address: source.criteria.address,\n                topics: source.criteria.topics,\n              },\n            });\n          const logFilterProgressTracker = new ProgressTracker({\n            target: [startBlock, endBlock],\n            completed: completedLogFilterIntervals,\n          });\n          this.logFilterProgressTrackers[source.id] = logFilterProgressTracker;\n\n          const requiredLogFilterIntervals =\n            logFilterProgressTracker.getRequired();\n\n          const logFilterTaskChunks = getChunks({\n            intervals: requiredLogFilterIntervals,\n            maxChunkSize:\n              source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n          });\n\n          for (const [fromBlock, toBlock] of logFilterTaskChunks) {\n            this.queue.addTask(\n              {\n                kind: \"LOG_FILTER\",\n                logFilter: source,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n          if (logFilterTaskChunks.length > 0) {\n            const total = intervalSum(requiredLogFilterIntervals);\n            this.common.logger.debug({\n              service: \"historical\",\n              msg: `Added LOG_FILTER tasks for ${total}-block range (contract=${source.contractName}, network=${this.network.name})`,\n            });\n          }\n\n          const targetBlockCount = endBlock - startBlock + 1;\n          const cachedBlockCount =\n            targetBlockCount - intervalSum(requiredLogFilterIntervals);\n\n          this.common.metrics.ponder_historical_total_blocks.set(\n            { network: this.network.name, contract: source.contractName },\n            targetBlockCount,\n          );\n          this.common.metrics.ponder_historical_cached_blocks.set(\n            { network: this.network.name, contract: source.contractName },\n            cachedBlockCount,\n          );\n\n          this.common.logger.info({\n            service: \"historical\",\n            msg: `Started sync with ${formatPercentage(\n              Math.min(1, cachedBlockCount / (targetBlockCount || 1)),\n            )} cached (contract=${source.contractName} network=${\n              this.network.name\n            })`,\n          });\n        } else {\n          // Factory\n          if (!isHistoricalSyncRequired) {\n            this.factoryChildAddressProgressTrackers[source.id] =\n              new ProgressTracker({\n                target: [startBlock, finalizedBlockNumber],\n                completed: [[startBlock, finalizedBlockNumber]],\n              });\n            this.factoryLogFilterProgressTrackers[source.id] =\n              new ProgressTracker({\n                target: [startBlock, finalizedBlockNumber],\n                completed: [[startBlock, finalizedBlockNumber]],\n              });\n            this.common.metrics.ponder_historical_total_blocks.set(\n              { network: this.network.name, contract: source.contractName },\n              0,\n            );\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Start block is in unfinalized range, skipping historical sync (contract=${source.contractName})`,\n            });\n            return;\n          }\n\n          // Note that factory child address progress is stored using\n          // log intervals for the factory log.\n          const completedFactoryChildAddressIntervals =\n            await this.syncStore.getLogFilterIntervals({\n              chainId: source.chainId,\n              logFilter: {\n                address: source.criteria.address,\n                topics: [source.criteria.eventSelector],\n              },\n            });\n          const factoryChildAddressProgressTracker = new ProgressTracker({\n            target: [startBlock, endBlock],\n            completed: completedFactoryChildAddressIntervals,\n          });\n          this.factoryChildAddressProgressTrackers[source.id] =\n            factoryChildAddressProgressTracker;\n\n          const requiredFactoryChildAddressIntervals =\n            factoryChildAddressProgressTracker.getRequired();\n          const factoryChildAddressTaskChunks = getChunks({\n            intervals: requiredFactoryChildAddressIntervals,\n            maxChunkSize:\n              source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n          });\n\n          for (const [fromBlock, toBlock] of factoryChildAddressTaskChunks) {\n            this.queue.addTask(\n              {\n                kind: \"FACTORY_CHILD_ADDRESS\",\n                factory: source,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n          if (factoryChildAddressTaskChunks.length > 0) {\n            const total = intervalSum(requiredFactoryChildAddressIntervals);\n            this.common.logger.debug({\n              service: \"historical\",\n              msg: `Added FACTORY_CHILD_ADDRESS tasks for ${total}-block range (factory=${source.id}, network=${this.network.name})`,\n            });\n          }\n\n          const targetFactoryChildAddressBlockCount = endBlock - startBlock + 1;\n          const cachedFactoryChildAddressBlockCount =\n            targetFactoryChildAddressBlockCount -\n            intervalSum(requiredFactoryChildAddressIntervals);\n\n          this.common.metrics.ponder_historical_total_blocks.set(\n            {\n              network: this.network.name,\n              contract: `${source.contractName}_factory`,\n            },\n            targetFactoryChildAddressBlockCount,\n          );\n          this.common.metrics.ponder_historical_cached_blocks.set(\n            {\n              network: this.network.name,\n              contract: `${source.contractName}_factory`,\n            },\n            cachedFactoryChildAddressBlockCount,\n          );\n\n          const completedFactoryLogFilterIntervals =\n            await this.syncStore.getFactoryLogFilterIntervals({\n              chainId: source.chainId,\n              factory: source.criteria,\n            });\n          const factoryLogFilterProgressTracker = new ProgressTracker({\n            target: [startBlock, endBlock],\n            completed: completedFactoryLogFilterIntervals,\n          });\n          this.factoryLogFilterProgressTrackers[source.id] =\n            factoryLogFilterProgressTracker;\n\n          // Only add factory log filter tasks for any intervals where the\n          // child address tasks are completed, but the factory log filter tasks are not,\n          // because these won't be added automatically by child address tasks.\n          const requiredFactoryLogFilterIntervals =\n            factoryLogFilterProgressTracker.getRequired();\n          const missingFactoryLogFilterIntervals = intervalDifference(\n            requiredFactoryLogFilterIntervals,\n            requiredFactoryChildAddressIntervals,\n          );\n\n          const missingFactoryLogFilterTaskChunks = getChunks({\n            intervals: missingFactoryLogFilterIntervals,\n            maxChunkSize:\n              source.maxBlockRange ?? this.network.defaultMaxBlockRange,\n          });\n\n          for (const [\n            fromBlock,\n            toBlock,\n          ] of missingFactoryLogFilterTaskChunks) {\n            this.queue.addTask(\n              {\n                kind: \"FACTORY_LOG_FILTER\",\n                factory: source,\n                fromBlock,\n                toBlock,\n              },\n              { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n            );\n          }\n          if (missingFactoryLogFilterTaskChunks.length > 0) {\n            const total = intervalSum(missingFactoryLogFilterIntervals);\n            this.common.logger.debug({\n              service: \"historical\",\n              msg: `Added FACTORY_LOG_FILTER tasks for ${total}-block range (contract=${source.contractName}, network=${this.network.name})`,\n            });\n          }\n\n          const targetFactoryLogFilterBlockCount = endBlock - startBlock + 1;\n          const cachedFactoryLogFilterBlockCount =\n            targetFactoryLogFilterBlockCount -\n            intervalSum(requiredFactoryLogFilterIntervals);\n\n          this.common.metrics.ponder_historical_total_blocks.set(\n            { network: this.network.name, contract: source.contractName },\n            targetFactoryLogFilterBlockCount,\n          );\n          this.common.metrics.ponder_historical_cached_blocks.set(\n            { network: this.network.name, contract: source.contractName },\n            cachedFactoryLogFilterBlockCount,\n          );\n\n          // Use factory log filter progress for the logger because it better represents\n          // user-facing progress.\n          const cacheRate = Math.min(\n            1,\n            cachedFactoryLogFilterBlockCount /\n              (targetFactoryLogFilterBlockCount || 1),\n          );\n          this.common.logger.info({\n            service: \"historical\",\n            msg: `Started sync with ${formatPercentage(\n              cacheRate,\n            )} cached (contract=${source.contractName} network=${\n              this.network.name\n            })`,\n          });\n        }\n      }),\n    );\n  }\n\n  start() {\n    this.common.metrics.ponder_historical_start_timestamp.set(Date.now());\n\n    // Emit status update logs on an interval for each active log filter.\n    this.progressLogInterval = setInterval(async () => {\n      const completionStats = await getHistoricalSyncStats({\n        metrics: this.common.metrics,\n        sources: this.sources,\n      });\n\n      completionStats.forEach(({ contract, rate, eta }) => {\n        if (rate === 1) return;\n        this.common.logger.info({\n          service: \"historical\",\n          msg: `Sync is ${formatPercentage(rate)} complete${\n            eta !== undefined ? ` with ~${formatEta(eta)} remaining` : \"\"\n          } (contract=${contract})`,\n          network: this.network.name,\n        });\n      });\n    }, 10_000);\n\n    // Edge case: If there are no tasks in the queue, this means the entire\n    // requested range was cached, so the sync is complete. However, we still\n    // need to emit the historicalCheckpoint event with some timestamp. It should\n    // be safe to use the current timestamp.\n    if (this.queue.size === 0) {\n      this.emit(\"historicalCheckpoint\", {\n        blockTimestamp: Math.round(Date.now() / 1000),\n        chainId: this.network.chainId,\n        blockNumber: this.finalizedBlockNumber,\n      });\n      clearInterval(this.progressLogInterval);\n      this.emit(\"syncComplete\");\n      this.common.logger.info({\n        service: \"historical\",\n        msg: `Completed sync (network=${this.network.name})`,\n        network: this.network.name,\n      });\n    }\n\n    this.queue.start();\n  }\n\n  kill = () => {\n    this.isShuttingDown = true;\n    clearInterval(this.progressLogInterval);\n    this.queue.pause();\n    this.queue.clear();\n    this.common.logger.debug({\n      service: \"historical\",\n      msg: `Killed historical sync service (network=${this.network.name})`,\n    });\n  };\n\n  onIdle = () =>\n    new Promise((resolve) =>\n      setImmediate(() => this.queue.onIdle().then(resolve)),\n    );\n\n  private buildQueue = () => {\n    const worker: Worker<HistoricalSyncTask> = async ({ task, queue }) => {\n      switch (task.kind) {\n        case \"LOG_FILTER\": {\n          await this.logFilterTaskWorker(task);\n          break;\n        }\n        case \"FACTORY_CHILD_ADDRESS\": {\n          await this.factoryChildAddressTaskWorker(task);\n          break;\n        }\n        case \"FACTORY_LOG_FILTER\": {\n          await this.factoryLogFilterTaskWorker(task);\n          break;\n        }\n        case \"BLOCK\": {\n          await this.blockTaskWorker(task);\n          break;\n        }\n      }\n\n      // If this is not the final task, return.\n      if (queue.size > 0 || queue.pending > 1) return;\n      // If this is the final task but the kill() method has been called, do nothing.\n      if (this.isShuttingDown) return;\n\n      // If this is the final task, run the cleanup/completion logic.\n      clearInterval(this.progressLogInterval);\n      this.emit(\"syncComplete\");\n      const startTimestamp =\n        (await this.common.metrics.ponder_historical_start_timestamp.get())\n          .values?.[0]?.value ?? Date.now();\n      const duration = Date.now() - startTimestamp;\n      this.common.logger.info({\n        service: \"historical\",\n        msg: `Completed sync in ${formatEta(duration)} (network=${\n          this.network.name\n        })`,\n      });\n    };\n\n    const queue = createQueue<HistoricalSyncTask>({\n      worker,\n      options: {\n        concurrency: this.network.maxHistoricalTaskConcurrency,\n        autoStart: false,\n      },\n      onError: ({ error, task, queue }) => {\n        if (this.isShuttingDown) return;\n\n        switch (task.kind) {\n          case \"LOG_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Log filter task failed, retrying... [${task.fromBlock}, ${\n                task.toBlock\n              }] (contract=${task.logFilter.contractName}, network=${\n                this.network.name\n              }, error=${`${error.name}: ${error.message}`})`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"FACTORY_CHILD_ADDRESS\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Factory child address task failed, retrying... [${\n                task.fromBlock\n              }, ${task.toBlock}] (contract=${\n                task.factory.contractName\n              }, network=${\n                this.network.name\n              }, error=${`${error.name}: ${error.message}`})`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"FACTORY_LOG_FILTER\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Factory log filter task failed, retrying... [${\n                task.fromBlock\n              }, ${task.toBlock}] (contract=${\n                task.factory.contractName\n              }, network=${\n                this.network.name\n              }, error=${`${error.name}: ${error.message}`})`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.fromBlock;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n          case \"BLOCK\": {\n            this.common.logger.warn({\n              service: \"historical\",\n              msg: `Block task failed, retrying... [${\n                task.blockNumber\n              }] (network=${\n                this.network.name\n              }, error=${`${error.name}: ${error.message}`})`,\n            });\n            const priority = Number.MAX_SAFE_INTEGER - task.blockNumber;\n            queue.addTask({ ...task }, { priority });\n            break;\n          }\n        }\n      },\n    });\n\n    return queue;\n  };\n\n  private logFilterTaskWorker = async ({\n    logFilter,\n    fromBlock,\n    toBlock,\n  }: LogFilterTask) => {\n    const logs = await this._eth_getLogs({\n      address: logFilter.criteria.address,\n      topics: logFilter.criteria.topics,\n      fromBlock: toHex(fromBlock),\n      toBlock: toHex(toBlock),\n    });\n\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n\n    for (const logInterval of logIntervals) {\n      const { startBlock, endBlock } = logInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock].push(async (block) => {\n        await this._insertLogFilterInterval({\n          logInterval,\n          logFilter: logFilter.criteria,\n          chainId: logFilter.chainId,\n          block,\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          { network: this.network.name, contract: logFilter.contractName },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.logFilterProgressTrackers[logFilter.id].addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed LOG_FILTER task adding ${logIntervals.length} BLOCK tasks [${fromBlock}, ${toBlock}] (contract=${logFilter.contractName}, network=${this.network.name})`,\n    });\n  };\n\n  private factoryLogFilterTaskWorker = async ({\n    factory,\n    fromBlock,\n    toBlock,\n  }: FactoryLogFilterTask) => {\n    const iterator = this.syncStore.getFactoryChildAddresses({\n      chainId: factory.chainId,\n      factory: factory.criteria,\n      upToBlockNumber: BigInt(toBlock),\n    });\n\n    const logs: RpcLog[] = [];\n    for await (const childContractAddressBatch of iterator) {\n      const _logs = await this._eth_getLogs({\n        address: childContractAddressBatch,\n        topics: factory.criteria.topics,\n        fromBlock: numberToHex(fromBlock),\n        toBlock: numberToHex(toBlock),\n      });\n      logs.push(..._logs);\n    }\n\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n\n    for (const logInterval of logIntervals) {\n      const { startBlock, endBlock, logs, transactionHashes } = logInterval;\n\n      if (this.blockCallbacks[endBlock] === undefined)\n        this.blockCallbacks[endBlock] = [];\n\n      this.blockCallbacks[endBlock].push(async (block) => {\n        await this.syncStore.insertFactoryLogFilterInterval({\n          chainId: factory.chainId,\n          factory: factory.criteria,\n          block,\n          transactions: block.transactions.filter((tx) =>\n            transactionHashes.has(tx.hash),\n          ),\n          logs,\n          interval: {\n            startBlock: BigInt(startBlock),\n            endBlock: BigInt(endBlock),\n          },\n        });\n\n        this.common.metrics.ponder_historical_completed_blocks.inc(\n          { network: this.network.name, contract: factory.contractName },\n          endBlock - startBlock + 1,\n        );\n      });\n    }\n\n    this.factoryLogFilterProgressTrackers[factory.id].addCompletedInterval([\n      fromBlock,\n      toBlock,\n    ]);\n\n    this.enqueueBlockTasks();\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed FACTORY_LOG_FILTER task adding ${logIntervals.length} BLOCK tasks [${fromBlock}, ${toBlock}] (contract=${factory.contractName}, network=${this.network.name})`,\n    });\n  };\n\n  private factoryChildAddressTaskWorker = async ({\n    factory,\n    fromBlock,\n    toBlock,\n  }: FactoryChildAddressTask) => {\n    const logs = await this._eth_getLogs({\n      address: factory.criteria.address,\n      topics: [factory.criteria.eventSelector],\n      fromBlock: toHex(fromBlock),\n      toBlock: toHex(toBlock),\n    });\n\n    // Insert the new child address logs into the store.\n    await this.syncStore.insertFactoryChildAddressLogs({\n      chainId: factory.chainId,\n      logs,\n    });\n\n    // Register block callbacks for the child address logs. This is how\n    // the intervals will be recorded (marking the child address logs as\n    // cached on subsequent starts).\n    const logIntervals = this.buildLogIntervals({ fromBlock, toBlock, logs });\n    for (const logInterval of logIntervals) {\n      if (this.blockCallbacks[logInterval.endBlock] === undefined)\n        this.blockCallbacks[logInterval.endBlock] = [];\n\n      this.blockCallbacks[logInterval.endBlock].push(async (block) => {\n        await this._insertLogFilterInterval({\n          logInterval,\n          logFilter: {\n            address: factory.criteria.address,\n            topics: [factory.criteria.eventSelector],\n          },\n          chainId: factory.chainId,\n          block,\n        });\n      });\n    }\n\n    // Update the checkpoint, and if necessary, enqueue factory log filter tasks.\n    const { isUpdated, prevCheckpoint, newCheckpoint } =\n      this.factoryChildAddressProgressTrackers[factory.id].addCompletedInterval(\n        [fromBlock, toBlock],\n      );\n    if (isUpdated) {\n      // It's possible for the factory log filter to have already completed some or\n      // all of the block interval here. To avoid duplicates, only add intervals that\n      // are still marked as required.\n      const requiredIntervals = intervalIntersection(\n        [[prevCheckpoint + 1, newCheckpoint]],\n        this.factoryLogFilterProgressTrackers[factory.id].getRequired(),\n      );\n      const factoryLogFilterChunks = getChunks({\n        intervals: requiredIntervals,\n        maxChunkSize:\n          factory.maxBlockRange ?? this.network.defaultMaxBlockRange,\n      });\n\n      for (const [fromBlock, toBlock] of factoryLogFilterChunks) {\n        this.queue.addTask(\n          {\n            kind: \"FACTORY_LOG_FILTER\",\n            factory,\n            fromBlock,\n            toBlock,\n          },\n          { priority: Number.MAX_SAFE_INTEGER - fromBlock },\n        );\n      }\n    }\n    this.common.metrics.ponder_historical_completed_blocks.inc(\n      {\n        network: this.network.name,\n        contract: `${factory.contractName}_factory`,\n      },\n      toBlock - fromBlock + 1,\n    );\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed FACTORY_CHILD_ADDRESS task [${fromBlock}, ${toBlock}] (contract=${factory.contractName}, network=${this.network.name})`,\n    });\n  };\n\n  private blockTaskWorker = async ({ blockNumber, callbacks }: BlockTask) => {\n    const block = await this._eth_getBlockByNumber({\n      blockNumber,\n    });\n\n    while (callbacks.length !== 0) {\n      await callbacks[callbacks.length - 1](block);\n      callbacks.pop()!;\n    }\n\n    const newBlockCheckpoint = this.blockProgressTracker.addCompletedBlock({\n      blockNumber,\n      blockTimestamp: hexToNumber(block.timestamp),\n    });\n\n    if (newBlockCheckpoint) {\n      this.emit(\"historicalCheckpoint\", {\n        blockTimestamp: newBlockCheckpoint.blockTimestamp,\n        chainId: this.network.chainId,\n        blockNumber: newBlockCheckpoint.blockNumber,\n      });\n    }\n\n    this.common.logger.trace({\n      service: \"historical\",\n      msg: `Completed BLOCK task ${hexToNumber(block.number!)} with ${\n        callbacks.length\n      } callbacks (network=${this.network.name})`,\n    });\n  };\n\n  private buildLogIntervals = ({\n    fromBlock,\n    toBlock,\n    logs,\n  }: {\n    fromBlock: number;\n    toBlock: number;\n    logs: RpcLog[];\n  }) => {\n    const logsByBlockNumber: Record<number, RpcLog[] | undefined> = {};\n    const txHashesByBlockNumber: Record<number, Set<Hash> | undefined> = {};\n\n    logs.forEach((log) => {\n      const blockNumber = hexToNumber(log.blockNumber!);\n      (txHashesByBlockNumber[blockNumber] ||= new Set<Hash>()).add(\n        log.transactionHash!,\n      );\n      (logsByBlockNumber[blockNumber] ||= []).push(log);\n    });\n\n    const requiredBlocks = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    // If toBlock is not already required, add it. This is necessary\n    // to mark the full block range of the eth_getLogs request as cached.\n    if (!requiredBlocks.includes(toBlock)) {\n      requiredBlocks.push(toBlock);\n    }\n\n    const requiredIntervals: {\n      startBlock: number;\n      endBlock: number;\n      logs: RpcLog[];\n      transactionHashes: Set<Hash>;\n    }[] = [];\n\n    let prev = fromBlock;\n    for (const blockNumber of requiredBlocks) {\n      requiredIntervals.push({\n        startBlock: prev,\n        endBlock: blockNumber,\n        logs: logsByBlockNumber[blockNumber] ?? [],\n        transactionHashes: txHashesByBlockNumber[blockNumber] ?? new Set(),\n      });\n      prev = blockNumber + 1;\n    }\n\n    return requiredIntervals;\n  };\n\n  private enqueueBlockTasks = () => {\n    const blockTasksCanBeEnqueuedTo = Math.min(\n      ...Object.values(this.logFilterProgressTrackers).map((i) =>\n        i.getCheckpoint(),\n      ),\n      ...Object.values(this.factoryChildAddressProgressTrackers).map((i) =>\n        i.getCheckpoint(),\n      ),\n      ...Object.values(this.factoryLogFilterProgressTrackers).map((i) =>\n        i.getCheckpoint(),\n      ),\n    );\n\n    if (blockTasksCanBeEnqueuedTo > this.blockTasksEnqueuedCheckpoint) {\n      const newBlocks = Object.keys(this.blockCallbacks)\n        .map(Number)\n        .filter((blockNumber) => blockNumber <= blockTasksCanBeEnqueuedTo);\n\n      this.blockProgressTracker.addPendingBlocks({ blockNumbers: newBlocks });\n\n      for (const blockNumber of newBlocks) {\n        this.queue.addTask(\n          {\n            kind: \"BLOCK\",\n            blockNumber,\n\n            callbacks: this.blockCallbacks[blockNumber],\n          },\n          { priority: Number.MAX_SAFE_INTEGER - blockNumber },\n        );\n        delete this.blockCallbacks[blockNumber];\n      }\n\n      this.common.logger.trace({\n        service: \"historical\",\n        msg: `Enqueued ${newBlocks.length} BLOCK tasks [${\n          this.blockTasksEnqueuedCheckpoint + 1\n        }, ${blockTasksCanBeEnqueuedTo}] (network=${this.network.name})`,\n      });\n\n      this.blockTasksEnqueuedCheckpoint = blockTasksCanBeEnqueuedTo;\n    }\n  };\n\n  /**\n   * Helper function for \"eth_getLogs\" rpc request.\n   * Handles different error types and retries the request if applicable.\n   */\n  private _eth_getLogs = (params: {\n    address?: Address | Address[];\n    topics?: Topics;\n    fromBlock: Hex;\n    toBlock: Hex;\n  }): Promise<RpcLog[]> => {\n    try {\n      return this.requestQueue.request({\n        method: \"eth_getLogs\",\n        params: [\n          {\n            fromBlock: params.fromBlock,\n            toBlock: params.toBlock,\n\n            topics: params.topics,\n            address: params.address\n              ? Array.isArray(params.address)\n                ? params.address.map((a) => toLowerCase(a))\n                : toLowerCase(params.address)\n              : undefined,\n          },\n        ],\n      });\n    } catch (err) {\n      const retryRanges = getLogFilterRetryRanges(\n        err as LogFilterError,\n        params.fromBlock,\n        params.toBlock,\n      );\n\n      return Promise.all(\n        retryRanges.map(([from, to]) =>\n          this._eth_getLogs({\n            fromBlock: from,\n            toBlock: to,\n            topics: params.topics,\n            address: params.address,\n          }),\n        ),\n      ).then((l) => l.flat());\n    }\n  };\n\n  /**\n   * Helper function for \"eth_getBlockByNumber\" request.\n   */\n  private _eth_getBlockByNumber = (params: {\n    blockNumber: number;\n  }): Promise<HistoricalBlock> =>\n    this.requestQueue\n      .request({\n        method: \"eth_getBlockByNumber\",\n        params: [numberToHex(params.blockNumber), true],\n      })\n      .then((block) => {\n        if (!block)\n          throw new BlockNotFoundError({\n            blockNumber: BigInt(params.blockNumber),\n          });\n        return block as HistoricalBlock;\n      });\n\n  /**\n   * Helper function for \"insertLogFilterInterval\"\n   */\n  private _insertLogFilterInterval = ({\n    logInterval: { transactionHashes, logs, startBlock, endBlock },\n    logFilter,\n    block,\n    chainId,\n  }: {\n    logInterval: LogInterval;\n    logFilter: LogFilterCriteria;\n    block: HistoricalBlock;\n    chainId: number;\n  }) =>\n    this.syncStore.insertLogFilterInterval({\n      chainId,\n      logFilter,\n      block,\n      transactions: block.transactions.filter((tx) =>\n        transactionHashes.has(tx.hash),\n      ),\n      logs,\n      interval: {\n        startBlock: BigInt(startBlock),\n        endBlock: BigInt(endBlock),\n      },\n    });\n}\n","import { getChunks } from \"@/utils/interval.js\";\nimport {\n  type Hex,\n  InvalidParamsRpcError,\n  LimitExceededRpcError,\n  type RpcError,\n  hexToNumber,\n  toHex,\n} from \"viem\";\n\nexport type LogFilterError = Partial<RpcError> & { name: string };\n\nexport type RetryRanges = [Hex, Hex][];\n\n/**\n * Returns the appropriate retry ranges given the emitted error.\n * Throws error when the error argument is unrecognized.\n */\nexport const getLogFilterRetryRanges = (\n  error: LogFilterError,\n  fromBlock: Hex,\n  toBlock: Hex,\n): RetryRanges => {\n  const retryRanges: RetryRanges = [];\n  if (\n    // Alchemy response size error.\n    error.code === InvalidParamsRpcError.code &&\n    error.details!.startsWith(\"Log response size exceeded.\")\n  ) {\n    const safe = error.details!.split(\"this block range should work: \")[1];\n    const safeStart = Number(safe.split(\", \")[0].slice(1));\n    const safeEnd = Number(safe.split(\", \")[1].slice(0, -1));\n\n    retryRanges.push([toHex(safeStart), toHex(safeEnd)]);\n    retryRanges.push([toHex(safeEnd + 1), toBlock]);\n  } else if (\n    // Another Alchemy response size error.\n    error.details?.includes(\"Response size is larger than 150MB limit\")\n  ) {\n    // No hint available, split into 10 equal ranges.\n    const from = hexToNumber(fromBlock);\n    const to = hexToNumber(toBlock);\n    const chunks = getChunks({\n      intervals: [[from, to]],\n      maxChunkSize: Math.round((to - from) / 10),\n    });\n    retryRanges.push(\n      ...chunks.map(([f, t]) => [toHex(f), toHex(t)] as RetryRanges[number]),\n    );\n  } else if (\n    // Infura block range limit error.\n    error.code === LimitExceededRpcError.code &&\n    error.details!.includes(\"query returned more than 10000 results\")\n  ) {\n    const safe = error.details!.split(\"Try with this block range \")[1];\n    const safeStart = Number(safe.split(\", \")[0].slice(1));\n    const safeEnd = Number(safe.split(\", \")[1].slice(0, -2));\n\n    retryRanges.push([toHex(safeStart), toHex(safeEnd)]);\n    retryRanges.push([toHex(safeEnd + 1), toBlock]);\n  } else if (\n    // Thirdweb block range limit error.\n    error.code === InvalidParamsRpcError.code &&\n    error.details!.includes(\"block range less than 20000\")\n  ) {\n    const midpoint = Math.floor(\n      (Number(toBlock) - Number(fromBlock)) / 2 + Number(fromBlock),\n    );\n\n    retryRanges.push([toHex(fromBlock), toHex(midpoint)]);\n    retryRanges.push([toHex(midpoint + 1), toBlock]);\n  } else if (\n    // Quicknode block range limit error (should never happen).\n    error.name === \"HttpRequestError\" &&\n    error.details!.includes(\n      \"eth_getLogs and eth_newFilter are limited to a 10,000 blocks range\",\n    )\n  ) {\n    const midpoint = Math.floor(\n      (Number(toBlock) - Number(fromBlock)) / 2 + Number(fromBlock),\n    );\n    retryRanges.push([fromBlock, toHex(midpoint)]);\n    retryRanges.push([toHex(midpoint + 1), toBlock]);\n  } else {\n    // Throw any unrecognized errors.\n    throw error;\n  }\n\n  return retryRanges;\n};\n","export function validateHistoricalBlockRange({\n  startBlock,\n  endBlock: userDefinedEndBlock,\n  finalizedBlockNumber,\n  latestBlockNumber,\n}: {\n  startBlock: number;\n  endBlock?: number;\n  finalizedBlockNumber: number;\n  latestBlockNumber: number;\n}) {\n  if (startBlock > latestBlockNumber) {\n    throw new Error(\n      `Start block number (${startBlock}) cannot be greater than latest block number (${latestBlockNumber}).\n         Are you sure the RPC endpoint is for the correct network?`,\n    );\n  }\n\n  if (startBlock > finalizedBlockNumber) {\n    // If the start block is in the unfinalized range, the historical sync is not needed.\n    // Set the checkpoint to the current timestamp, then return (don't create the queue).\n    return {\n      isHistoricalSyncRequired: false,\n      startBlock,\n      endBlock: userDefinedEndBlock,\n    } as const;\n  }\n\n  if (userDefinedEndBlock) {\n    if (userDefinedEndBlock < startBlock) {\n      throw new Error(\n        `End block number (${userDefinedEndBlock}) cannot be less than start block number (${startBlock}).\n           Are you sure the RPC endpoint is for the correct network?`,\n      );\n    }\n\n    if (userDefinedEndBlock > latestBlockNumber) {\n      throw new Error(\n        `End block number (${userDefinedEndBlock}) cannot be greater than latest block number (${latestBlockNumber}).\n           Are you sure the RPC endpoint is for the correct network?`,\n      );\n    }\n\n    if (userDefinedEndBlock > finalizedBlockNumber) {\n      throw new Error(\n        `End block number (${userDefinedEndBlock}) cannot be greater than finalized block number (${finalizedBlockNumber}).\n           Are you sure the RPC endpoint is for the correct network?`,\n      );\n    }\n  }\n\n  const resolvedEndBlock = userDefinedEndBlock ?? finalizedBlockNumber;\n\n  return {\n    isHistoricalSyncRequired: true,\n    startBlock,\n    endBlock: resolvedEndBlock,\n  } as const;\n}\n","import { wait } from \"./wait.js\";\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/38422ac7617022761ee7aa87310dd89adb34573c/src/utils/poll.ts\n\ntype PollOptions = {\n  // Whether or not to emit when the polling starts.\n  emitOnBegin?: boolean;\n  // The interval (in ms).\n  interval: number;\n};\n\n/**\n * @description Polls a function at a specified interval.\n */\nexport function poll(\n  fn: ({ unpoll }: { unpoll: () => void }) => Promise<unknown> | unknown,\n  { emitOnBegin, interval }: PollOptions,\n) {\n  let active = true;\n\n  const unwatch = () => (active = false);\n\n  const watch = async () => {\n    if (emitOnBegin) await fn({ unpoll: unwatch });\n    await wait(interval);\n\n    const poll = async () => {\n      if (!active) return;\n      await fn({ unpoll: unwatch });\n      await wait(interval);\n      poll();\n    };\n\n    poll();\n  };\n  watch();\n\n  return unwatch;\n}\n","/**\n * Generates an array of integers between two bounds. Exclusive on the right.\n *\n * @param start Integer to start at.\n * @param stop Integer to stop at (exclusive).\n */\nexport const range = (start: number, stop: number) =>\n  Array.from({ length: stop - start }, (_, i) => start + i);\n","import type { Common } from \"@/Ponder.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type Factory,\n  type LogFilter,\n  type Source,\n  sourceIsFactory,\n  sourceIsLogFilter,\n} from \"@/config/sources.js\";\nimport type { SyncStore } from \"@/sync-store/store.js\";\nimport { type Checkpoint, maxCheckpoint } from \"@/utils/checkpoint.js\";\nimport { dedupe } from \"@/utils/dedupe.js\";\nimport { Emittery } from \"@/utils/emittery.js\";\nimport { poll } from \"@/utils/poll.js\";\nimport { range } from \"@/utils/range.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  type Address,\n  BlockNotFoundError,\n  type Hex,\n  hexToNumber,\n  numberToHex,\n} from \"viem\";\nimport { isMatchedLogInBloomFilter } from \"./bloom.js\";\nimport { filterLogs } from \"./filter.js\";\nimport {\n  type LightBlock,\n  type LightLog,\n  type RealtimeBlock,\n  type RealtimeLog,\n  realtimeBlockToLightBlock,\n  realtimeLogToLightLog,\n} from \"./format.js\";\n\ntype RealtimeSyncEvents = {\n  realtimeCheckpoint: Checkpoint;\n  finalityCheckpoint: Checkpoint;\n  shallowReorg: Checkpoint;\n  deepReorg: { detectedAtBlockNumber: number; minimumDepth: number };\n  idle: undefined;\n  fatal: undefined;\n};\n\nexport class RealtimeSyncService extends Emittery<RealtimeSyncEvents> {\n  private common: Common;\n  private syncStore: SyncStore;\n  private network: Network;\n  private requestQueue: RequestQueue;\n  private sources: Source[];\n\n  /**\n   * Derived source state.\n   */\n  private hasFactorySource: boolean;\n  private logFilterSources: LogFilter[];\n  private factorySources: Factory[];\n  private address: Address[] | undefined;\n  private eventSelectors: Hex[];\n\n  private isProcessingBlock = false;\n  private isProcessBlockQueued = false;\n\n  private lastLogsPerBlock = 0;\n\n  /** Current finalized block. */\n  private finalizedBlock: LightBlock = undefined!;\n  /** Local representation of the unfinalized portion of the chain. */\n  private blocks: LightBlock[] = [];\n  private logs: LightLog[] = [];\n  /** Function to stop polling for new blocks. */\n  private unpoll = () => {};\n  /** If true, failed tasks should not log errors or be retried. */\n  private isShuttingDown = false;\n\n  constructor({\n    common,\n    syncStore,\n    network,\n    requestQueue,\n    sources = [],\n  }: {\n    common: Common;\n    syncStore: SyncStore;\n    network: Network;\n    requestQueue: RequestQueue;\n    sources?: Source[];\n  }) {\n    super();\n\n    this.common = common;\n    this.syncStore = syncStore;\n    this.network = network;\n    this.requestQueue = requestQueue;\n    this.sources = sources;\n\n    this.hasFactorySource = sources.some(sourceIsFactory);\n    this.logFilterSources = sources.filter(sourceIsLogFilter);\n    this.factorySources = sources.filter(sourceIsFactory);\n\n    const isAddressDefined = this.logFilterSources.every(\n      (source) => !!source.criteria.address,\n    );\n\n    // If all sources are log filters that define an address, we can pass an address\n    // param to our realtime eth_getLogs requests. But, if any of our sources are\n    // factories OR any of our log filter sources DON'T specify address, we can't narrow\n    // the address field and must pass undefined.\n    this.address =\n      !this.hasFactorySource && isAddressDefined\n        ? (sources.flatMap((source) => source.criteria.address) as Address[])\n        : undefined;\n\n    this.eventSelectors = sources.flatMap((source) => {\n      const topics: Hex[] = [];\n\n      if (sourceIsFactory(source)) {\n        topics.push(source.criteria.eventSelector);\n      }\n\n      const topic0 = source.criteria.topics?.[0];\n      if (topic0) {\n        if (Array.isArray(topic0)) topics.push(...topic0);\n        else topics.push(topic0);\n      } else {\n        topics.push(...(Object.keys(source.abiEvents.bySelector) as Hex[]));\n      }\n      return topics;\n    });\n  }\n\n  setup = async () => {\n    // Initialize state variables. Required when restarting the service.\n    this.blocks = [];\n    this.logs = [];\n\n    // Fetch the latest block, and remote chain Id for the network.\n    let latestBlock: RealtimeBlock;\n    let rpcChainId: number;\n    try {\n      [latestBlock, rpcChainId] = await Promise.all([\n        this._eth_getBlockByNumber(\"latest\"),\n        this.requestQueue\n          .request({ method: \"eth_chainId\" })\n          .then((c) => hexToNumber(c)),\n      ]);\n    } catch (error_) {\n      throw Error(\n        \"Failed to fetch initial realtime data. (Hint: Most likely the result of an incapable RPC provider)\",\n      );\n    }\n\n    if (rpcChainId !== this.network.chainId) {\n      this.common.logger.warn({\n        service: \"realtime\",\n        msg: `Remote chain ID (${rpcChainId}) does not match configured chain ID (${this.network.chainId}) for network \"${this.network.name}\"`,\n      });\n    }\n\n    const latestBlockNumber = hexToNumber(latestBlock.number);\n\n    this.common.logger.info({\n      service: \"realtime\",\n      msg: `Fetched latest block at ${latestBlockNumber} (network=${this.network.name})`,\n    });\n\n    this.common.metrics.ponder_realtime_is_connected.set(\n      { network: this.network.name },\n      1,\n    );\n\n    // Set the finalized block number according to the network's finality threshold.\n    // If the finality block count is greater than the latest block number, set to zero.\n    // Note: Doesn't handle the case when there are no finalized blocks\n    const finalizedBlockNumber = Math.max(\n      0,\n      latestBlockNumber - this.network.finalityBlockCount,\n    );\n\n    this.finalizedBlock = await this._eth_getBlockByNumber(\n      finalizedBlockNumber,\n    ).then(realtimeBlockToLightBlock);\n\n    return { latestBlockNumber, finalizedBlockNumber };\n  };\n\n  start = () => {\n    // If an endBlock is specified for every event source on this network, and the\n    // latest end blcock is less than the finalized block number, we can stop here.\n    // The service won't poll for new blocks and won't emit any events.\n    const endBlocks = this.sources.map((f) => f.endBlock);\n    if (\n      endBlocks.every(\n        (endBlock) =>\n          endBlock !== undefined && endBlock < this.finalizedBlock.number,\n      )\n    ) {\n      this.common.logger.warn({\n        service: \"realtime\",\n        msg: `No realtime contracts (network=${this.network.name})`,\n      });\n\n      this.emit(\"realtimeCheckpoint\", {\n        ...maxCheckpoint,\n        chainId: this.network.chainId,\n      });\n\n      this.common.metrics.ponder_realtime_is_connected.set(\n        { network: this.network.name },\n        0,\n      );\n\n      return;\n    }\n\n    // TODO: Subscriptions\n    this.unpoll = poll(\n      async () => {\n        await this.process();\n      },\n      { emitOnBegin: false, interval: this.network.pollingInterval },\n    );\n  };\n\n  kill = () => {\n    this.isShuttingDown = true;\n    this.unpoll();\n    this.common.logger.debug({\n      service: \"realtime\",\n      msg: `Killed realtime sync service (network=${this.network.name})`,\n    });\n  };\n\n  onIdle = () => {\n    if (!this.isProcessingBlock) return Promise.resolve();\n\n    return new Promise<void>((res) => {\n      this.on(\"idle\", res);\n    });\n  };\n\n  process = async () => {\n    if (this.isProcessingBlock) {\n      this.isProcessBlockQueued = true;\n      return;\n    }\n\n    this.isProcessingBlock = true;\n\n    for (let i = 0; i < 4; i++) {\n      try {\n        const block = await this._eth_getBlockByNumber(\"latest\");\n        await this.handleNewBlock(block);\n        break;\n      } catch (error_) {\n        const error = error_ as Error;\n        if (this.isShuttingDown) return;\n\n        this.common.logger.warn({\n          service: \"realtime\",\n          msg: `Realtime sync task failed (network=${\n            this.network.name\n          }, error=${`${error.name}: ${error.message}`})`,\n          network: this.network.name,\n        });\n\n        if (i === 3) this.emit(\"fatal\");\n      }\n    }\n\n    this.isProcessingBlock = false;\n\n    if (this.isProcessBlockQueued) {\n      this.isProcessBlockQueued = false;\n      await this.process();\n    } else {\n      this.emit(\"idle\");\n    }\n  };\n\n  /**\n   * 1) Determine sync algorithm to use.\n   * 2) Fetch new blocks and logs.\n   * 3) Check for re-org, if occurred evict forked blocks and logs, and re-run.\n   *    If not re-org, continue.\n   * 4) Add blocks, logs, and tx data to store.\n   * 5) Move finalized block forward if applicable, insert interval.\n   *\n   */\n  private handleNewBlock = async (newBlock: RealtimeBlock) => {\n    const latestLocalBlock = this.getLatestLocalBlock();\n\n    // We already saw and handled this block. No-op.\n    if (latestLocalBlock.hash === newBlock.hash) {\n      this.common.logger.trace({\n        service: \"realtime\",\n        msg: `Already processed block at ${hexToNumber(\n          newBlock.number,\n        )} (network=${this.network.name})`,\n      });\n\n      return;\n    }\n\n    const sync = this.determineSyncPath(newBlock);\n    const syncResult =\n      sync === \"traverse\"\n        ? await this.syncTraverse(newBlock)\n        : await this.syncBatch(newBlock);\n\n    if (!syncResult.reorg) {\n      await this.insertRealtimeBlocks(syncResult);\n\n      this.logs.push(...syncResult.logs.map(realtimeLogToLightLog));\n      this.blocks.push(...syncResult.blocks.map(realtimeBlockToLightBlock));\n    }\n\n    // If this block moves the finality checkpoint, remove now-finalized blocks from the local chain\n    // and mark data as cached in the store.\n\n    const latestBlockNumber = hexToNumber(newBlock.number);\n    const blockMovesFinality =\n      latestBlockNumber >=\n      this.finalizedBlock.number + 2 * this.network.finalityBlockCount;\n\n    let hasReorg = false;\n\n    if (\n      (blockMovesFinality &&\n        !this.isChainConsistent([this.finalizedBlock, ...this.blocks])) ||\n      syncResult.reorg\n    ) {\n      hasReorg = await this.reconcileReorg(latestBlockNumber);\n    }\n\n    if (hasReorg || syncResult.reorg) {\n      this.common.metrics.ponder_realtime_reorg_total.inc({\n        network: this.network.name,\n      });\n\n      this.isProcessBlockQueued = true;\n\n      return;\n    }\n\n    if (blockMovesFinality) {\n      const newFinalizedBlock = this.blocks.findLast(\n        (block) =>\n          block.number <= latestBlockNumber - this.network.finalityBlockCount,\n      );\n\n      // Note: double check this\n      if (newFinalizedBlock) {\n        this.blocks = this.blocks.filter(\n          (block) => block.number > newFinalizedBlock.number,\n        );\n        this.logs = this.logs.filter(\n          (log) => log.blockNumber > newFinalizedBlock.number,\n        );\n\n        // TODO: Update this to insert:\n        // 1) Log filter intervals\n        // 2) Factory contract intervals\n        // 3) Child filter intervals\n        await this.syncStore.insertRealtimeInterval({\n          chainId: this.network.chainId,\n          logFilters: this.logFilterSources.map((l) => l.criteria),\n          factories: this.factorySources.map((f) => f.criteria),\n          interval: {\n            startBlock: BigInt(this.finalizedBlock.number + 1),\n            endBlock: BigInt(newFinalizedBlock.number),\n          },\n        });\n\n        this.finalizedBlock = newFinalizedBlock;\n\n        this.emit(\"finalityCheckpoint\", {\n          blockTimestamp: newFinalizedBlock.timestamp,\n          chainId: this.network.chainId,\n          blockNumber: newFinalizedBlock.number,\n        });\n\n        this.common.logger.debug({\n          service: \"realtime\",\n          msg: `Updated finality checkpoint to ${newFinalizedBlock.number} (network=${this.network.name})`,\n        });\n      }\n    }\n\n    const newBlockNumber = hexToNumber(newBlock.number);\n    const newBlockTimestamp = hexToNumber(newBlock.timestamp);\n\n    this.emit(\"realtimeCheckpoint\", {\n      blockTimestamp: newBlockTimestamp,\n      chainId: this.network.chainId,\n      blockNumber: newBlockNumber,\n    });\n\n    this.common.metrics.ponder_realtime_latest_block_number.set(\n      { network: this.network.name },\n      newBlockNumber,\n    );\n    this.common.metrics.ponder_realtime_latest_block_timestamp.set(\n      { network: this.network.name },\n      newBlockTimestamp,\n    );\n\n    this.common.logger.debug({\n      service: \"realtime\",\n      msg: `Finished syncing new head block ${hexToNumber(\n        newBlock.number,\n      )} (network=${this.network.name})`,\n    });\n  };\n\n  /**\n   * Determine which sync algorithm to use.\n   */\n  determineSyncPath = (newBlock: RealtimeBlock): \"traverse\" | \"batch\" => {\n    if (this.hasFactorySource) return \"batch\";\n\n    const latestLocalBlock = this.getLatestLocalBlock();\n\n    const numBlocks = hexToNumber(newBlock.number) - latestLocalBlock.number;\n\n    // Probability of a log in a block\n    const pLog = Math.min(this.lastLogsPerBlock, 1);\n\n    const batchCost =\n      75 +\n      16 * numBlocks * pLog +\n      75 * Math.min(1, numBlocks / this.network.finalityBlockCount);\n\n    // Probability of no logs in the range of blocks\n    const pNoLogs = (1 - pLog) ** numBlocks;\n    const traverseCost = 16 * numBlocks + 75 * (1 - pNoLogs);\n\n    return batchCost > traverseCost ? \"traverse\" : \"batch\";\n  };\n\n  private syncTraverse = async (\n    newBlock: RealtimeBlock,\n  ): Promise<\n    | { blocks: RealtimeBlock[]; logs: RealtimeLog[]; reorg: false }\n    | { reorg: true }\n  > => {\n    const latestLocalBlock = this.getLatestLocalBlock();\n    const latestLocalBlockNumber = latestLocalBlock.number;\n\n    const newBlockNumber = hexToNumber(newBlock.number);\n\n    const missingBlockRange = range(latestLocalBlockNumber + 1, newBlockNumber);\n    const newBlocks = await Promise.all(\n      missingBlockRange.map(this._eth_getBlockByNumber),\n    );\n    newBlocks.push(newBlock);\n\n    // Detect re-org\n\n    if (!this.isChainConsistent([latestLocalBlock, ...newBlocks])) {\n      return { reorg: true };\n    }\n\n    const criteria = this.sources.map((s) => s.criteria);\n    // Don't attempt to skip \"eth_getLogs\" if a factory source is present.\n    // Note: this may not be a possible path depending on the implementation of \"determineSyncPath\".\n    const canSkipGetLogs =\n      !this.hasFactorySource &&\n      newBlocks.every(\n        (block) =>\n          !isMatchedLogInBloomFilter({\n            bloom: block.logsBloom,\n            logFilters: criteria,\n          }),\n      );\n\n    if (canSkipGetLogs) return { blocks: newBlocks, logs: [], reorg: false };\n\n    const logs = await this._eth_getLogs({\n      fromBlock: numberToHex(latestLocalBlockNumber + 1),\n      toBlock: numberToHex(newBlockNumber),\n    });\n\n    const matchedLogs = await this.getMatchedLogs(\n      logs,\n      BigInt(newBlockNumber),\n      true,\n    );\n\n    return { blocks: newBlocks, logs: matchedLogs, reorg: false };\n  };\n\n  private syncBatch = async (\n    newBlock: RealtimeBlock,\n  ): Promise<{\n    blocks: RealtimeBlock[];\n    logs: RealtimeLog[];\n    reorg: false;\n  }> => {\n    const latestLocalBlock = this.getLatestLocalBlock();\n    const latestLocalBlockNumber = latestLocalBlock.number;\n\n    const newBlockNumber = hexToNumber(newBlock.number);\n\n    // Get logs\n    const logs = await this._eth_getLogs({\n      fromBlock: numberToHex(latestLocalBlockNumber + 1),\n      toBlock: newBlock.number,\n    });\n\n    const matchedLogs = await this.getMatchedLogs(\n      logs,\n      BigInt(newBlockNumber),\n      true,\n    );\n\n    // Get blocks\n    const missingBlockNumbers = dedupe(\n      matchedLogs.map((log) => log.blockNumber!),\n    ).filter((b) => b !== newBlock.number);\n\n    const blocks = await Promise.all(\n      missingBlockNumbers.map(this._eth_getBlockByNumber),\n    );\n    blocks.push(newBlock);\n\n    return { blocks: blocks, logs: matchedLogs, reorg: false };\n  };\n\n  /**\n   * Check if a re-org occurred by comparing remote logs to local.\n   *\n   * @returns True if a re-org has occurred.\n   */\n  reconcileReorg = async (latestBlockNumber: number) => {\n    const logs = await this._eth_getLogs({\n      fromBlock: numberToHex(this.finalizedBlock.number + 1),\n      toBlock: numberToHex(latestBlockNumber),\n    });\n\n    const matchedLogs = await this.getMatchedLogs(\n      logs,\n      BigInt(latestBlockNumber),\n      false,\n    );\n\n    const localLogs = this.logs.filter(\n      (log) => log.blockNumber <= latestBlockNumber,\n    );\n\n    /**\n     * Common ancestor is the block directly before the logs diverge.\n     * If the divergence occurred at index 0, check for deep re-org.\n     */\n    const handleReorg = async (nonMatchingIndex: number) => {\n      if (nonMatchingIndex === 0) {\n        const hasDeepReorg = await this.reconcileDeepReorg(latestBlockNumber);\n\n        if (hasDeepReorg) return;\n\n        this.blocks = [];\n        this.logs = [];\n\n        await this.syncStore.deleteRealtimeData({\n          chainId: this.network.chainId,\n          fromBlock: BigInt(this.finalizedBlock.number),\n        });\n\n        this.emit(\"shallowReorg\", {\n          blockTimestamp: this.finalizedBlock.timestamp,\n          chainId: this.network.chainId,\n          blockNumber: this.finalizedBlock.number,\n        });\n\n        const depth = latestBlockNumber - this.finalizedBlock.number;\n        this.common.logger.warn({\n          service: \"realtime\",\n          msg: `Detected ${depth}-block reorg with common ancestor ${this.finalizedBlock.number} (network=${this.network.name})`,\n        });\n      } else {\n        const ancestorBlockHash = localLogs[nonMatchingIndex - 1].blockHash;\n        const commonAncestor = this.blocks.find(\n          (block) => block.hash === ancestorBlockHash,\n        )!;\n\n        this.blocks = this.blocks.filter(\n          (block) => block.number <= commonAncestor.number,\n        );\n        this.logs = this.logs.filter(\n          (log) => log.blockNumber <= commonAncestor.number,\n        );\n\n        await this.syncStore.deleteRealtimeData({\n          chainId: this.network.chainId,\n          fromBlock: BigInt(commonAncestor.number),\n        });\n\n        this.emit(\"shallowReorg\", {\n          blockTimestamp: commonAncestor.timestamp,\n          chainId: this.network.chainId,\n          blockNumber: commonAncestor.number,\n        });\n\n        const depth = latestBlockNumber - commonAncestor.number;\n        this.common.logger.warn({\n          service: \"realtime\",\n          msg: `Detected ${depth}-block reorg with common ancestor ${commonAncestor.number} (network=${this.network.name})`,\n        });\n      }\n    };\n\n    let i = 0;\n    for (; i < localLogs.length && i < matchedLogs.length; i++) {\n      const lightMatchedLog = realtimeLogToLightLog(matchedLogs[i]);\n      if (lightMatchedLog.blockHash !== localLogs[i].blockHash) {\n        handleReorg(i);\n        return true;\n      }\n    }\n\n    if (localLogs.length !== matchedLogs.length) {\n      handleReorg(i);\n      return true;\n    }\n\n    // If there are no logs to compare, must make sure a deep re-org didn't occur.\n    if (localLogs.length === 0) {\n      return await this.reconcileDeepReorg(latestBlockNumber);\n    } else return false;\n  };\n\n  /**\n   * Check if deep re-org occured by comparing remote \"finalized\" block to local.\n   */\n  private reconcileDeepReorg = async (latestBlockNumber: number) => {\n    const remoteFinalizedBlock = await this._eth_getBlockByNumber(\n      this.finalizedBlock.number,\n    );\n\n    if (remoteFinalizedBlock.hash !== this.finalizedBlock.hash) {\n      this.emit(\"deepReorg\", {\n        detectedAtBlockNumber: latestBlockNumber,\n        minimumDepth: latestBlockNumber - this.blocks[0].number,\n      });\n\n      this.common.logger.warn({\n        service: \"realtime\",\n        msg: `Unable to reconcile >${\n          latestBlockNumber - this.blocks[0].number\n        }-block reorg (network=${this.network.name})`,\n      });\n\n      this.emit(\"fatal\");\n\n      this.blocks = [];\n      this.logs = [];\n\n      this.finalizedBlock = realtimeBlockToLightBlock(remoteFinalizedBlock);\n\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Helper function for \"eth_getBlockByNumber\" request.\n   */\n  private _eth_getBlockByNumber = (\n    block: \"latest\" | Hex | number,\n  ): Promise<RealtimeBlock> =>\n    this.requestQueue\n      .request({\n        method: \"eth_getBlockByNumber\",\n        params: [typeof block === \"number\" ? numberToHex(block) : block, true],\n      })\n      .then((block) => {\n        if (!block) throw new BlockNotFoundError({});\n        return block as RealtimeBlock;\n      });\n\n  /**\n   * Helper function for \"eth_getLogs\" rpc request.\n   *\n   * Note: Consider handling different error types and retry the request if applicable.\n   */\n  private _eth_getLogs = (params: {\n    fromBlock: Hex;\n    toBlock: Hex;\n  }): Promise<RealtimeLog[]> =>\n    this.requestQueue.request({\n      method: \"eth_getLogs\",\n      params: [\n        {\n          fromBlock: params.fromBlock,\n          toBlock: params.toBlock,\n          address: this.address,\n          topics: [this.eventSelectors],\n        },\n      ],\n    }) as Promise<RealtimeLog[]>;\n\n  private insertRealtimeBlocks = async ({\n    logs,\n    blocks,\n  }: { logs: RealtimeLog[]; blocks: RealtimeBlock[] }) => {\n    for (const block of blocks) {\n      const blockLogs = logs.filter((l) => l.blockNumber === block.number);\n\n      if (blockLogs.length === 0) continue;\n\n      const requiredTransactionHashes = new Set(\n        blockLogs.map((l) => l.transactionHash),\n      );\n      const blockTransactions = block.transactions.filter((t) =>\n        requiredTransactionHashes.has(t.hash),\n      );\n\n      // TODO: Maybe rename or at least document behavior\n      await this.syncStore.insertRealtimeBlock({\n        chainId: this.network.chainId,\n        block: block,\n        transactions: blockTransactions,\n        logs: blockLogs,\n      });\n\n      const matchedLogCountText =\n        blockLogs.length === 1\n          ? \"1 matched log\"\n          : `${blockLogs.length} matched logs`;\n      this.common.logger.info({\n        service: \"realtime\",\n        msg: `Synced ${matchedLogCountText} from block ${hexToNumber(\n          block.number,\n        )} (network=${this.network.name})`,\n      });\n    }\n\n    this.lastLogsPerBlock = logs.length / blocks.length;\n  };\n\n  private getMatchedLogs = async (\n    logs: RealtimeLog[],\n    toBlockNumber: bigint,\n    insertChildAddress: boolean,\n  ): Promise<RealtimeLog[]> => {\n    if (!this.hasFactorySource) {\n      return filterLogs({\n        logs,\n        logFilters: this.sources.map((s) => s.criteria),\n      });\n    } else {\n      // Find and insert any new child contracts.\n      const matchedFactoryLogs = filterLogs({\n        logs,\n        logFilters: this.factorySources.map((fs) => ({\n          address: fs.criteria.address,\n          topics: [fs.criteria.eventSelector],\n        })),\n      });\n\n      if (insertChildAddress) {\n        await this.syncStore.insertFactoryChildAddressLogs({\n          chainId: this.network.chainId,\n          logs: matchedFactoryLogs,\n        });\n      }\n\n      // Find any logs matching log filters or child contract filters.\n      // NOTE: It might make sense to just insert all logs rather than introduce\n      // a potentially slow DB operation here. It's a tradeoff between sync\n      // latency and database growth.\n      // NOTE: Also makes sense to hold factoryChildAddresses in memory rather than\n      // a query each interval.\n      const factoryLogFilters = await Promise.all(\n        this.factorySources.map(async (factory) => {\n          const iterator = this.syncStore.getFactoryChildAddresses({\n            chainId: this.network.chainId,\n            factory: factory.criteria,\n            upToBlockNumber: toBlockNumber,\n          });\n          const childContractAddresses: Address[] = [];\n          for await (const batch of iterator) {\n            childContractAddresses.push(...batch);\n          }\n          return {\n            address: childContractAddresses,\n            topics: factory.criteria.topics,\n          };\n        }),\n      );\n\n      return filterLogs({\n        logs,\n        logFilters: [\n          ...this.logFilterSources.map((l) => l.criteria),\n          ...factoryLogFilters,\n        ],\n      });\n    }\n  };\n\n  /** Returns true if \"blocks\" has a valid chain of block.parentHash to block.hash. */\n  private isChainConsistent = (\n    blocks: (LightBlock | RealtimeBlock)[],\n  ): boolean => {\n    for (let i = blocks.length - 1; i > 1; i--) {\n      if (blocks[i].parentHash !== blocks[i - 1].hash) return false;\n    }\n    return true;\n  };\n\n  private getLatestLocalBlock = (): LightBlock =>\n    this.blocks[this.blocks.length - 1] ?? this.finalizedBlock;\n}\n","import {\n  isContractAddressInBloom,\n  isTopicInBloom,\n} from \"ethereum-bloom-filters\";\nimport type { Address, Hex } from \"viem\";\n\nimport type { Topics } from \"@/config/sources.js\";\n\nexport function isMatchedLogInBloomFilter({\n  bloom,\n  logFilters,\n}: {\n  bloom: Hex;\n  logFilters: {\n    address?: Address | Address[];\n    topics?: Topics;\n  }[];\n}) {\n  const allAddresses: Address[] = [];\n  logFilters.forEach((logFilter) => {\n    const address =\n      logFilter.address === undefined\n        ? []\n        : Array.isArray(logFilter.address)\n          ? logFilter.address\n          : [logFilter.address];\n    allAddresses.push(...address);\n  });\n  if (allAddresses.some((a) => isContractAddressInBloom(bloom, a))) {\n    return true;\n  }\n\n  const allTopics: Hex[] = [];\n  logFilters.forEach((logFilter) => {\n    logFilter.topics?.forEach((topic) => {\n      if (topic === null) return;\n      if (Array.isArray(topic)) allTopics.push(...topic);\n      else allTopics.push(topic);\n    });\n  });\n  if (allTopics.some((a) => isTopicInBloom(bloom, a))) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Topics } from \"@/config/sources.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { type Address, type Hex } from \"viem\";\nimport type { RealtimeLog } from \"./format.js\";\n\nexport function filterLogs({\n  logs,\n  logFilters,\n}: {\n  logs: RealtimeLog[];\n  logFilters: {\n    address?: Address | Address[];\n    topics?: Topics;\n  }[];\n}) {\n  return logs.filter((log) => {\n    for (const { address, topics } of logFilters) {\n      if (isLogMatchedByFilter({ log, address, topics })) return true;\n    }\n    return false;\n  });\n}\n\nexport function isLogMatchedByFilter({\n  log,\n  address,\n  topics,\n}: {\n  log: {\n    address: Address;\n    topics: Hex[];\n  };\n  address?: Address | Address[];\n  topics?: Topics;\n}) {\n  const logAddress = toLowerCase(log.address);\n\n  if (address !== undefined && address.length > 0) {\n    if (Array.isArray(address)) {\n      if (!address.includes(logAddress)) return false;\n    } else {\n      if (logAddress !== address) return false;\n    }\n  }\n\n  if (topics) {\n    for (const [index, topic] of topics.entries()) {\n      if (topic === null) continue;\n      if (Array.isArray(topic)) {\n        if (!topic.includes(log.topics[index])) return false;\n      } else {\n        if (log.topics[index] !== topic) return false;\n      }\n    }\n  }\n\n  return true;\n}\n","import {\n  type Block,\n  type BlockTag,\n  type Hex,\n  type Log,\n  type RpcBlock,\n  hexToNumber,\n} from \"viem\";\n\nexport type RealtimeBlock = RpcBlock<Exclude<BlockTag, \"pending\">, true>;\nexport type RealtimeLog = Log<Hex, Hex, false>;\n\nexport type LightBlock = Pick<\n  Block<number, boolean, Exclude<BlockTag, \"pending\">>,\n  \"hash\" | \"parentHash\" | \"number\" | \"timestamp\"\n>;\nexport type LightLog = Pick<\n  Log<number, Hex, false>,\n  \"blockHash\" | \"blockNumber\"\n>;\n\nexport const realtimeBlockToLightBlock = ({\n  hash,\n  parentHash,\n  number,\n  timestamp,\n}: RealtimeBlock): LightBlock => ({\n  hash,\n  parentHash,\n  number: hexToNumber(number),\n  timestamp: hexToNumber(timestamp),\n});\n\nexport const realtimeLogToLightLog = ({\n  blockHash,\n  blockNumber,\n}: RealtimeLog): LightLog => ({\n  blockHash,\n  blockNumber: hexToNumber(blockNumber),\n});\n","import type { Address, Hex } from \"viem\";\n\nimport type { FactoryCriteria, LogFilterCriteria } from \"@/config/sources.js\";\n\n/**\n * Generates log filter fragments from a log filter.\n *\n * @param logFilter Log filter to be decompose into fragments.\n * @returns A list of log filter fragments.\n */\nexport function buildLogFilterFragments({\n  address,\n  topics,\n  chainId,\n}: LogFilterCriteria & {\n  chainId: number;\n}) {\n  return buildFragments({\n    address,\n    topics,\n    chainId,\n    idCallback: (address_, topic0_, topic1_, topic2_, topic3_) =>\n      `${chainId}_${address_}_${topic0_}_${topic1_}_${topic2_}_${topic3_}`,\n  });\n}\n\n/**\n * Generates factory fragments from a factory.\n *\n * @param factory Factory to be decomposed into fragments.\n * @returns A list of factory fragments.\n */\nexport function buildFactoryFragments({\n  address,\n  topics,\n  childAddressLocation,\n  eventSelector,\n  chainId,\n}: FactoryCriteria & {\n  chainId: number;\n}) {\n  const fragments = buildFragments({\n    address,\n    topics,\n    chainId,\n    childAddressLocation,\n    eventSelector,\n    idCallback: (address_, topic0_, topic1_, topic2_, topic3_) =>\n      `${chainId}_${address_}_${eventSelector}_${childAddressLocation}_${topic0_}_${topic1_}_${topic2_}_${topic3_}`,\n  });\n\n  return fragments as ((typeof fragments)[number] &\n    Pick<\n      FactoryCriteria,\n      \"eventSelector\" | \"childAddressLocation\" | \"address\"\n    >)[];\n}\n\nfunction buildFragments({\n  address,\n  topics,\n  chainId,\n  idCallback,\n  ...rest\n}: (LogFilterCriteria | FactoryCriteria) & {\n  idCallback: (\n    address: Address | null,\n    topic0: ReturnType<typeof parseTopics>[\"topic0\"],\n    topic1: ReturnType<typeof parseTopics>[\"topic1\"],\n    topic2: ReturnType<typeof parseTopics>[\"topic2\"],\n    topic3: ReturnType<typeof parseTopics>[\"topic3\"],\n  ) => string;\n  chainId: number;\n}) {\n  const fragments: {\n    id: string;\n    chainId: number;\n    address: Hex | null;\n    topic0: Hex | null;\n    topic1: Hex | null;\n    topic2: Hex | null;\n    topic3: Hex | null;\n  }[] = [];\n\n  const { topic0, topic1, topic2, topic3 } = parseTopics(topics);\n\n  for (const address_ of Array.isArray(address) ? address : [address ?? null]) {\n    for (const topic0_ of Array.isArray(topic0) ? topic0 : [topic0]) {\n      for (const topic1_ of Array.isArray(topic1) ? topic1 : [topic1]) {\n        for (const topic2_ of Array.isArray(topic2) ? topic2 : [topic2]) {\n          for (const topic3_ of Array.isArray(topic3) ? topic3 : [topic3]) {\n            fragments.push({\n              id: idCallback(address_, topic0_, topic1_, topic2_, topic3_),\n              ...rest,\n              chainId,\n              address: address_,\n              topic0: topic0_,\n              topic1: topic1_,\n              topic2: topic2_,\n              topic3: topic3_,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return fragments;\n}\n\nfunction parseTopics(topics: (Hex | Hex[] | null)[] | undefined) {\n  return {\n    topic0: topics?.[0] ?? null,\n    topic1: topics?.[1] ?? null,\n    topic2: topics?.[2] ?? null,\n    topic3: topics?.[3] ?? null,\n  } as {\n    topic0: Hex | Hex[] | null;\n    topic1: Hex | Hex[] | null;\n    topic2: Hex | Hex[] | null;\n    topic3: Hex | Hex[] | null;\n  };\n}\n","import type { Common } from \"@/Ponder.js\";\nimport type { FactoryCriteria, LogFilterCriteria } from \"@/config/sources.js\";\nimport type { Block, Log, Transaction } from \"@/types/eth.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport type { Checkpoint } from \"@/utils/checkpoint.js\";\nimport {\n  buildFactoryFragments,\n  buildLogFilterFragments,\n} from \"@/utils/fragments.js\";\nimport { intervalIntersectionMany, intervalUnion } from \"@/utils/interval.js\";\nimport { range } from \"@/utils/range.js\";\nimport {\n  type ExpressionBuilder,\n  Kysely,\n  Migrator,\n  PostgresDialect,\n  type Transaction as KyselyTransaction,\n  sql,\n} from \"kysely\";\nimport type { Pool } from \"pg\";\nimport {\n  type Hex,\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  checksumAddress,\n} from \"viem\";\nimport type { SyncStore } from \"../store.js\";\nimport {\n  type SyncStoreTables,\n  rpcToPostgresBlock,\n  rpcToPostgresLog,\n  rpcToPostgresTransaction,\n} from \"./format.js\";\nimport { migrationProvider } from \"./migrations.js\";\n\nexport class PostgresSyncStore implements SyncStore {\n  common: Common;\n  kind = \"postgres\" as const;\n  db: Kysely<SyncStoreTables>;\n  migrator: Migrator;\n\n  constructor({ common, pool }: { common: Common; pool: Pool }) {\n    this.common = common;\n    this.db = new Kysely<SyncStoreTables>({\n      dialect: new PostgresDialect({ pool }),\n      log(event) {\n        if (event.level === \"query\") {\n          common.metrics.ponder_postgres_query_count?.inc({ kind: \"sync\" });\n        }\n      },\n    });\n\n    this.migrator = new Migrator({\n      db: this.db,\n      provider: migrationProvider,\n      migrationTableSchema: \"public\",\n    });\n  }\n\n  async kill() {\n    try {\n      await this.db.destroy();\n    } catch (e) {\n      const error = e as Error;\n      if (error.message !== \"Called end on pool more than once\") {\n        throw error;\n      }\n    }\n  }\n\n  migrateUp = async () => {\n    const start = performance.now();\n\n    const { error } = await this.migrator.migrateToLatest();\n    if (error) throw error;\n\n    this.record(\"migrateUp\", start);\n  };\n\n  insertLogFilterInterval = async ({\n    chainId,\n    logFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values({ ...rpcToPostgresBlock(rpcBlock), chainId })\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n\n      if (rpcTransactions.length > 0) {\n        await tx\n          .insertInto(\"transactions\")\n          .values(\n            rpcTransactions.map((transaction) => ({\n              ...rpcToPostgresTransaction(transaction),\n              chainId,\n            })),\n          )\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n\n      if (rpcLogs.length > 0) {\n        await tx\n          .insertInto(\"logs\")\n          .values(\n            rpcLogs.map((log) => ({\n              ...rpcToPostgresLog(log),\n              chainId,\n            })),\n          )\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n\n      await this._insertLogFilterInterval({\n        tx,\n        chainId,\n        logFilters: [logFilter],\n        interval,\n      });\n    });\n\n    this.record(\"insertLogFilterInterval\", start);\n  };\n\n  getLogFilterIntervals = async ({\n    chainId,\n    logFilter,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n  }) => {\n    const start = performance.now();\n\n    const fragments = buildLogFilterFragments({ ...logFilter, chainId });\n\n    // First, attempt to merge overlapping and adjacent intervals.\n    await Promise.all(\n      fragments.map(async (fragment) => {\n        return await this.transaction(async (tx) => {\n          const { id: logFilterId } = await tx\n            .insertInto(\"logFilters\")\n            .values(fragment)\n            .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n            .returningAll()\n            .executeTakeFirstOrThrow();\n\n          const existingIntervalRows = await tx\n            .deleteFrom(\"logFilterIntervals\")\n            .where(\"logFilterId\", \"=\", logFilterId)\n            .returningAll()\n            .execute();\n\n          const mergedIntervals = intervalUnion(\n            existingIntervalRows.map((i) => [\n              Number(i.startBlock),\n              Number(i.endBlock),\n            ]),\n          );\n\n          const mergedIntervalRows = mergedIntervals.map(\n            ([startBlock, endBlock]) => ({\n              logFilterId,\n              startBlock: BigInt(startBlock),\n              endBlock: BigInt(endBlock),\n            }),\n          );\n\n          if (mergedIntervalRows.length > 0) {\n            await tx\n              .insertInto(\"logFilterIntervals\")\n              .values(mergedIntervalRows)\n              .execute();\n          }\n\n          return mergedIntervals;\n        });\n      }),\n    );\n\n    const intervals = await this.db\n      .with(\n        \"logFilterFragments(fragmentId, fragmentAddress, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3)\",\n        () =>\n          sql`( values ${sql.join(\n            fragments.map(\n              (f) =>\n                sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                  f.topic0,\n                )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                  f.topic3,\n                )} )`,\n            ),\n          )} )`,\n      )\n      .selectFrom(\"logFilterIntervals\")\n      .leftJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n      .innerJoin(\"logFilterFragments\", (join) => {\n        let baseJoin = join.on(({ or, cmpr }) =>\n          or([\n            cmpr(\"address\", \"is\", null),\n            cmpr(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n          ]),\n        );\n        for (const idx_ of range(0, 4)) {\n          baseJoin = baseJoin.on(({ or, cmpr }) => {\n            const idx = idx_ as 0 | 1 | 2 | 3;\n            return or([\n              cmpr(`topic${idx}`, \"is\", null),\n              cmpr(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n            ]);\n          });\n        }\n\n        return baseJoin;\n      })\n      .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n      .where(\"chainId\", \"=\", chainId)\n      .execute();\n\n    const intervalsByFragment = intervals.reduce(\n      (acc, cur) => {\n        const { fragmentId, ...rest } = cur;\n        acc[fragmentId] ||= [];\n        acc[fragmentId].push(rest);\n        return acc;\n      },\n      {} as Record<string, { startBlock: bigint; endBlock: bigint }[]>,\n    );\n\n    const fragmentIntervals = fragments.map((f) => {\n      return (intervalsByFragment[f.id] ?? []).map(\n        (r) =>\n          [Number(r.startBlock), Number(r.endBlock)] satisfies [number, number],\n      );\n    });\n\n    const intersectIntervals = intervalIntersectionMany(fragmentIntervals);\n\n    this.record(\"getLogFilterIntervals\", start);\n\n    return intersectIntervals;\n  };\n\n  insertFactoryChildAddressLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: RpcLog[];\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      if (rpcLogs.length > 0) {\n        await tx\n          .insertInto(\"logs\")\n          .values(\n            rpcLogs.map((log) => ({\n              ...rpcToPostgresLog(log),\n              chainId,\n            })),\n          )\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n    });\n\n    this.record(\"insertFactoryChildAddressLogs\", start);\n  };\n\n  async *getFactoryChildAddresses({\n    chainId,\n    upToBlockNumber,\n    factory,\n    pageSize = 500,\n  }: {\n    chainId: number;\n    upToBlockNumber: bigint;\n    factory: FactoryCriteria;\n    pageSize?: number;\n  }) {\n    const start = performance.now();\n\n    const { address, eventSelector, childAddressLocation } = factory;\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({ childAddressLocation });\n\n    const baseQuery = this.db\n      .selectFrom(\"logs\")\n      .select([selectChildAddressExpression.as(\"childAddress\"), \"blockNumber\"])\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"address\", \"=\", address)\n      .where(\"topic0\", \"=\", eventSelector)\n      .where(\"blockNumber\", \"<=\", upToBlockNumber)\n      .limit(pageSize);\n\n    let cursor: bigint | undefined = undefined;\n\n    while (true) {\n      let query = baseQuery;\n\n      if (cursor) {\n        query = query.where(\"blockNumber\", \">\", cursor);\n      }\n\n      const batch = await query.execute();\n\n      const lastRow = batch[batch.length - 1];\n      if (lastRow) {\n        cursor = lastRow.blockNumber;\n      }\n\n      if (batch.length > 0) {\n        yield batch.map((a) => a.childAddress);\n      }\n\n      if (batch.length < pageSize) break;\n    }\n\n    this.record(\"getFactoryChildAddresses\", start);\n  }\n\n  insertFactoryLogFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values({ ...rpcToPostgresBlock(rpcBlock), chainId })\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n\n      for (const rpcTransaction of rpcTransactions) {\n        await tx\n          .insertInto(\"transactions\")\n          .values({ ...rpcToPostgresTransaction(rpcTransaction), chainId })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n\n      for (const rpcLog of rpcLogs) {\n        await tx\n          .insertInto(\"logs\")\n          .values({ ...rpcToPostgresLog(rpcLog), chainId })\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n\n      await this._insertFactoryLogFilterInterval({\n        tx,\n        chainId,\n        factories: [factory],\n        interval,\n      });\n    });\n\n    this.record(\"insertFactoryLogFilterInterval\", start);\n  };\n\n  getFactoryLogFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryCriteria;\n  }) => {\n    const start = performance.now();\n\n    const fragments = buildFactoryFragments({\n      ...factory,\n      chainId,\n    });\n\n    await Promise.all(\n      fragments.map(async (fragment) => {\n        await this.transaction(async (tx) => {\n          const { id: factoryId } = await tx\n            .insertInto(\"factories\")\n            .values(fragment)\n            .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n            .returningAll()\n            .executeTakeFirstOrThrow();\n\n          const existingIntervals = await tx\n            .deleteFrom(\"factoryLogFilterIntervals\")\n            .where(\"factoryId\", \"=\", factoryId)\n            .returningAll()\n            .execute();\n\n          const mergedIntervals = intervalUnion(\n            existingIntervals.map((i) => [\n              Number(i.startBlock),\n              Number(i.endBlock),\n            ]),\n          );\n\n          const mergedIntervalRows = mergedIntervals.map(\n            ([startBlock, endBlock]) => ({\n              factoryId,\n              startBlock: BigInt(startBlock),\n              endBlock: BigInt(endBlock),\n            }),\n          );\n\n          if (mergedIntervalRows.length > 0) {\n            await tx\n              .insertInto(\"factoryLogFilterIntervals\")\n              .values(mergedIntervalRows)\n              .execute();\n          }\n\n          return mergedIntervals;\n        });\n      }),\n    );\n\n    const intervals = await this.db\n      .with(\n        \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3)\",\n        () =>\n          sql`( values ${sql.join(\n            fragments.map(\n              (f) =>\n                sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                  f.eventSelector,\n                )}, ${sql.val(f.childAddressLocation)}, ${sql.val(\n                  f.topic0,\n                )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                  f.topic3,\n                )} )`,\n            ),\n          )} )`,\n      )\n      .selectFrom(\"factoryLogFilterIntervals\")\n      .leftJoin(\"factories\", \"factoryId\", \"factories.id\")\n      .innerJoin(\"factoryFilterFragments\", (join) => {\n        let baseJoin = join.on(({ and, cmpr }) =>\n          and([\n            cmpr(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n            cmpr(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n            cmpr(\n              \"fragmentChildAddressLocation\",\n              \"=\",\n              sql.ref(\"childAddressLocation\"),\n            ),\n          ]),\n        );\n        for (const idx_ of range(0, 4)) {\n          baseJoin = baseJoin.on(({ or, cmpr }) => {\n            const idx = idx_ as 0 | 1 | 2 | 3;\n            return or([\n              cmpr(`topic${idx}`, \"is\", null),\n              cmpr(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n            ]);\n          });\n        }\n\n        return baseJoin;\n      })\n      .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n      .where(\"chainId\", \"=\", chainId)\n      .execute();\n\n    const intervalsByFragment = intervals.reduce(\n      (acc, cur) => {\n        const { fragmentId, ...rest } = cur;\n        acc[fragmentId] ||= [];\n        acc[fragmentId].push({\n          startBlock: rest.startBlock,\n          endBlock: rest.endBlock,\n        });\n        return acc;\n      },\n      {} as Record<string, { startBlock: bigint; endBlock: bigint }[]>,\n    );\n\n    const fragmentIntervals = fragments.map((f) => {\n      return (intervalsByFragment[f.id] ?? []).map(\n        (r) =>\n          [Number(r.startBlock), Number(r.endBlock)] satisfies [number, number],\n      );\n    });\n\n    const intersectIntervals = intervalIntersectionMany(fragmentIntervals);\n\n    this.record(\"getFactoryLogFilterIntervals\", start);\n\n    return intersectIntervals;\n  };\n\n  insertRealtimeBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values({ ...rpcToPostgresBlock(rpcBlock), chainId })\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n\n      for (const rpcTransaction of rpcTransactions) {\n        await tx\n          .insertInto(\"transactions\")\n          .values({ ...rpcToPostgresTransaction(rpcTransaction), chainId })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n\n      for (const rpcLog of rpcLogs) {\n        await tx\n          .insertInto(\"logs\")\n          .values({ ...rpcToPostgresLog(rpcLog), chainId })\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n    });\n\n    this.record(\"insertRealtimeBlock\", start);\n  };\n\n  insertRealtimeInterval = async ({\n    chainId,\n    logFilters,\n    factories,\n    interval,\n  }: {\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    factories: FactoryCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await this._insertLogFilterInterval({\n        tx,\n        chainId,\n        logFilters: [\n          ...logFilters,\n          ...factories.map((f) => ({\n            address: f.address,\n            topics: [f.eventSelector],\n          })),\n        ],\n        interval,\n      });\n\n      await this._insertFactoryLogFilterInterval({\n        tx,\n        chainId,\n        factories,\n        interval,\n      });\n    });\n\n    this.record(\"insertRealtimeInterval\", start);\n  };\n\n  deleteRealtimeData = async ({\n    chainId,\n    fromBlock,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await tx\n        .deleteFrom(\"blocks\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"number\", \">\", fromBlock)\n        .execute();\n      await tx\n        .deleteFrom(\"transactions\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \">\", fromBlock)\n        .execute();\n      await tx\n        .deleteFrom(\"logs\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \">\", fromBlock)\n        .execute();\n      await tx\n        .deleteFrom(\"rpcRequestResults\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \">\", fromBlock)\n        .execute();\n\n      // Delete all intervals with a startBlock greater than fromBlock.\n      // Then, if any intervals have an endBlock greater than fromBlock,\n      // update their endBlock to equal fromBlock.\n      await tx\n        .deleteFrom(\"logFilterIntervals\")\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"logFilters\")\n              .select(\"logFilters.chainId\")\n              .whereRef(\"logFilters.id\", \"=\", \"logFilterIntervals.logFilterId\")\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"startBlock\", \">\", fromBlock)\n        .execute();\n      await tx\n        .updateTable(\"logFilterIntervals\")\n        .set({ endBlock: fromBlock })\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"logFilters\")\n              .select(\"logFilters.chainId\")\n              .whereRef(\"logFilters.id\", \"=\", \"logFilterIntervals.logFilterId\")\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"endBlock\", \">\", fromBlock)\n        .execute();\n\n      await tx\n        .deleteFrom(\"factoryLogFilterIntervals\")\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"factories\")\n              .select(\"factories.chainId\")\n              .whereRef(\n                \"factories.id\",\n                \"=\",\n                \"factoryLogFilterIntervals.factoryId\",\n              )\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"startBlock\", \">\", fromBlock)\n        .execute();\n      await tx\n        .updateTable(\"factoryLogFilterIntervals\")\n        .set({ endBlock: fromBlock })\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"factories\")\n              .select(\"factories.chainId\")\n              .whereRef(\n                \"factories.id\",\n                \"=\",\n                \"factoryLogFilterIntervals.factoryId\",\n              )\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"endBlock\", \">\", fromBlock)\n        .execute();\n    });\n\n    this.record(\"deleteRealtimeData\", start);\n  };\n\n  /** SYNC HELPER METHODS */\n\n  private _insertLogFilterInterval = async ({\n    tx,\n    chainId,\n    logFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const logFilterFragments = logFilters.flatMap((logFilter) =>\n      buildLogFilterFragments({ ...logFilter, chainId }),\n    );\n\n    await Promise.all(\n      logFilterFragments.map(async (logFilterFragment) => {\n        const { id: logFilterId } = await tx\n          .insertInto(\"logFilters\")\n          .values(logFilterFragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(logFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"logFilterIntervals\")\n          .values({ logFilterId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryLogFilterInterval = async ({\n    tx,\n    chainId,\n    factories,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factories: FactoryCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factories.flatMap((factory) =>\n      buildFactoryFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factories\")\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryLogFilterIntervals\")\n          .values({ factoryId, startBlock, endBlock })\n          .execute();\n      }),\n    );\n  };\n\n  insertRpcRequestResult = async ({\n    request,\n    blockNumber,\n    chainId,\n    result,\n  }: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n    result: string;\n  }) => {\n    const start = performance.now();\n\n    await this.db\n      .insertInto(\"rpcRequestResults\")\n      .values({ request, blockNumber, chainId, result })\n      .onConflict((oc) =>\n        oc.constraint(\"rpcRequestResultPrimaryKey\").doUpdateSet({ result }),\n      )\n      .execute();\n\n    this.record(\"insertRpcRequestResult\", start);\n  };\n\n  getRpcRequestResult = async ({\n    request,\n    blockNumber,\n    chainId,\n  }: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n  }) => {\n    const start = performance.now();\n\n    const contractReadResult = await this.db\n      .selectFrom(\"rpcRequestResults\")\n      .selectAll()\n      .where(\"request\", \"=\", request)\n      .where(\"blockNumber\", \"=\", blockNumber)\n      .where(\"chainId\", \"=\", chainId)\n      .executeTakeFirst();\n\n    const result = contractReadResult ?? null;\n\n    this.record(\"getRpcRequestResult\", start);\n\n    return result;\n  };\n\n  async getLogEvents({\n    fromCheckpoint,\n    toCheckpoint,\n    limit,\n    logFilters = [],\n    factories = [],\n  }: {\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n    limit: number;\n    logFilters?: {\n      id: string;\n      chainId: number;\n      criteria: LogFilterCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n      includeEventSelectors?: Hex[];\n    }[];\n    factories?: {\n      id: string;\n      chainId: number;\n      criteria: FactoryCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n      includeEventSelectors?: Hex[];\n    }[];\n  }) {\n    const start = performance.now();\n\n    const baseQuery = this.db\n      .with(\n        \"sources(source_id)\",\n        () =>\n          sql`( values ${sql.join(\n            [...logFilters.map((f) => f.id), ...factories.map((f) => f.id)].map(\n              (id) => sql`( ${sql.val(id)} )`,\n            ),\n          )} )`,\n      )\n      .selectFrom(\"logs\")\n      .leftJoin(\"blocks\", \"blocks.hash\", \"logs.blockHash\")\n      .leftJoin(\"transactions\", \"transactions.hash\", \"logs.transactionHash\")\n      .innerJoin(\"sources\", (join) => join.onTrue())\n      .where((eb) => {\n        const logFilterCmprs = logFilters.map((logFilter) => {\n          const exprs = this.buildLogFilterCmprs({ eb, logFilter });\n          if (logFilter.includeEventSelectors) {\n            exprs.push(\n              eb.or(\n                logFilter.includeEventSelectors.map((t) =>\n                  eb(\"logs.topic0\", \"=\", t),\n                ),\n              ),\n            );\n          }\n          return eb.and(exprs);\n        });\n\n        const factoryCmprs = factories.map((factory) => {\n          const exprs = this.buildFactoryCmprs({ eb, factory });\n          if (factory.includeEventSelectors) {\n            exprs.push(\n              eb.or(\n                factory.includeEventSelectors.map((t) =>\n                  eb(\"logs.topic0\", \"=\", t),\n                ),\n              ),\n            );\n          }\n          return eb.and(exprs);\n        });\n\n        return eb.or([...logFilterCmprs, ...factoryCmprs]);\n      });\n\n    // Get full log objects, including the includeEventSelectors clause.\n    const requestedLogs = await baseQuery\n      .select([\n        \"source_id\",\n\n        \"logs.address as log_address\",\n        \"logs.blockHash as log_blockHash\",\n        \"logs.blockNumber as log_blockNumber\",\n        \"logs.chainId as log_chainId\",\n        \"logs.data as log_data\",\n        \"logs.id as log_id\",\n        \"logs.logIndex as log_logIndex\",\n        \"logs.topic0 as log_topic0\",\n        \"logs.topic1 as log_topic1\",\n        \"logs.topic2 as log_topic2\",\n        \"logs.topic3 as log_topic3\",\n        \"logs.transactionHash as log_transactionHash\",\n        \"logs.transactionIndex as log_transactionIndex\",\n\n        \"blocks.baseFeePerGas as block_baseFeePerGas\",\n        \"blocks.difficulty as block_difficulty\",\n        \"blocks.extraData as block_extraData\",\n        \"blocks.gasLimit as block_gasLimit\",\n        \"blocks.gasUsed as block_gasUsed\",\n        \"blocks.hash as block_hash\",\n        \"blocks.logsBloom as block_logsBloom\",\n        \"blocks.miner as block_miner\",\n        \"blocks.mixHash as block_mixHash\",\n        \"blocks.nonce as block_nonce\",\n        \"blocks.number as block_number\",\n        \"blocks.parentHash as block_parentHash\",\n        \"blocks.receiptsRoot as block_receiptsRoot\",\n        \"blocks.sha3Uncles as block_sha3Uncles\",\n        \"blocks.size as block_size\",\n        \"blocks.stateRoot as block_stateRoot\",\n        \"blocks.timestamp as block_timestamp\",\n        \"blocks.totalDifficulty as block_totalDifficulty\",\n        \"blocks.transactionsRoot as block_transactionsRoot\",\n\n        \"transactions.accessList as tx_accessList\",\n        \"transactions.blockHash as tx_blockHash\",\n        \"transactions.blockNumber as tx_blockNumber\",\n        \"transactions.from as tx_from\",\n        \"transactions.gas as tx_gas\",\n        \"transactions.gasPrice as tx_gasPrice\",\n        \"transactions.hash as tx_hash\",\n        \"transactions.input as tx_input\",\n        \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n        \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n        \"transactions.nonce as tx_nonce\",\n        \"transactions.r as tx_r\",\n        \"transactions.s as tx_s\",\n        \"transactions.to as tx_to\",\n        \"transactions.transactionIndex as tx_transactionIndex\",\n        \"transactions.type as tx_type\",\n        \"transactions.value as tx_value\",\n        \"transactions.v as tx_v\",\n      ])\n      .where((eb) => this.buildCheckpointCmprs(eb, \">\", fromCheckpoint))\n      .where((eb) => this.buildCheckpointCmprs(eb, \"<=\", toCheckpoint))\n      .orderBy(\"blocks.timestamp\", \"asc\")\n      .orderBy(\"logs.chainId\", \"asc\")\n      .orderBy(\"blocks.number\", \"asc\")\n      .orderBy(\"logs.logIndex\", \"asc\")\n      .limit(limit + 1)\n      .execute();\n\n    const events = requestedLogs.map((_row) => {\n      // Without this cast, the block_ and tx_ fields are all nullable\n      // which makes this very annoying. Should probably add a runtime check\n      // that those fields are indeed present before continuing here.\n      const row = _row as NonNull<(typeof requestedLogs)[number]>;\n\n      return {\n        sourceId: row.source_id,\n        chainId: row.log_chainId,\n        log: {\n          address: checksumAddress(row.log_address),\n          blockHash: row.log_blockHash,\n          blockNumber: row.log_blockNumber,\n          data: row.log_data,\n          id: row.log_id as Log[\"id\"],\n          logIndex: Number(row.log_logIndex),\n          removed: false,\n          topics: [\n            row.log_topic0,\n            row.log_topic1,\n            row.log_topic2,\n            row.log_topic3,\n          ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n          transactionHash: row.log_transactionHash,\n          transactionIndex: Number(row.log_transactionIndex),\n        },\n        block: {\n          baseFeePerGas: row.block_baseFeePerGas,\n          difficulty: row.block_difficulty,\n          extraData: row.block_extraData,\n          gasLimit: row.block_gasLimit,\n          gasUsed: row.block_gasUsed,\n          hash: row.block_hash,\n          logsBloom: row.block_logsBloom,\n          miner: checksumAddress(row.block_miner),\n          mixHash: row.block_mixHash,\n          nonce: row.block_nonce,\n          number: row.block_number,\n          parentHash: row.block_parentHash,\n          receiptsRoot: row.block_receiptsRoot,\n          sha3Uncles: row.block_sha3Uncles,\n          size: row.block_size,\n          stateRoot: row.block_stateRoot,\n          timestamp: row.block_timestamp,\n          totalDifficulty: row.block_totalDifficulty,\n          transactionsRoot: row.block_transactionsRoot,\n        },\n        transaction: {\n          blockHash: row.tx_blockHash,\n          blockNumber: row.tx_blockNumber,\n          from: checksumAddress(row.tx_from),\n          gas: row.tx_gas,\n          hash: row.tx_hash,\n          input: row.tx_input,\n          nonce: Number(row.tx_nonce),\n          r: row.tx_r,\n          s: row.tx_s,\n          to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n          transactionIndex: Number(row.tx_transactionIndex),\n          value: row.tx_value,\n          v: row.tx_v,\n          ...(row.tx_type === \"0x0\"\n            ? { type: \"legacy\", gasPrice: row.tx_gasPrice }\n            : row.tx_type === \"0x1\"\n              ? {\n                  type: \"eip2930\",\n                  gasPrice: row.tx_gasPrice,\n                  accessList: JSON.parse(row.tx_accessList),\n                }\n              : row.tx_type === \"0x2\"\n                ? {\n                    type: \"eip1559\",\n                    maxFeePerGas: row.tx_maxFeePerGas,\n                    maxPriorityFeePerGas: row.tx_maxPriorityFeePerGas,\n                  }\n                : row.tx_type === \"0x7e\"\n                  ? {\n                      type: \"deposit\",\n                      maxFeePerGas: row.tx_maxFeePerGas ?? undefined,\n                      maxPriorityFeePerGas:\n                        row.tx_maxPriorityFeePerGas ?? undefined,\n                    }\n                  : { type: row.tx_type }),\n        },\n      } satisfies {\n        sourceId: string;\n        chainId: number;\n        log: Log;\n        block: Block;\n        transaction: Transaction;\n      };\n    });\n\n    // Query for the checkpoint of the last event in the requested range (ignore the batch limit)\n    const lastCheckpointRows = await baseQuery\n      .select([\n        \"blocks.timestamp as block_timestamp\",\n        \"logs.chainId as log_chainId\",\n        \"blocks.number as block_number\",\n        \"logs.logIndex as log_logIndex\",\n      ])\n      .where((eb) => this.buildCheckpointCmprs(eb, \"<=\", toCheckpoint))\n      .orderBy(\"blocks.timestamp\", \"desc\")\n      .orderBy(\"logs.chainId\", \"desc\")\n      .orderBy(\"blocks.number\", \"desc\")\n      .orderBy(\"logs.logIndex\", \"desc\")\n      .limit(1)\n      .execute();\n\n    const lastCheckpointRow = lastCheckpointRows[0];\n    const lastCheckpoint =\n      lastCheckpointRow !== undefined\n        ? ({\n            blockTimestamp: Number(lastCheckpointRow.block_timestamp!),\n            blockNumber: Number(lastCheckpointRow.block_number!),\n            chainId: lastCheckpointRow.log_chainId,\n            logIndex: lastCheckpointRow.log_logIndex,\n          } satisfies Checkpoint)\n        : undefined;\n\n    this.record(\"getLogEvents\", performance.now() - start);\n\n    if (events.length === limit + 1) {\n      events.pop();\n\n      const lastEventInPage = events[events.length - 1];\n      const lastCheckpointInPage = {\n        blockTimestamp: Number(lastEventInPage.block.timestamp),\n        chainId: lastEventInPage.chainId,\n        blockNumber: Number(lastEventInPage.block.number),\n        logIndex: lastEventInPage.log.logIndex,\n      } satisfies Checkpoint;\n\n      return {\n        events,\n        hasNextPage: true,\n        lastCheckpointInPage,\n        lastCheckpoint,\n      } as const;\n    } else {\n      return {\n        events,\n        hasNextPage: false,\n        lastCheckpointInPage: undefined,\n        lastCheckpoint,\n      } as const;\n    }\n  }\n\n  /**\n   * Builds an expression that filters for events that are greater or\n   * less than the provided checkpoint. If the log index is not specific,\n   * the expression will use a block-level granularity.\n   */\n  private buildCheckpointCmprs = (\n    eb: ExpressionBuilder<any, any>,\n    op: \">\" | \">=\" | \"<\" | \"<=\",\n    checkpoint: Checkpoint,\n  ) => {\n    const { and, or } = eb;\n\n    const { blockTimestamp, chainId, blockNumber, logIndex } = checkpoint;\n\n    const operand = op.startsWith(\">\") ? (\">\" as const) : (\"<\" as const);\n    const operandOrEquals = `${operand}=` as const;\n    const isInclusive = op.endsWith(\"=\");\n\n    // If the execution index is not defined, the checkpoint is at block granularity.\n    // Include (or exclude) all events in the block.\n    if (logIndex === undefined) {\n      return and([\n        eb(\"blocks.timestamp\", operandOrEquals, BigInt(blockTimestamp)),\n        or([\n          eb(\"blocks.timestamp\", operand, BigInt(blockTimestamp)),\n          and([\n            eb(\"logs.chainId\", operandOrEquals, chainId),\n            or([\n              eb(\"logs.chainId\", operand, chainId),\n              eb(\n                \"blocks.number\",\n                isInclusive ? operandOrEquals : operand,\n                BigInt(blockNumber),\n              ),\n            ]),\n          ]),\n        ]),\n      ]);\n    }\n\n    // Otherwise, apply the filter down to the log index.\n    return and([\n      eb(\"blocks.timestamp\", operandOrEquals, BigInt(blockTimestamp)),\n      or([\n        eb(\"blocks.timestamp\", operand, BigInt(blockTimestamp)),\n        and([\n          eb(\"logs.chainId\", operandOrEquals, chainId),\n          or([\n            eb(\"logs.chainId\", operand, chainId),\n            and([\n              eb(\"blocks.number\", operandOrEquals, BigInt(blockNumber)),\n              or([\n                eb(\"blocks.number\", operand, BigInt(blockNumber)),\n                eb(\n                  \"logs.logIndex\",\n                  isInclusive ? operandOrEquals : operand,\n                  logIndex,\n                ),\n              ]),\n            ]),\n          ]),\n        ]),\n      ]),\n    ]);\n  };\n\n  private buildLogFilterCmprs = ({\n    eb,\n    logFilter,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    logFilter: {\n      id: string;\n      chainId: number;\n      criteria: LogFilterCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n    };\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"source_id\", \"=\", logFilter.id));\n    exprs.push(\n      eb(\n        \"logs.chainId\",\n        \"=\",\n        sql`cast (${sql.val(logFilter.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    if (logFilter.criteria.address) {\n      // If it's an array of length 1, collapse it.\n      const address =\n        Array.isArray(logFilter.criteria.address) &&\n        logFilter.criteria.address.length === 1\n          ? logFilter.criteria.address[0]\n          : logFilter.criteria.address;\n      if (Array.isArray(address)) {\n        exprs.push(eb.or(address.map((a) => eb(\"logs.address\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"logs.address\", \"=\", address));\n      }\n    }\n\n    if (logFilter.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = logFilter.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (logFilter.fromBlock)\n      exprs.push(eb(\"blocks.number\", \">=\", BigInt(logFilter.fromBlock)));\n    if (logFilter.toBlock)\n      exprs.push(eb(\"blocks.number\", \"<=\", BigInt(logFilter.toBlock)));\n\n    return exprs;\n  };\n\n  private buildFactoryCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: {\n      id: string;\n      chainId: number;\n      criteria: FactoryCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n    };\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"source_id\", \"=\", factory.id));\n    exprs.push(\n      eb(\n        \"logs.chainId\",\n        \"=\",\n        sql`cast (${sql.val(factory.chainId)} as numeric(16, 0))`,\n      ),\n    );\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"logs.address\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.fromBlock)\n      exprs.push(eb(\"blocks.number\", \">=\", BigInt(factory.fromBlock)));\n    if (factory.toBlock)\n      exprs.push(eb(\"blocks.number\", \"<=\", BigInt(factory.toBlock)));\n\n    return exprs;\n  };\n\n  private transaction = <U>(\n    callback: (tx: KyselyTransaction<SyncStoreTables>) => Promise<U>,\n  ) => this.db.transaction().execute(callback);\n\n  private record(methodName: string, start: number) {\n    this.common.metrics.ponder_sync_store_method_duration.observe(\n      { method: methodName },\n      performance.now() - start,\n    );\n  }\n}\n\nfunction buildFactoryChildAddressSelectExpression({\n  childAddressLocation,\n}: {\n  childAddressLocation: FactoryCriteria[\"childAddressLocation\"];\n}) {\n  if (childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(childAddressLocation.substring(6));\n    const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(data from ${start}::int for ${length}::int)`;\n  } else {\n    const start = 2 + 12 * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(${sql.ref(\n      childAddressLocation,\n    )} from ${start}::integer for ${length}::integer)`;\n  }\n}\n","import type { Generated, Insertable } from \"kysely\";\nimport type { Address, Hash, Hex } from \"viem\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\n\nimport { toLowerCase } from \"@/utils/lowercase.js\";\n\ntype BlocksTable = {\n  baseFeePerGas: bigint | null;\n  difficulty: bigint;\n  extraData: Hex;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  number: bigint;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash;\n  size: bigint;\n  stateRoot: Hash;\n  timestamp: bigint;\n  totalDifficulty: bigint;\n  transactionsRoot: Hash;\n\n  chainId: number;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToPostgresBlock(\n  block: RpcBlock,\n): Omit<InsertableBlock, \"chainId\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    difficulty: BigInt(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: BigInt(block.gasLimit),\n    gasUsed: BigInt(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    number: BigInt(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles,\n    size: BigInt(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: BigInt(block.timestamp),\n    totalDifficulty: BigInt(block.totalDifficulty!),\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: bigint;\n  from: Address;\n  gas: bigint;\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex;\n  s: Hex;\n  to: Address | null;\n  transactionIndex: number;\n  v: bigint;\n  value: bigint;\n\n  type: Hex;\n  gasPrice: bigint | null;\n  maxFeePerGas: bigint | null;\n  maxPriorityFeePerGas: bigint | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToPostgresTransaction(\n  transaction: RpcTransaction,\n): Omit<InsertableTransaction, \"chainId\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: BigInt(transaction.blockNumber!),\n    from: toLowerCase(transaction.from),\n    gas: BigInt(transaction.gas),\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r,\n    s: transaction.s,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: BigInt(transaction.value),\n    v: BigInt(transaction.v),\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: bigint;\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n\n  chainId: number;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToPostgresLog(log: RpcLog): Omit<InsertableLog, \"chainId\"> {\n  return {\n    address: toLowerCase(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: BigInt(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype RpcRequestResultsTable = {\n  blockNumber: bigint;\n  chainId: number;\n  request: string;\n  result: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\ntype FactoriesTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: bigint;\n  endBlock: bigint;\n};\n\nexport type SyncStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  logs: LogsTable;\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factories: FactoriesTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n};\n","import type { Kysely } from \"kysely\";\nimport { type Migration, type MigrationProvider, sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", sql`bytea`) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses Postgres SERIAL type which autoincrements.\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"numeric(78, 0)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"v\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_01_30_0_change_chain_id_type\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logs\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"rpcRequestResults\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"mixHash\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"nonce\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n","import {\n  type ExpressionBuilder,\n  Kysely,\n  Migrator,\n  SqliteDialect,\n  type Transaction as KyselyTransaction,\n  sql,\n} from \"kysely\";\nimport {\n  type Hex,\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  checksumAddress,\n} from \"viem\";\n\nimport type { Common } from \"@/Ponder.js\";\nimport type { FactoryCriteria, LogFilterCriteria } from \"@/config/sources.js\";\nimport type { Block, Log, Transaction } from \"@/types/eth.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport type { Checkpoint } from \"@/utils/checkpoint.js\";\nimport { decodeToBigInt, encodeAsText } from \"@/utils/encoding.js\";\nimport {\n  buildFactoryFragments,\n  buildLogFilterFragments,\n} from \"@/utils/fragments.js\";\nimport { intervalIntersectionMany, intervalUnion } from \"@/utils/interval.js\";\nimport { range } from \"@/utils/range.js\";\nimport { type SqliteDatabase } from \"@/utils/sqlite.js\";\nimport { wait } from \"@/utils/wait.js\";\n\nimport type { SyncStore } from \"../store.js\";\nimport type { BigIntText } from \"./format.js\";\nimport {\n  type SyncStoreTables,\n  rpcToSqliteBlock,\n  rpcToSqliteLog,\n  rpcToSqliteTransaction,\n} from \"./format.js\";\nimport { migrationProvider } from \"./migrations.js\";\n\nexport class SqliteSyncStore implements SyncStore {\n  kind = \"sqlite\" as const;\n  private common: Common;\n\n  db: Kysely<SyncStoreTables>;\n  migrator: Migrator;\n\n  constructor({\n    common,\n    database,\n  }: { common: Common; database: SqliteDatabase }) {\n    this.common = common;\n    this.db = new Kysely<SyncStoreTables>({\n      dialect: new SqliteDialect({ database }),\n      log(event) {\n        if (event.level === \"query\")\n          common.metrics.ponder_sqlite_query_count?.inc({ kind: \"sync\" });\n      },\n    });\n\n    this.migrator = new Migrator({\n      db: this.db,\n      provider: migrationProvider,\n    });\n  }\n\n  async kill() {\n    try {\n      await this.db.destroy();\n    } catch (e) {\n      const error = e as Error;\n      if (error.message !== \"Called end on pool more than once\") {\n        throw error;\n      }\n    }\n  }\n\n  migrateUp = async () => {\n    const start = performance.now();\n\n    const { error } = await this.migrator.migrateToLatest();\n    if (error) throw error;\n\n    this.record(\"migrateUp\", performance.now() - start);\n  };\n\n  insertLogFilterInterval = async ({\n    chainId,\n    logFilter,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const start = performance.now();\n    await this.transaction(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values({ ...rpcToSqliteBlock(rpcBlock), chainId })\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n\n      for (const rpcTransaction of rpcTransactions) {\n        await tx\n          .insertInto(\"transactions\")\n          .values({ ...rpcToSqliteTransaction(rpcTransaction), chainId })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n\n      for (const rpcLog of rpcLogs) {\n        await tx\n          .insertInto(\"logs\")\n          .values({ ...rpcToSqliteLog(rpcLog), chainId })\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n\n      await this._insertLogFilterInterval({\n        tx,\n        chainId,\n        logFilters: [logFilter],\n        interval,\n      });\n    });\n\n    this.record(\"insertLogFilterInterval\", performance.now() - start);\n  };\n\n  getLogFilterIntervals = async ({\n    chainId,\n    logFilter,\n  }: {\n    chainId: number;\n    logFilter: LogFilterCriteria;\n  }) => {\n    const start = performance.now();\n    const fragments = buildLogFilterFragments({ ...logFilter, chainId });\n\n    // First, attempt to merge overlapping and adjacent intervals.\n    await Promise.all(\n      fragments.map(async (fragment) => {\n        return await this.transaction(async (tx) => {\n          const { id: logFilterId } = await tx\n            .insertInto(\"logFilters\")\n            .values(fragment)\n            .onConflict((oc) => oc.doUpdateSet(fragment))\n            .returningAll()\n            .executeTakeFirstOrThrow();\n\n          const existingIntervalRows = await tx\n            .deleteFrom(\"logFilterIntervals\")\n            .where(\"logFilterId\", \"=\", logFilterId)\n            .returningAll()\n            .execute();\n\n          const mergedIntervals = intervalUnion(\n            existingIntervalRows.map((i) => [\n              Number(decodeToBigInt(i.startBlock)),\n              Number(decodeToBigInt(i.endBlock)),\n            ]),\n          );\n\n          const mergedIntervalRows = mergedIntervals.map(\n            ([startBlock, endBlock]) => ({\n              logFilterId,\n              startBlock: encodeAsText(startBlock),\n              endBlock: encodeAsText(endBlock),\n            }),\n          );\n\n          if (mergedIntervalRows.length > 0) {\n            await tx\n              .insertInto(\"logFilterIntervals\")\n              .values(mergedIntervalRows)\n              .execute();\n          }\n\n          return mergedIntervals;\n        });\n      }),\n    );\n\n    const intervals = await this.db\n      .with(\n        \"logFilterFragments(fragmentId, fragmentAddress, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3)\",\n        () =>\n          sql`( values ${sql.join(\n            fragments.map(\n              (f) =>\n                sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                  f.topic0,\n                )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                  f.topic3,\n                )} )`,\n            ),\n          )} )`,\n      )\n      .selectFrom(\"logFilterIntervals\")\n      .leftJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n      .innerJoin(\"logFilterFragments\", (join) => {\n        let baseJoin = join.on(({ or, cmpr }) =>\n          or([\n            cmpr(\"address\", \"is\", null),\n            cmpr(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n          ]),\n        );\n        for (const idx_ of range(0, 4)) {\n          baseJoin = baseJoin.on(({ or, cmpr }) => {\n            const idx = idx_ as 0 | 1 | 2 | 3;\n            return or([\n              cmpr(`topic${idx}`, \"is\", null),\n              cmpr(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n            ]);\n          });\n        }\n\n        return baseJoin;\n      })\n      .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n      .where(\"chainId\", \"=\", chainId)\n      .execute();\n\n    const intervalsByFragment = intervals.reduce(\n      (acc, cur) => {\n        const { fragmentId, ...rest } = cur;\n        acc[fragmentId] ||= [];\n        acc[fragmentId].push({\n          startBlock: decodeToBigInt(rest.startBlock),\n          endBlock: decodeToBigInt(rest.endBlock),\n        });\n        return acc;\n      },\n      {} as Record<string, { startBlock: bigint; endBlock: bigint }[]>,\n    );\n\n    const fragmentIntervals = fragments.map((f) => {\n      return (intervalsByFragment[f.id] ?? []).map(\n        (r) =>\n          [Number(r.startBlock), Number(r.endBlock)] satisfies [number, number],\n      );\n    });\n\n    const intersectionIntervals = intervalIntersectionMany(fragmentIntervals);\n    this.record(\"getLogFilterIntervals\", performance.now() - start);\n    return intersectionIntervals;\n  };\n\n  insertFactoryChildAddressLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: RpcLog[];\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      for (const rpcLog of rpcLogs) {\n        await tx\n          .insertInto(\"logs\")\n          .values({ ...rpcToSqliteLog(rpcLog), chainId })\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n    });\n\n    this.record(\"insertFactoryChildAddressLogs\", performance.now() - start);\n  };\n\n  async *getFactoryChildAddresses({\n    chainId,\n    upToBlockNumber,\n    factory,\n    pageSize = 500,\n  }: {\n    chainId: number;\n    upToBlockNumber: bigint;\n    factory: FactoryCriteria;\n    pageSize?: number;\n  }) {\n    let queryExecutionTime = 0;\n\n    const { address, eventSelector, childAddressLocation } = factory;\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({ childAddressLocation });\n\n    const baseQuery = this.db\n      .selectFrom(\"logs\")\n      .select([selectChildAddressExpression.as(\"childAddress\"), \"blockNumber\"])\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"address\", \"=\", address)\n      .where(\"topic0\", \"=\", eventSelector)\n      .where(\"blockNumber\", \"<=\", encodeAsText(upToBlockNumber))\n      .limit(pageSize);\n\n    let cursor: BigIntText | undefined = undefined;\n\n    while (true) {\n      let query = baseQuery;\n\n      if (cursor) {\n        query = query.where(\"blockNumber\", \">\", cursor);\n      }\n\n      const start = performance.now();\n      const batch = await query.execute();\n      queryExecutionTime += performance.now() - start;\n\n      const lastRow = batch[batch.length - 1];\n      if (lastRow) {\n        cursor = lastRow.blockNumber;\n      }\n\n      if (batch.length > 0) {\n        yield batch.map((a) => a.childAddress);\n      }\n\n      if (batch.length < pageSize) break;\n    }\n\n    this.record(\"getFactoryChildAddresses\", queryExecutionTime);\n  }\n\n  insertFactoryLogFilterInterval = async ({\n    chainId,\n    factory,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n    interval,\n  }: {\n    chainId: number;\n    factory: FactoryCriteria;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values({ ...rpcToSqliteBlock(rpcBlock), chainId })\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n\n      for (const rpcTransaction of rpcTransactions) {\n        await tx\n          .insertInto(\"transactions\")\n          .values({ ...rpcToSqliteTransaction(rpcTransaction), chainId })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n\n      for (const rpcLog of rpcLogs) {\n        await tx\n          .insertInto(\"logs\")\n          .values({ ...rpcToSqliteLog(rpcLog), chainId })\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n\n      await this._insertFactoryLogFilterInterval({\n        tx,\n        chainId,\n        factories: [factory],\n        interval,\n      });\n    });\n\n    this.record(\"insertFactoryLogFilterInterval\", performance.now() - start);\n  };\n\n  getFactoryLogFilterIntervals = async ({\n    chainId,\n    factory,\n  }: {\n    chainId: number;\n    factory: FactoryCriteria;\n  }) => {\n    const start = performance.now();\n\n    const fragments = buildFactoryFragments({\n      ...factory,\n      chainId,\n    });\n\n    await Promise.all(\n      fragments.map(async (fragment) => {\n        return await this.transaction(async (tx) => {\n          const { id: factoryId } = await tx\n            .insertInto(\"factories\")\n            .values(fragment)\n            .onConflict((oc) => oc.doUpdateSet(fragment))\n            .returningAll()\n            .executeTakeFirstOrThrow();\n\n          const existingIntervals = await tx\n            .deleteFrom(\"factoryLogFilterIntervals\")\n            .where(\"factoryId\", \"=\", factoryId)\n            .returningAll()\n            .execute();\n\n          const mergedIntervals = intervalUnion(\n            existingIntervals.map((i) => [\n              Number(decodeToBigInt(i.startBlock)),\n              Number(decodeToBigInt(i.endBlock)),\n            ]),\n          );\n\n          const mergedIntervalRows = mergedIntervals.map(\n            ([startBlock, endBlock]) => ({\n              factoryId,\n              startBlock: encodeAsText(startBlock),\n              endBlock: encodeAsText(endBlock),\n            }),\n          );\n\n          if (mergedIntervalRows.length > 0) {\n            await tx\n              .insertInto(\"factoryLogFilterIntervals\")\n              .values(mergedIntervalRows)\n              .execute();\n          }\n\n          return mergedIntervals;\n        });\n      }),\n    );\n\n    const intervals = await this.db\n      .with(\n        \"factoryFilterFragments(fragmentId, fragmentAddress, fragmentEventSelector, fragmentChildAddressLocation, fragmentTopic0, fragmentTopic1, fragmentTopic2, fragmentTopic3)\",\n        () =>\n          sql`( values ${sql.join(\n            fragments.map(\n              (f) =>\n                sql`( ${sql.val(f.id)}, ${sql.val(f.address)}, ${sql.val(\n                  f.eventSelector,\n                )}, ${sql.val(f.childAddressLocation)}, ${sql.val(\n                  f.topic0,\n                )}, ${sql.val(f.topic1)}, ${sql.val(f.topic2)}, ${sql.val(\n                  f.topic3,\n                )} )`,\n            ),\n          )} )`,\n      )\n      .selectFrom(\"factoryLogFilterIntervals\")\n      .leftJoin(\"factories\", \"factoryId\", \"factories.id\")\n      .innerJoin(\"factoryFilterFragments\", (join) => {\n        let baseJoin = join.on(({ and, cmpr }) =>\n          and([\n            cmpr(\"fragmentAddress\", \"=\", sql.ref(\"address\")),\n            cmpr(\"fragmentEventSelector\", \"=\", sql.ref(\"eventSelector\")),\n            cmpr(\n              \"fragmentChildAddressLocation\",\n              \"=\",\n              sql.ref(\"childAddressLocation\"),\n            ),\n          ]),\n        );\n        for (const idx_ of range(0, 4)) {\n          baseJoin = baseJoin.on(({ or, cmpr }) => {\n            const idx = idx_ as 0 | 1 | 2 | 3;\n            return or([\n              cmpr(`topic${idx}`, \"is\", null),\n              cmpr(`fragmentTopic${idx}`, \"=\", sql.ref(`topic${idx}`)),\n            ]);\n          });\n        }\n\n        return baseJoin;\n      })\n      .select([\"fragmentId\", \"startBlock\", \"endBlock\"])\n      .where(\"chainId\", \"=\", chainId)\n      .execute();\n\n    const intervalsByFragment = intervals.reduce(\n      (acc, cur) => {\n        const { fragmentId, ...rest } = cur;\n        acc[fragmentId] ||= [];\n        acc[fragmentId].push({\n          startBlock: decodeToBigInt(rest.startBlock),\n          endBlock: decodeToBigInt(rest.endBlock),\n        });\n        return acc;\n      },\n      {} as Record<string, { startBlock: bigint; endBlock: bigint }[]>,\n    );\n\n    const fragmentIntervals = fragments.map((f) => {\n      return (intervalsByFragment[f.id] ?? []).map(\n        (r) =>\n          [Number(r.startBlock), Number(r.endBlock)] satisfies [number, number],\n      );\n    });\n\n    const intersectionIntervals = intervalIntersectionMany(fragmentIntervals);\n\n    this.record(\"getFactoryLogFilterIntervals\", performance.now() - start);\n\n    return intersectionIntervals;\n  };\n\n  insertRealtimeBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values({ ...rpcToSqliteBlock(rpcBlock), chainId })\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n\n      for (const rpcTransaction of rpcTransactions) {\n        await tx\n          .insertInto(\"transactions\")\n          .values({ ...rpcToSqliteTransaction(rpcTransaction), chainId })\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n\n      for (const rpcLog of rpcLogs) {\n        await tx\n          .insertInto(\"logs\")\n          .values({ ...rpcToSqliteLog(rpcLog), chainId })\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n    });\n\n    this.record(\"insertRealtimeBlock\", performance.now() - start);\n  };\n\n  insertRealtimeInterval = async ({\n    chainId,\n    logFilters,\n    factories,\n    interval,\n  }: {\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    factories: FactoryCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const start = performance.now();\n\n    await this.transaction(async (tx) => {\n      await this._insertLogFilterInterval({\n        tx,\n        chainId,\n        logFilters: [\n          ...logFilters,\n          ...factories.map((f) => ({\n            address: f.address,\n            topics: [f.eventSelector],\n          })),\n        ],\n        interval,\n      });\n\n      await this._insertFactoryLogFilterInterval({\n        tx,\n        chainId,\n        factories,\n        interval,\n      });\n    });\n\n    this.record(\"insertRealtimeInterval\", performance.now() - start);\n  };\n\n  deleteRealtimeData = async ({\n    chainId,\n    fromBlock: fromBlock_,\n  }: {\n    chainId: number;\n    fromBlock: bigint;\n  }) => {\n    const start = performance.now();\n\n    const fromBlock = encodeAsText(fromBlock_);\n\n    await this.transaction(async (tx) => {\n      await tx\n        .deleteFrom(\"blocks\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"number\", \">\", fromBlock)\n        .execute();\n      await tx\n        .deleteFrom(\"transactions\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \">\", fromBlock)\n        .execute();\n      await tx\n        .deleteFrom(\"logs\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \">\", fromBlock)\n        .execute();\n      await tx\n        .deleteFrom(\"rpcRequestResults\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \">\", fromBlock)\n        .execute();\n\n      // Delete all intervals with a startBlock greater than fromBlock.\n      // Then, if any intervals have an endBlock greater than fromBlock,\n      // update their endBlock to equal fromBlock.\n      await tx\n        .deleteFrom(\"logFilterIntervals\")\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"logFilters\")\n              .select(\"logFilters.chainId\")\n              .whereRef(\"logFilters.id\", \"=\", \"logFilterIntervals.logFilterId\")\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"startBlock\", \">\", fromBlock)\n        .execute();\n      await tx\n        .updateTable(\"logFilterIntervals\")\n        .set({ endBlock: fromBlock })\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"logFilters\")\n              .select(\"logFilters.chainId\")\n              .whereRef(\"logFilters.id\", \"=\", \"logFilterIntervals.logFilterId\")\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"endBlock\", \">\", fromBlock)\n        .execute();\n\n      await tx\n        .deleteFrom(\"factoryLogFilterIntervals\")\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"factories\")\n              .select(\"factories.chainId\")\n              .whereRef(\n                \"factories.id\",\n                \"=\",\n                \"factoryLogFilterIntervals.factoryId\",\n              )\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"startBlock\", \">\", fromBlock)\n        .execute();\n      await tx\n        .updateTable(\"factoryLogFilterIntervals\")\n        .set({ endBlock: fromBlock })\n        .where(\n          (qb) =>\n            qb\n              .selectFrom(\"factories\")\n              .select(\"factories.chainId\")\n              .whereRef(\n                \"factories.id\",\n                \"=\",\n                \"factoryLogFilterIntervals.factoryId\",\n              )\n              .limit(1),\n          \"=\",\n          chainId,\n        )\n        .where(\"endBlock\", \">\", fromBlock)\n        .execute();\n    });\n\n    this.record(\"deleteRealtimeData\", performance.now() - start);\n  };\n\n  /** SYNC HELPER METHODS */\n\n  private _insertLogFilterInterval = async ({\n    tx,\n    chainId,\n    logFilters,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    logFilters: LogFilterCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const logFilterFragments = logFilters.flatMap((logFilter) =>\n      buildLogFilterFragments({ ...logFilter, chainId }),\n    );\n\n    await Promise.all(\n      logFilterFragments.map(async (logFilterFragment) => {\n        const { id: logFilterId } = await tx\n          .insertInto(\"logFilters\")\n          .values(logFilterFragment)\n          .onConflict((oc) => oc.doUpdateSet(logFilterFragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"logFilterIntervals\")\n          .values({\n            logFilterId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  private _insertFactoryLogFilterInterval = async ({\n    tx,\n    chainId,\n    factories,\n    interval: { startBlock, endBlock },\n  }: {\n    tx: KyselyTransaction<SyncStoreTables>;\n    chainId: number;\n    factories: FactoryCriteria[];\n    interval: { startBlock: bigint; endBlock: bigint };\n  }) => {\n    const factoryFragments = factories.flatMap((factory) =>\n      buildFactoryFragments({ ...factory, chainId }),\n    );\n\n    await Promise.all(\n      factoryFragments.map(async (fragment) => {\n        const { id: factoryId } = await tx\n          .insertInto(\"factories\")\n          .values(fragment)\n          .onConflict((oc) => oc.doUpdateSet(fragment))\n          .returningAll()\n          .executeTakeFirstOrThrow();\n\n        await tx\n          .insertInto(\"factoryLogFilterIntervals\")\n          .values({\n            factoryId,\n            startBlock: encodeAsText(startBlock),\n            endBlock: encodeAsText(endBlock),\n          })\n          .execute();\n      }),\n    );\n  };\n\n  /** CONTRACT READS */\n\n  insertRpcRequestResult = async ({\n    blockNumber,\n    chainId,\n    request,\n    result,\n  }: {\n    blockNumber: bigint;\n    chainId: number;\n    request: string;\n    result: string;\n  }) => {\n    const start = performance.now();\n\n    await this.db\n      .insertInto(\"rpcRequestResults\")\n      .values({\n        request,\n        blockNumber: encodeAsText(blockNumber),\n        chainId,\n        result,\n      })\n      .onConflict((oc) => oc.doUpdateSet({ result }))\n      .execute();\n\n    this.record(\"insertRpcRequestResult\", performance.now() - start);\n  };\n\n  getRpcRequestResult = async ({\n    blockNumber,\n    chainId,\n    request,\n  }: {\n    blockNumber: bigint;\n    chainId: number;\n    request: string;\n  }) => {\n    const start = performance.now();\n\n    const rpcRequestResult = await this.db\n      .selectFrom(\"rpcRequestResults\")\n      .selectAll()\n      .where(\"blockNumber\", \"=\", encodeAsText(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"request\", \"=\", request)\n      .executeTakeFirst();\n\n    const result = rpcRequestResult\n      ? {\n          ...rpcRequestResult,\n          blockNumber: decodeToBigInt(rpcRequestResult.blockNumber),\n        }\n      : null;\n\n    this.record(\"getRpcRequestResult\", performance.now() - start);\n\n    return result;\n  };\n\n  async getLogEvents({\n    fromCheckpoint,\n    toCheckpoint,\n    limit,\n    logFilters = [],\n    factories = [],\n  }: {\n    fromCheckpoint: Checkpoint;\n    toCheckpoint: Checkpoint;\n    limit: number;\n    logFilters?: {\n      id: string;\n      chainId: number;\n      criteria: LogFilterCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n      includeEventSelectors?: Hex[];\n    }[];\n    factories?: {\n      id: string;\n      chainId: number;\n      criteria: FactoryCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n      includeEventSelectors?: Hex[];\n    }[];\n  }) {\n    const start = performance.now();\n\n    const baseQuery = this.db\n      .with(\n        \"sources(source_id)\",\n        () =>\n          sql`( values ${sql.join(\n            [...logFilters.map((f) => f.id), ...factories.map((f) => f.id)].map(\n              (id) => sql`( ${sql.val(id)} )`,\n            ),\n          )} )`,\n      )\n      .selectFrom(\"logs\")\n      .leftJoin(\"blocks\", \"blocks.hash\", \"logs.blockHash\")\n      .leftJoin(\"transactions\", \"transactions.hash\", \"logs.transactionHash\")\n      .innerJoin(\"sources\", (join) => join.onTrue())\n      .where((eb) => {\n        const logFilterCmprs = logFilters.map((logFilter) => {\n          const exprs = this.buildLogFilterCmprs({ eb, logFilter });\n          if (logFilter.includeEventSelectors) {\n            exprs.push(\n              eb.or(\n                logFilter.includeEventSelectors.map((t) =>\n                  eb(\"logs.topic0\", \"=\", t),\n                ),\n              ),\n            );\n          }\n          return eb.and(exprs);\n        });\n\n        const factoryCmprs = factories.map((factory) => {\n          const exprs = this.buildFactoryCmprs({ eb, factory });\n          if (factory.includeEventSelectors) {\n            exprs.push(\n              eb.or(\n                factory.includeEventSelectors.map((t) =>\n                  eb(\"logs.topic0\", \"=\", t),\n                ),\n              ),\n            );\n          }\n          return eb.and(exprs);\n        });\n\n        return eb.or([...logFilterCmprs, ...factoryCmprs]);\n      });\n\n    // Query a batch of logs.\n    const requestedLogs = await baseQuery\n      .select([\n        \"source_id\",\n\n        \"logs.address as log_address\",\n        \"logs.blockHash as log_blockHash\",\n        \"logs.blockNumber as log_blockNumber\",\n        \"logs.chainId as log_chainId\",\n        \"logs.data as log_data\",\n        \"logs.id as log_id\",\n        \"logs.logIndex as log_logIndex\",\n        \"logs.topic0 as log_topic0\",\n        \"logs.topic1 as log_topic1\",\n        \"logs.topic2 as log_topic2\",\n        \"logs.topic3 as log_topic3\",\n        \"logs.transactionHash as log_transactionHash\",\n        \"logs.transactionIndex as log_transactionIndex\",\n\n        \"blocks.baseFeePerGas as block_baseFeePerGas\",\n        \"blocks.difficulty as block_difficulty\",\n        \"blocks.extraData as block_extraData\",\n        \"blocks.gasLimit as block_gasLimit\",\n        \"blocks.gasUsed as block_gasUsed\",\n        \"blocks.hash as block_hash\",\n        \"blocks.logsBloom as block_logsBloom\",\n        \"blocks.miner as block_miner\",\n        \"blocks.mixHash as block_mixHash\",\n        \"blocks.nonce as block_nonce\",\n        \"blocks.number as block_number\",\n        \"blocks.parentHash as block_parentHash\",\n        \"blocks.receiptsRoot as block_receiptsRoot\",\n        \"blocks.sha3Uncles as block_sha3Uncles\",\n        \"blocks.size as block_size\",\n        \"blocks.stateRoot as block_stateRoot\",\n        \"blocks.timestamp as block_timestamp\",\n        \"blocks.totalDifficulty as block_totalDifficulty\",\n        \"blocks.transactionsRoot as block_transactionsRoot\",\n\n        \"transactions.accessList as tx_accessList\",\n        \"transactions.blockHash as tx_blockHash\",\n        \"transactions.blockNumber as tx_blockNumber\",\n        \"transactions.from as tx_from\",\n        \"transactions.gas as tx_gas\",\n        \"transactions.gasPrice as tx_gasPrice\",\n        \"transactions.hash as tx_hash\",\n        \"transactions.input as tx_input\",\n        \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n        \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n        \"transactions.nonce as tx_nonce\",\n        \"transactions.r as tx_r\",\n        \"transactions.s as tx_s\",\n        \"transactions.to as tx_to\",\n        \"transactions.transactionIndex as tx_transactionIndex\",\n        \"transactions.type as tx_type\",\n        \"transactions.value as tx_value\",\n        \"transactions.v as tx_v\",\n      ])\n      .where((eb) => this.buildCheckpointCmprs(eb, \">\", fromCheckpoint))\n      .where((eb) => this.buildCheckpointCmprs(eb, \"<=\", toCheckpoint))\n      .orderBy(\"blocks.timestamp\", \"asc\")\n      .orderBy(\"logs.chainId\", \"asc\")\n      .orderBy(\"blocks.number\", \"asc\")\n      .orderBy(\"logs.logIndex\", \"asc\")\n      .limit(limit + 1)\n      .execute();\n\n    const events = requestedLogs.map((_row) => {\n      // Without this cast, the block_ and tx_ fields are all nullable\n      // which makes this very annoying. Should probably add a runtime check\n      // that those fields are indeed present before continuing here.\n      const row = _row as NonNull<(typeof requestedLogs)[number]>;\n      return {\n        sourceId: row.source_id,\n        chainId: row.log_chainId,\n        log: {\n          address: checksumAddress(row.log_address),\n          blockHash: row.log_blockHash,\n          blockNumber: decodeToBigInt(row.log_blockNumber),\n          data: row.log_data,\n          id: row.log_id as Log[\"id\"],\n          logIndex: Number(row.log_logIndex),\n          removed: false,\n          topics: [\n            row.log_topic0,\n            row.log_topic1,\n            row.log_topic2,\n            row.log_topic3,\n          ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n          transactionHash: row.log_transactionHash,\n          transactionIndex: Number(row.log_transactionIndex),\n        },\n        block: {\n          baseFeePerGas: row.block_baseFeePerGas\n            ? decodeToBigInt(row.block_baseFeePerGas)\n            : null,\n          difficulty: decodeToBigInt(row.block_difficulty),\n          extraData: row.block_extraData,\n          gasLimit: decodeToBigInt(row.block_gasLimit),\n          gasUsed: decodeToBigInt(row.block_gasUsed),\n          hash: row.block_hash,\n          logsBloom: row.block_logsBloom,\n          miner: checksumAddress(row.block_miner),\n          mixHash: row.block_mixHash,\n          nonce: row.block_nonce,\n          number: decodeToBigInt(row.block_number),\n          parentHash: row.block_parentHash,\n          receiptsRoot: row.block_receiptsRoot,\n          sha3Uncles: row.block_sha3Uncles,\n          size: decodeToBigInt(row.block_size),\n          stateRoot: row.block_stateRoot,\n          timestamp: decodeToBigInt(row.block_timestamp),\n          totalDifficulty: decodeToBigInt(row.block_totalDifficulty),\n          transactionsRoot: row.block_transactionsRoot,\n        },\n        transaction: {\n          blockHash: row.tx_blockHash,\n          blockNumber: decodeToBigInt(row.tx_blockNumber),\n          from: checksumAddress(row.tx_from),\n          gas: decodeToBigInt(row.tx_gas),\n          hash: row.tx_hash,\n          input: row.tx_input,\n          nonce: Number(row.tx_nonce),\n          r: row.tx_r,\n          s: row.tx_s,\n          to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n          transactionIndex: Number(row.tx_transactionIndex),\n          value: decodeToBigInt(row.tx_value),\n          v: decodeToBigInt(row.tx_v),\n          ...(row.tx_type === \"0x0\"\n            ? {\n                type: \"legacy\",\n                gasPrice: decodeToBigInt(row.tx_gasPrice),\n              }\n            : row.tx_type === \"0x1\"\n              ? {\n                  type: \"eip2930\",\n                  gasPrice: decodeToBigInt(row.tx_gasPrice),\n                  accessList: JSON.parse(row.tx_accessList),\n                }\n              : row.tx_type === \"0x2\"\n                ? {\n                    type: \"eip1559\",\n                    maxFeePerGas: decodeToBigInt(row.tx_maxFeePerGas),\n                    maxPriorityFeePerGas: decodeToBigInt(\n                      row.tx_maxPriorityFeePerGas,\n                    ),\n                  }\n                : row.tx_type === \"0x7e\"\n                  ? {\n                      type: \"deposit\",\n                      maxFeePerGas: row.tx_maxFeePerGas\n                        ? decodeToBigInt(row.tx_maxFeePerGas)\n                        : undefined,\n                      maxPriorityFeePerGas: row.tx_maxPriorityFeePerGas\n                        ? decodeToBigInt(row.tx_maxPriorityFeePerGas)\n                        : undefined,\n                    }\n                  : {\n                      type: row.tx_type,\n                    }),\n        },\n      } satisfies {\n        sourceId: string;\n        chainId: number;\n        log: Log;\n        block: Block;\n        transaction: Transaction;\n      };\n    });\n\n    // Query for the checkpoint of the last event in the requested range (ignore the batch limit)\n    const lastCheckpointRows = await baseQuery\n      .select([\n        \"blocks.timestamp as block_timestamp\",\n        \"logs.chainId as log_chainId\",\n        \"blocks.number as block_number\",\n        \"logs.logIndex as log_logIndex\",\n      ])\n      .where((eb) => this.buildCheckpointCmprs(eb, \"<=\", toCheckpoint))\n      .orderBy(\"blocks.timestamp\", \"desc\")\n      .orderBy(\"logs.chainId\", \"desc\")\n      .orderBy(\"blocks.number\", \"desc\")\n      .orderBy(\"logs.logIndex\", \"desc\")\n      .limit(1)\n      .execute();\n\n    const lastCheckpointRow = lastCheckpointRows[0];\n    const lastCheckpoint =\n      lastCheckpointRow !== undefined\n        ? ({\n            blockTimestamp: Number(\n              decodeToBigInt(lastCheckpointRow.block_timestamp!),\n            ),\n            blockNumber: Number(\n              decodeToBigInt(lastCheckpointRow.block_number!),\n            ),\n            chainId: lastCheckpointRow.log_chainId,\n            logIndex: lastCheckpointRow.log_logIndex,\n          } satisfies Checkpoint)\n        : undefined;\n\n    this.record(\"getLogEvents\", performance.now() - start);\n\n    if (events.length === limit + 1) {\n      events.pop();\n\n      const lastEventInPage = events[events.length - 1];\n      const lastCheckpointInPage = {\n        blockTimestamp: Number(lastEventInPage.block.timestamp),\n        chainId: lastEventInPage.chainId,\n        blockNumber: Number(lastEventInPage.block.number),\n        logIndex: lastEventInPage.log.logIndex,\n      } satisfies Checkpoint;\n\n      return {\n        events,\n        hasNextPage: true,\n        lastCheckpointInPage,\n        lastCheckpoint,\n      } as const;\n    } else {\n      return {\n        events,\n        hasNextPage: false,\n        lastCheckpointInPage: undefined,\n        lastCheckpoint,\n      } as const;\n    }\n  }\n\n  /**\n   * Builds an expression that filters for events that are greater or\n   * less than the provided checkpoint. If the log index is not specific,\n   * the expression will use a block-level granularity.\n   */\n  private buildCheckpointCmprs = (\n    eb: ExpressionBuilder<any, any>,\n    op: \">\" | \">=\" | \"<\" | \"<=\",\n    checkpoint: Checkpoint,\n  ) => {\n    const { and, or } = eb;\n\n    const { blockTimestamp, chainId, blockNumber, logIndex } = checkpoint;\n\n    const operand = op.startsWith(\">\") ? (\">\" as const) : (\"<\" as const);\n    const operandOrEquals = `${operand}=` as const;\n    const isInclusive = op.endsWith(\"=\");\n\n    // If the execution index is not defined, the checkpoint is at block granularity.\n    // Include (or exclude) all events in the block.\n    if (logIndex === undefined) {\n      return and([\n        eb(\"blocks.timestamp\", operandOrEquals, encodeAsText(blockTimestamp)),\n        or([\n          eb(\"blocks.timestamp\", operand, encodeAsText(blockTimestamp)),\n          and([\n            eb(\"logs.chainId\", operandOrEquals, chainId),\n            or([\n              eb(\"logs.chainId\", operand, chainId),\n              eb(\n                \"blocks.number\",\n                isInclusive ? operandOrEquals : operand,\n                encodeAsText(blockNumber),\n              ),\n            ]),\n          ]),\n        ]),\n      ]);\n    }\n\n    // Otherwise, apply the filter down to the log index.\n    return and([\n      eb(\"blocks.timestamp\", operandOrEquals, encodeAsText(blockTimestamp)),\n      or([\n        eb(\"blocks.timestamp\", operand, encodeAsText(blockTimestamp)),\n        and([\n          eb(\"logs.chainId\", operandOrEquals, chainId),\n          or([\n            eb(\"logs.chainId\", operand, chainId),\n            and([\n              eb(\"blocks.number\", operandOrEquals, encodeAsText(blockNumber)),\n              or([\n                eb(\"blocks.number\", operand, encodeAsText(blockNumber)),\n                eb(\n                  \"logs.logIndex\",\n                  isInclusive ? operandOrEquals : operand,\n                  logIndex,\n                ),\n              ]),\n            ]),\n          ]),\n        ]),\n      ]),\n    ]);\n  };\n\n  private buildLogFilterCmprs = ({\n    eb,\n    logFilter,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    logFilter: {\n      id: string;\n      chainId: number;\n      criteria: LogFilterCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n    };\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"source_id\", \"=\", logFilter.id));\n    exprs.push(eb(\"logs.chainId\", \"=\", logFilter.chainId));\n\n    if (logFilter.criteria.address) {\n      // If it's an array of length 1, collapse it.\n      const address =\n        Array.isArray(logFilter.criteria.address) &&\n        logFilter.criteria.address.length === 1\n          ? logFilter.criteria.address[0]\n          : logFilter.criteria.address;\n      if (Array.isArray(address)) {\n        exprs.push(eb.or(address.map((a) => eb(\"logs.address\", \"=\", a))));\n      } else {\n        exprs.push(eb(\"logs.address\", \"=\", address));\n      }\n    }\n\n    if (logFilter.criteria.topics) {\n      for (const idx_ of range(0, 4)) {\n        const idx = idx_ as 0 | 1 | 2 | 3;\n        // If it's an array of length 1, collapse it.\n        const raw = logFilter.criteria.topics[idx] ?? null;\n        if (raw === null) continue;\n        const topic = Array.isArray(raw) && raw.length === 1 ? raw[0] : raw;\n        if (Array.isArray(topic)) {\n          exprs.push(eb.or(topic.map((a) => eb(`logs.topic${idx}`, \"=\", a))));\n        } else {\n          exprs.push(eb(`logs.topic${idx}`, \"=\", topic));\n        }\n      }\n    }\n\n    if (logFilter.fromBlock)\n      exprs.push(eb(\"blocks.number\", \">=\", encodeAsText(logFilter.fromBlock)));\n    if (logFilter.toBlock)\n      exprs.push(eb(\"blocks.number\", \"<=\", encodeAsText(logFilter.toBlock)));\n\n    return exprs;\n  };\n\n  private buildFactoryCmprs = ({\n    eb,\n    factory,\n  }: {\n    eb: ExpressionBuilder<any, any>;\n    factory: {\n      id: string;\n      chainId: number;\n      criteria: FactoryCriteria;\n      fromBlock?: number;\n      toBlock?: number;\n    };\n  }) => {\n    const exprs = [];\n\n    exprs.push(eb(\"source_id\", \"=\", factory.id));\n    exprs.push(eb(\"logs.chainId\", \"=\", factory.chainId));\n\n    const selectChildAddressExpression =\n      buildFactoryChildAddressSelectExpression({\n        childAddressLocation: factory.criteria.childAddressLocation,\n      });\n\n    exprs.push(\n      eb(\n        \"logs.address\",\n        \"in\",\n        eb\n          .selectFrom(\"logs\")\n          .select(selectChildAddressExpression.as(\"childAddress\"))\n          .where(\"chainId\", \"=\", factory.chainId)\n          .where(\"address\", \"=\", factory.criteria.address)\n          .where(\"topic0\", \"=\", factory.criteria.eventSelector),\n      ),\n    );\n\n    if (factory.fromBlock)\n      exprs.push(eb(\"blocks.number\", \">=\", encodeAsText(factory.fromBlock)));\n    if (factory.toBlock)\n      exprs.push(eb(\"blocks.number\", \"<=\", encodeAsText(factory.toBlock)));\n\n    return exprs;\n  };\n\n  private transaction = async <U>(\n    callback: (tx: KyselyTransaction<SyncStoreTables>) => Promise<U>,\n  ) => {\n    return await this.db.transaction().execute(async (tx) => {\n      return await Promise.race([\n        callback(tx),\n        wait(15_000).then(() => {\n          throw new Error(\"SQLite transaction timed out after 15 seconds.\");\n        }),\n      ]);\n    });\n  };\n\n  private record(methodName: string, duration: number) {\n    this.common.metrics.ponder_sync_store_method_duration.observe(\n      { method: methodName },\n      duration,\n    );\n  }\n}\n\nfunction buildFactoryChildAddressSelectExpression({\n  childAddressLocation,\n}: {\n  childAddressLocation: FactoryCriteria[\"childAddressLocation\"];\n}) {\n  if (childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(childAddressLocation.substring(6));\n    const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(data, ${start}, ${length})`;\n  } else {\n    const start = 2 + 12 * 2 + 1;\n    const length = 20 * 2;\n    return sql<Hex>`'0x' || substring(${sql.ref(\n      childAddressLocation,\n    )}, ${start}, ${length})`;\n  }\n}\n","import type { Generated, Insertable } from \"kysely\";\nimport type { Address, Hash, Hex } from \"viem\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\n\nimport { encodeAsText } from \"@/utils/encoding.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\n\nexport type BigIntText = string;\n\ntype BlocksTable = {\n  baseFeePerGas: BigIntText | null;\n  difficulty: BigIntText;\n  extraData: Hex;\n  gasLimit: BigIntText;\n  gasUsed: BigIntText;\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  number: BigIntText;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash;\n  size: BigIntText;\n  stateRoot: Hash;\n  timestamp: BigIntText;\n  totalDifficulty: BigIntText;\n  transactionsRoot: Hash;\n\n  chainId: number;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToSqliteBlock(\n  block: RpcBlock,\n): Omit<InsertableBlock, \"chainId\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas\n      ? encodeAsText(block.baseFeePerGas)\n      : null,\n    difficulty: encodeAsText(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: encodeAsText(block.gasLimit),\n    gasUsed: encodeAsText(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    number: encodeAsText(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles,\n    size: encodeAsText(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: encodeAsText(block.timestamp),\n    totalDifficulty: encodeAsText(block.totalDifficulty!),\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  from: Address;\n  gas: BigIntText;\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex;\n  s: Hex;\n  to: Address | null;\n  transactionIndex: number;\n  v: BigIntText;\n  value: BigIntText;\n\n  type: Hex;\n  gasPrice: BigIntText | null;\n  maxFeePerGas: BigIntText | null;\n  maxPriorityFeePerGas: BigIntText | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToSqliteTransaction(\n  transaction: RpcTransaction,\n): Omit<InsertableTransaction, \"chainId\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: encodeAsText(transaction.blockNumber!),\n    from: toLowerCase(transaction.from),\n    gas: encodeAsText(transaction.gas),\n    gasPrice: transaction.gasPrice ? encodeAsText(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? encodeAsText(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? encodeAsText(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r,\n    s: transaction.s,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: encodeAsText(transaction.value),\n    v: encodeAsText(transaction.v),\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: BigIntText;\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n\n  chainId: number;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToSqliteLog(log: RpcLog): Omit<InsertableLog, \"chainId\"> {\n  return {\n    address: toLowerCase(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: encodeAsText(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype RpcRequestResultsTable = {\n  blockNumber: BigIntText;\n  chainId: number;\n  result: string;\n  request: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\ntype FactoriesTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: BigIntText;\n  endBlock: BigIntText;\n};\n\nexport type SyncStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  logs: LogsTable;\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factories: FactoriesTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n};\n","import type { Kysely } from \"kysely\";\nimport { type Migration, type MigrationProvider } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", \"blob\") // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses SQLite's ROWID() function (simple autoincrement).\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"varchar(79)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"varchar(79)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"varchar(79)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"varchar(79)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"v\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"varchar(79)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"varchar(79)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      // SQLite doesn't support dropping NOT NULL constraints. As a workaround:\n      // 1) Create a new column of the same type without NOT NULL.\n      // 2) Copy data from the old column to the new column.\n      // 3) Drop the old column.\n      // 4) Rename the new column to the old column's name.\n\n      // Drop NOT NULL constraint from \"blocks.mixHash\".\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"mixHash_temp_null\", \"varchar(66)\")\n        .execute();\n      await db\n        .updateTable(\"blocks\")\n        .set((eb: any) => ({\n          mixHash_temp_null: eb.selectFrom(\"blocks\").select(\"mixHash\"),\n        }))\n        .execute();\n      await db.schema.alterTable(\"blocks\").dropColumn(\"mixHash\").execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .renameColumn(\"mixHash_temp_null\", \"mixHash\")\n        .execute();\n\n      // Drop NOT NULL constraint from \"blocks.nonce\".\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"nonce_temp_null\", \"varchar(18)\")\n        .execute();\n      await db\n        .updateTable(\"blocks\")\n        .set((eb: any) => ({\n          nonce_temp_null: eb.selectFrom(\"blocks\").select(\"nonce\"),\n        }))\n        .execute();\n      await db.schema.alterTable(\"blocks\").dropColumn(\"nonce\").execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .renameColumn(\"nonce_temp_null\", \"nonce\")\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n","import { createHash } from \"node:crypto\";\nimport fs from \"node:fs\";\n\nimport { randomBytes } from \"crypto\";\nimport os from \"os\";\nimport path from \"path\";\nimport Conf from \"conf\";\n// @ts-ignore\nimport { detect, getNpmVersion } from \"detect-package-manager\";\nimport PQueue from \"p-queue\";\nimport pc from \"picocolors\";\nimport process from \"process\";\n\nimport type { Options } from \"@/config/options.js\";\nimport { getGitRemoteUrl } from \"@/telemetry/remote.js\";\nimport { wait } from \"@/utils/wait.js\";\n\ntype TelemetryEvent = {\n  event: string;\n  properties?: any;\n};\n\ntype TelemetryDeviceConfig = {\n  enabled: boolean;\n  notifiedAt: string;\n  anonymousId: string;\n  salt: string;\n};\n\ntype TelemetryEventContext = {\n  projectId: string;\n  sessionId: string;\n  packageManager: string;\n  packageManagerVersion: string;\n  nodeVersion: string;\n  ponderVersion: string;\n  systemPlatform: NodeJS.Platform;\n  systemRelease: string;\n  systemArchitecture: string;\n  cpuCount: number;\n  cpuModel: string | null;\n  cpuSpeed: number | null;\n  memoryInMb: number;\n  isExampleProject: boolean;\n};\n\nexport class TelemetryService {\n  private options: Options;\n  private conf: Conf<TelemetryDeviceConfig>;\n\n  private queue = new PQueue({ concurrency: 1 });\n  private events: TelemetryEvent[] = [];\n\n  private controller = new AbortController();\n  private context?: TelemetryEventContext;\n  private heartbeatIntervalId?: NodeJS.Timeout;\n\n  constructor({ options }: { options: Options }) {\n    this.options = options;\n    this.conf = new Conf({ projectName: \"ponder\" });\n    this.notify();\n    this.heartbeatIntervalId = setInterval(() => {\n      this.record({ event: \"Heartbeat\" });\n    }, 60_000);\n  }\n\n  record(event: TelemetryEvent) {\n    if (this.disabled) return;\n    this.events.push(event);\n    this.queue.add(() => this.processEvent());\n  }\n\n  async flush() {\n    await this.queue.onIdle();\n  }\n\n  private processEvent = async () => {\n    const event = this.events.pop();\n    if (!event) return;\n\n    // Build the context. If it's already been built, this will return immediately.\n    try {\n      await this.getContext();\n    } catch (e) {\n      // Do nothing\n    }\n\n    // See https://segment.com/docs/connections/spec/track\n    const serializedEvent = {\n      ...event,\n      anonymousId: this.anonymousId,\n      context: this.context,\n    };\n\n    try {\n      await fetch(this.options.telemetryUrl, {\n        method: \"POST\",\n        body: JSON.stringify(serializedEvent),\n        headers: { \"Content-Type\": \"application/json\" },\n        signal: this.controller.signal,\n      });\n    } catch (e) {\n      // Do nothing\n    }\n  };\n\n  async kill() {\n    clearInterval(this.heartbeatIntervalId);\n    this.queue.pause();\n    this.queue.clear();\n    await Promise.race([wait(500), this.queue.onIdle()]);\n    if (this.queue.pending > 0) {\n      this.controller.abort();\n    }\n  }\n\n  private notify() {\n    if (\n      this.disabled ||\n      this.conf.get(\"notifiedAt\") ||\n      process.env.NODE_ENV === \"test\"\n    ) {\n      return;\n    }\n\n    this.conf.set(\"notifiedAt\", Date.now().toString());\n\n    console.log(\n      `${pc.magenta(\n        \"Attention\",\n      )}: Ponder collects anonymous telemetry data to identify issues and prioritize features. See https://ponder.sh/advanced/telemetry for more information.`,\n    );\n  }\n\n  get disabled() {\n    return (\n      this.options.telemetryDisabled ||\n      (this.conf.has(\"enabled\") && !this.conf.get(\"enabled\"))\n    );\n  }\n\n  private get anonymousId() {\n    const storedAnonymousId = this.conf.get(\"anonymousId\");\n    if (storedAnonymousId) return storedAnonymousId;\n\n    const createdId = randomBytes(32).toString(\"hex\");\n    this.conf.set(\"anonymousId\", createdId);\n    return createdId;\n  }\n\n  private get salt() {\n    const storedSalt = this.conf.get(\"salt\");\n    if (storedSalt) return storedSalt;\n\n    const createdSalt = randomBytes(32).toString(\"hex\");\n    this.conf.set(\"salt\", createdSalt);\n    return createdSalt;\n  }\n\n  private oneWayHash(value: string) {\n    const hash = createHash(\"sha256\");\n    // Always prepend the payload value with salt. This ensures the hash is truly\n    // one-way.\n    hash.update(this.salt);\n    hash.update(value);\n    return hash.digest(\"hex\");\n  }\n\n  private async getContext() {\n    if (this.context) return this.context;\n\n    const sessionId = randomBytes(32).toString(\"hex\");\n    const projectIdRaw = (await getGitRemoteUrl()) ?? process.cwd();\n    const projectId = this.oneWayHash(projectIdRaw);\n\n    let packageManager: any = \"unknown\";\n    let packageManagerVersion: any = \"unknown\";\n    try {\n      packageManager = await detect();\n      packageManagerVersion = await getNpmVersion(packageManager);\n    } catch (e) {\n      // Ignore\n    }\n\n    const packageJsonCwdPath = path.join(process.cwd(), \"package.json\");\n    const packageJsonRootPath = path.join(this.options.rootDir, \"package.json\");\n    const packageJsonPath = fs.existsSync(packageJsonCwdPath)\n      ? packageJsonCwdPath\n      : fs.existsSync(packageJsonRootPath)\n        ? packageJsonRootPath\n        : undefined;\n    const packageJson = packageJsonPath\n      ? JSON.parse(fs.readFileSync(\"package.json\", \"utf8\"))\n      : undefined;\n    const ponderVersion = packageJson\n      ? packageJson.dependencies[\"@ponder/core\"]\n      : \"unknown\";\n\n    const cpus = os.cpus() || [];\n\n    this.context = {\n      sessionId,\n      projectId,\n      nodeVersion: process.version,\n      packageManager,\n      packageManagerVersion,\n      ponderVersion,\n      systemPlatform: os.platform(),\n      systemRelease: os.release(),\n      systemArchitecture: os.arch(),\n      cpuCount: cpus.length,\n      cpuModel: cpus.length ? cpus[0].model : null,\n      cpuSpeed: cpus.length ? cpus[0].speed : null,\n      memoryInMb: Math.trunc(os.totalmem() / 1024 ** 2),\n      isExampleProject: this.options.telemetryIsExampleProject,\n    } satisfies TelemetryEventContext;\n\n    return this.context;\n  }\n}\n","import { exec } from \"child_process\";\n\nexport async function getGitRemoteUrl() {\n  try {\n    let resolve: (value: Buffer | string) => void;\n    let reject: (err: Error) => void;\n    const promise = new Promise<Buffer | string>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    exec(\n      \"git config --local --get remote.origin.url\",\n      {\n        timeout: 1000,\n        windowsHide: true,\n      },\n      (error: null | Error, stdout: Buffer | string) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(stdout);\n      },\n    );\n\n    return String(await promise).trim();\n  } catch (_) {\n    return null;\n  }\n}\n","import { Box, Text, render as inkRender } from \"ink\";\nimport React from \"react\";\n\nimport type { Source } from \"@/config/sources.js\";\n\nimport { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport { ProgressBar } from \"./ProgressBar.js\";\n\nexport type UiState = {\n  port: number;\n\n  historicalSyncStats: {\n    network: string;\n    contract: string;\n    rate: number;\n    eta?: number;\n  }[];\n  isHistoricalSyncComplete: boolean;\n\n  realtimeSyncNetworks: {\n    name: string;\n    isConnected: boolean;\n  }[];\n\n  indexingStats: {\n    event: string;\n    totalSeconds: number | undefined;\n    completedSeconds: number | undefined;\n    completedEventCount: number;\n  }[];\n  indexingCompletedToTimestamp: number;\n  indexingError: boolean;\n};\n\nexport const buildUiState = ({ sources }: { sources: Source[] }) => {\n  const ui: UiState = {\n    port: 0,\n\n    historicalSyncStats: [],\n    isHistoricalSyncComplete: false,\n    realtimeSyncNetworks: [],\n\n    indexingStats: [],\n    indexingCompletedToTimestamp: 0,\n    indexingError: false,\n  };\n\n  sources.forEach((source) => {\n    ui.historicalSyncStats.push({\n      network: source.networkName,\n      contract: source.contractName,\n      rate: 0,\n    });\n  });\n\n  return ui;\n};\n\nconst App = (ui: UiState) => {\n  const {\n    port,\n    historicalSyncStats,\n    // isHistoricalSyncComplete,\n    // TODO: Consider adding realtime back into the UI in some manner.\n    // realtimeSyncNetworks,\n    indexingStats,\n    indexingError,\n  } = ui;\n\n  if (indexingError) {\n    return (\n      <Box flexDirection=\"column\">\n        <Text> </Text>\n\n        <Text color=\"cyan\">\n          Resolve the error and save your changes to reload the server.\n        </Text>\n      </Box>\n    );\n  }\n\n  const maxWidth = process.stdout.columns || 80;\n\n  const titleWidth = Math.max(\n    ...historicalSyncStats.map((s) => s.contract.length + s.network.length + 4),\n    ...indexingStats.map((s) => s.event.length + 1),\n  );\n\n  const maxEventCount = Math.max(\n    ...indexingStats.map((s) => s.completedEventCount),\n  );\n  const metricsWidth = 15 + maxEventCount.toString().length;\n\n  const barWidth = Math.min(\n    Math.max(maxWidth - titleWidth - metricsWidth - 12, 24),\n    48,\n  );\n\n  return (\n    <Box flexDirection=\"column\">\n      <Text> </Text>\n\n      <Box flexDirection=\"row\">\n        <Text bold={true}>Historical sync</Text>\n      </Box>\n      <Box flexDirection=\"column\">\n        {historicalSyncStats.map(({ contract, network, rate, eta }) => {\n          const etaText = eta ? ` | ~${formatEta(eta)}` : \"\";\n          const rateText = formatPercentage(rate);\n\n          const titleText = `${contract} (${network})`.padEnd(titleWidth, \" \");\n          const metricsText =\n            rate === 1 ? (\n              <Text color=\"greenBright\">done</Text>\n            ) : (\n              `${rateText}${etaText}`\n            );\n\n          return (\n            <Box flexDirection=\"column\" key={`${contract}-${network}`}>\n              <Box flexDirection=\"row\">\n                <Text>{titleText} </Text>\n                <ProgressBar current={rate} end={1} width={barWidth} />\n                <Text> {metricsText}</Text>\n              </Box>\n            </Box>\n          );\n        })}\n      </Box>\n      <Text> </Text>\n\n      <Text bold={true}>Indexing </Text>\n      {indexingStats.map(\n        ({ event, totalSeconds, completedSeconds, completedEventCount }) => {\n          const rate =\n            totalSeconds === undefined ||\n            completedSeconds === undefined ||\n            totalSeconds === 0\n              ? 1\n              : completedSeconds / totalSeconds;\n\n          const titleText = event.padEnd(titleWidth, \" \");\n\n          const rateText =\n            rate === 1 ? (\n              <Text color=\"greenBright\">done</Text>\n            ) : (\n              formatPercentage(rate)\n            );\n\n          return (\n            <Box flexDirection=\"column\" key={event}>\n              <Box flexDirection=\"row\">\n                <Text>{titleText} </Text>\n                {completedSeconds !== undefined &&\n                totalSeconds !== undefined ? (\n                  <>\n                    <ProgressBar current={rate} end={1} width={barWidth} />\n                    <Text>\n                      {\" \"}\n                      {rateText} ({completedEventCount} events)\n                    </Text>\n                  </>\n                ) : (\n                  <Text>Waiting to start...</Text>\n                )}\n              </Box>\n            </Box>\n          );\n        },\n      )}\n      <Text> </Text>\n\n      {/* {realtimeSyncNetworks.length > 0 && (\n        <Box flexDirection=\"column\">\n          <Text bold={true}>Realtime sync </Text>\n          {realtimeSyncNetworks.map(({ name, isConnected }) => (\n            <Box flexDirection=\"row\" key={name}>\n              <Text>\n                {name.slice(0, 1).toUpperCase() + name.slice(1)} (\n                {isConnected ? \"live\" : \"disconnected\"})\n              </Text>\n            </Box>\n          ))}\n          <Text> </Text>\n        </Box>\n      )} */}\n\n      {true && (\n        <Box flexDirection=\"column\">\n          <Text bold={true}>GraphQL </Text>\n          <Box flexDirection=\"row\">\n            <Text>Server live at http://localhost:{port}</Text>\n          </Box>\n        </Box>\n      )}\n    </Box>\n  );\n};\n\nexport const setupInkApp = (ui: UiState) => {\n  const { rerender, unmount: inkUnmount, clear } = inkRender(<App {...ui} />);\n\n  const render = (ui: UiState) => {\n    rerender(<App {...ui} />);\n  };\n\n  const unmount = () => {\n    clear();\n    inkUnmount();\n  };\n  return { render, unmount };\n};\n","import { Text } from \"ink\";\nimport React from \"react\";\n\nexport const ProgressBar = ({ current = 5, end = 10, width = 36 }) => {\n  const maxCount = width || process.stdout.columns || 80;\n\n  const fraction = current / end;\n  const count = Math.min(Math.floor(maxCount * fraction), maxCount);\n\n  return (\n    <Text>\n      <Text>{\"█\".repeat(count)}</Text>\n      <Text>{\"░\".repeat(maxCount - count)}</Text>\n    </Text>\n  );\n};\n","import type { Common } from \"@/Ponder.js\";\nimport type { Source } from \"@/config/sources.js\";\nimport { getHistoricalSyncStats } from \"@/metrics/utils.js\";\n\nimport { type UiState, buildUiState, setupInkApp } from \"./app.js\";\n\nexport class UiService {\n  private common: Common;\n  private sources: Source[];\n\n  ui: UiState;\n  renderInterval: NodeJS.Timeout;\n  render: () => void;\n  unmount: () => void;\n\n  constructor({ common, sources }: { common: Common; sources: Source[] }) {\n    this.common = common;\n    this.sources = sources;\n\n    this.ui = buildUiState({ sources: this.sources });\n\n    if (this.common.options.uiEnabled) {\n      const { render, unmount } = setupInkApp(this.ui);\n      this.render = () => render(this.ui);\n      this.unmount = unmount;\n    } else {\n      this.render = () => undefined;\n      this.unmount = () => undefined;\n    }\n\n    this.renderInterval = setInterval(async () => {\n      // Historical sync\n\n      this.ui.historicalSyncStats = await getHistoricalSyncStats({\n        metrics: this.common.metrics,\n        sources: this.sources,\n      });\n\n      const minRate = Math.min(\n        ...this.ui.historicalSyncStats.map((s) => s.rate),\n      );\n\n      if (!this.ui.isHistoricalSyncComplete && minRate === 1) {\n        this.ui.isHistoricalSyncComplete = true;\n      }\n\n      // Realtime sync\n      const connectedNetworks = (\n        await this.common.metrics.ponder_realtime_is_connected.get()\n      ).values\n        .filter((m) => m.value === 1)\n        .map((m) => m.labels.network)\n        .filter((n): n is string => typeof n === \"string\");\n      const allNetworks = [\n        ...new Set(\n          this.sources\n            .filter((s) => s.endBlock === undefined)\n            .map((s) => s.networkName),\n        ),\n      ];\n\n      this.ui.realtimeSyncNetworks = allNetworks.map((networkName) => ({\n        name: networkName,\n        isConnected: connectedNetworks.includes(networkName),\n      }));\n\n      // Indexing\n      const totalSecondsMetric = (\n        await this.common.metrics.ponder_indexing_total_seconds.get()\n      ).values;\n      const completedSecondsMetric = (\n        await this.common.metrics.ponder_indexing_completed_seconds.get()\n      ).values;\n      const completedEventsMetric = (\n        await this.common.metrics.ponder_indexing_completed_events.get()\n      ).values;\n\n      const eventNames = totalSecondsMetric.map(\n        (m) => m.labels.event as string,\n      );\n\n      this.ui.indexingStats = eventNames.map((event) => {\n        const totalSeconds = totalSecondsMetric.find(\n          (m) => m.labels.event === event,\n        )?.value;\n        const completedSeconds = completedSecondsMetric.find(\n          (m) => m.labels.event === event,\n        )?.value;\n        const completedEventCount = completedEventsMetric\n          .filter((m) => m.labels.event === event)\n          .reduce((a, v) => a + v.value, 0);\n\n        return { event, totalSeconds, completedSeconds, completedEventCount };\n      });\n\n      const indexingCompletedToTimestamp =\n        (await this.common.metrics.ponder_indexing_completed_timestamp.get())\n          .values[0].value ?? 0;\n      this.ui.indexingCompletedToTimestamp = indexingCompletedToTimestamp;\n\n      // Server\n      const port = (await this.common.metrics.ponder_server_port.get())\n        .values[0].value;\n      this.ui.port = port;\n\n      this.render();\n    }, 17);\n  }\n\n  resetHistoricalState() {\n    this.ui.isHistoricalSyncComplete = false;\n  }\n\n  kill() {\n    clearInterval(this.renderInterval);\n    this.unmount();\n  }\n}\n","import type { Network } from \"@/config/networks.js\";\nimport type { MetricsService } from \"@/metrics/service.js\";\nimport { type EIP1193Parameters, type PublicRpcSchema } from \"viem\";\nimport { startClock } from \"./timer.js\";\n\ntype RequestReturnType<\n  method extends EIP1193Parameters<PublicRpcSchema>[\"method\"],\n> = Promise<Extract<PublicRpcSchema[number], { Method: method }>[\"ReturnType\"]>;\n\nexport type RequestQueue = {\n  /**\n   * Add a task to the queue.\n   * Lower block number means higher priority for historical tasks.\n   */\n  request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n    params: TParameters,\n  ) => RequestReturnType<TParameters[\"method\"]>;\n  /** Number of unsent requests. */\n  size: () => Promise<number>;\n  /** Number of pending requests. */\n  pending: () => Promise<number>;\n  /** Start execution of the tasks. */\n  start: () => void;\n  /** Pause execution of the tasks. */\n  pause: () => void;\n  /** Returns a promise that resolves when the queue is empty and all tasks have resolved. */\n  onIdle: () => Promise<void>;\n  /** Clear tasks from the queue. */\n  clear: () => void;\n  /** Internal tasks in the queue */\n  queue: Task[];\n};\n\n/**\n * Internal representation of a task in the request queue.\n *\n * @param blockNumber The blockNumber (priority) of the task.\n * \"latest\" represents the highest priority. \"null\" represents lowest priority\n */\ntype Task = {\n  params: EIP1193Parameters<PublicRpcSchema>;\n  resolve: (value: unknown) => void;\n  reject: () => unknown;\n  stopClockLag: () => number;\n};\n\n/**\n * Creates a queue built to manage rpc requests.\n */\nexport const createRequestQueue = ({\n  metrics,\n  network,\n}: { network: Network; metrics: MetricsService }): RequestQueue => {\n  let queue: Task[] = new Array();\n  const interval =\n    1000 / network.maxRequestsPerSecond > 50\n      ? 1000 / network.maxRequestsPerSecond\n      : 50;\n  const requestBatchSize =\n    1000 / network.maxRequestsPerSecond > 50\n      ? 1\n      : Math.floor(network.maxRequestsPerSecond / 20);\n\n  let lastRequestTime = 0;\n  let timeout: NodeJS.Timeout | undefined = undefined;\n\n  const pendingRequests: Map<Task, Promise<unknown>> = new Map();\n\n  let isTimerOn = false;\n  let isStarted = true;\n\n  const processQueue = () => {\n    if (!isStarted) return;\n\n    if (queue.length === 0) return;\n    const now = Date.now();\n    let timeSinceLastRequest = now - lastRequestTime;\n\n    if (timeSinceLastRequest >= interval) {\n      lastRequestTime = now;\n\n      for (let i = 0; i < requestBatchSize; i++) {\n        const task = queue.shift()!;\n\n        metrics.ponder_rpc_request_lag.observe(\n          { method: task.params.method, network: network.name },\n          task.stopClockLag(),\n        );\n\n        const stopClock = startClock();\n\n        const p = network.transport\n          .request(task.params)\n          .then(task.resolve)\n          .catch(task.reject)\n          .finally(() => {\n            pendingRequests.delete(task);\n\n            metrics.ponder_rpc_request_duration.observe(\n              { method: task.params.method, network: network.name },\n              stopClock(),\n            );\n          });\n\n        pendingRequests.set(task, p);\n\n        if (queue.length === 0) break;\n      }\n\n      timeSinceLastRequest = 0;\n    }\n\n    if (!isTimerOn) {\n      isTimerOn = true;\n      timeout = setTimeout(() => {\n        isTimerOn = false;\n        processQueue();\n      }, interval - timeSinceLastRequest);\n    }\n  };\n\n  return {\n    request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n      params: TParameters,\n    ): RequestReturnType<TParameters[\"method\"]> => {\n      const stopClockLag = startClock();\n\n      const p = new Promise((resolve, reject) => {\n        queue.push({\n          params,\n          resolve,\n          reject,\n          stopClockLag,\n        });\n      });\n\n      processQueue();\n\n      return p as RequestReturnType<TParameters[\"method\"]>;\n    },\n    size: () =>\n      new Promise<number>((res) => setImmediate(() => res(queue.length))),\n    pending: () =>\n      new Promise<number>((res) =>\n        setImmediate(() => res(Object.keys(pendingRequests).length)),\n      ),\n    start: () => {\n      isStarted = true;\n      processQueue();\n    },\n    pause: () => {\n      isStarted = false;\n    },\n    onIdle: () => Promise.all(Object.values(pendingRequests)).then(() => {}),\n    clear: () => {\n      clearTimeout(timeout);\n      queue = new Array();\n      lastRequestTime = 0;\n    },\n    queue,\n  };\n};\n","/**\n * Measures the elapsed wall clock time in milliseconds (ms) between two points.\n * @returns A function returning the elapsed time in milliseconds (ms).\n */\nexport function startClock() {\n  const start = process.hrtime();\n  return () => hrTimeToMs(process.hrtime(start));\n}\n\n/**\n * Converts a process.hrtime() measurement to milliseconds (ms).\n * @returns The timestamp in milliseconds (ms).\n */\nexport function hrTimeToMs(diff: [number, number]) {\n  return Math.round(diff[0] * 1000 + diff[1] / 1000000);\n}\n"],"mappings":"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","names":["readFileSync","pc","existsSync","path","process","path","columnName","tableName","GraphQLBoolean","GraphQLInt","GraphQLObjectType","GraphQLString","GraphQLInt","GraphQLList","GraphQLString","GraphQLList","buildWhereObject","GraphQLInt","GraphQLString","graphqlFilterToStoreCondition","GraphQLInt","GraphQLNonNull","GraphQLNonNull","GraphQLInt","GraphQLInt","GraphQLString","GraphQLBoolean","GraphQLObjectType","getEventSelector","getEventSelector","transport","symbol","table","file","path","path","eventName","path","path","dirname","path","path","path","connectionString","source","path","query","row","Kysely","sql","MAX_BATCH_SIZE","DEFAULT_LIMIT","MAX_LIMIT","scalarToSqlType","Kysely","sql","query","row","E_CANCELED","Mutex","readFileSync","codeFrameColumns","parseStackTrace","path","MAX_BATCH_SIZE","E_CANCELED","Mutex","path","createServer","resolve","server","createServer","blockNumber","hexToNumber","toHex","resolve","queue","toHex","logs","fromBlock","toBlock","hexToNumber","poll","BlockNotFoundError","hexToNumber","numberToHex","hexToNumber","hexToNumber","numberToHex","block","BlockNotFoundError","fs","Kysely","PostgresDialect","sql","checksumAddress","hexToNumber","hexToNumber","sql","Kysely","PostgresDialect","sql","query","checksumAddress","Kysely","Migrator","SqliteDialect","sql","checksumAddress","hexToNumber","hexToNumber","migrations","StaticMigrationProvider","migrationProvider","Kysely","SqliteDialect","Migrator","migrationProvider","sql","buildFactoryChildAddressSelectExpression","query","checksumAddress","fs","path","PQueue","pc","process","resolve","PQueue","process","pc","path","packageJsonPath","fs","packageJson","Text","React","React","Text","ui","resolve","path","existsSync","process","readFileSync","pc"]}